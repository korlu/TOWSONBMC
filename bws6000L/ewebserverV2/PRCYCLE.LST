Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 1
prcycle.ASM



      1					 ;*******************************************************************************************
      2					 ***************CK/
      3					 ;prcycle.asm
      4					 ;Copyright 2002 Dept of Computer Science, Towson University
      5					 ;Coded	by: Dr.R.K Karne, Rajvardhan Gattu, Xubo Zhang and Ramesh Dandu
      6					 ;  Luyin Sun, Karthick	Venkatasamy
      7					 ;Date:	02/08/02
      8					 ;Date:	03/22/04
      9					 ;Date:	07/01/04
     10					 ;***************************************************************************
     11					 ;Conventions:
     12					 ;X: When X is displayed, we are at the	point of jump to prcycle in aoaboot.
     13					 ;Y: When Y is displayed, we sucessfully jumped	from aoaboot to	the prcycle.
     14					 ;P: When P is displayed, we have entered/re-entered PMode.
     15					 ;R: When R is displayed, we have entered/re-entered RMode.
     16					 ;Z: When Z is displayed, we have sucessfully exited from the program in RMode.
     17					 INCLUDE	 386SCD.INC
1    18
1    19					 .386P
1    20					 ;----------------------------------------------------------------------------
1    21					 ;application structure	for aoa
1    22
1    23	00000000			 typeApplication struc
1    24	00000000  01*(????)			 noOfSectors	 DW	 ?
1    25	00000002  01*(????)			 startingSector	 DW	 ?
1    26	00000004  01*(08*(??))			 nameApplication DB	 8 dup(?)
1    27	0000000C			 typeApplication ends
1    28
1    29
1    30					 ;allApplications	 typeApplication 10 dup(<>)
1    31					 ; ten application vector
1    32
1    33
1    34					 ; command structure
1    35	00000000			 typeCommand		 struc
1    36	00000000  01*(??)			 command	 db	 ?	 ; command
1    37										 ; 0 - exit
1    38										 ; 1 - no command
1    39										 ; 2 - load
1    40										 ; 3 - run
1    41	00000001  01*(08*(??))			 appName	 db	 8 dup(?)
1    42
1    43	00000009  01*(??)			 appIndex	 db	 ?
1    44
1    45	0000000A			 typeCommand		 ends
1    46
1    47					 ;appCommand	 typeCommand <>
1    48					 ;----------------------------------------------------------------------------
1    49					 ; Setup keyboard LED according	to variable NumLock & CapLock
1    50					 ;----------------------------------------------------------------------------
1    51					 KeyboardLED	 MACRO	 NumLock, CapLock	 ; setup keyboard LED
1    52							 LOCAL @@NoCap,@@Write_LED,@@Wait1,@@Wait2,@@Wait3
1    53
1    54							 mov bl, 0
1    55							 mov al, CapLock
1    56							 cmp al, 0
1    57							 jz @@NoCap
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 2
prcycle.ASM



1    58							 or bl,	4
1    59					 @@NoCap:
1    60							 mov al, NumLock
1    61							 cmp al, 0
1    62							 jz @@Write_LED
1    63							 or bl,	2
1    64					 @@Write_LED:
1    65							 mov dx, 64h	 ; set CapLock LED
1    66					 @@Wait1:
1    67							 in al,	dx
1    68							 and al, 2
1    69							 jnz @@Wait1
1    70
1    71							 mov dx, 60h	 ; write LED command
1    72							 mov al, 0edh
1    73							 out dx, al
1    74
1    75							 mov dx, 64h
1    76					 @@Wait2:
1    77							 in al,	dx
1    78							 and al, 2
1    79							 jnz @@Wait2
1    80
1    81							 mov dx, 60h
1    82							 mov al, bl
1    83							 out dx, al
1    84
1    85							 mov dx, 64h
1    86					 @@Wait3:
1    87							 in al,	dx
1    88							 and al, 2
1    89							 jnz @@Wait3
1    90
1    91							 ENDM
1    92					 ;----------------------------------------------------------------------------
1    93					 ; Write configuration data to FDC
1    94					 ;----------------------------------------------------------------------------
1    95					 FDC_out	 MACRO
1    96							 local @@loop
1    97							 push	 edx
1    98							 push	 eax
1    99
1   100							 mov	 dx, 3f4h
1   101					 @@loop:
1   102							 in	 al, dx
1   103							 test	 al, 80h
1   104							 jz	 @@loop
1   105
1   106							 inc	 dx
1   107							 pop	 eax
1   108							 out	 dx, al
1   109
1   110							 pop	 edx
1   111							 ENDM
1   112					 ;----------------------------------------------------------------------------
1   113					 ; Read	a byte from FDC
1   114					 ; Return data is in AL
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 3
prcycle.ASM



1   115					 ;----------------------------------------------------------------------------
1   116					 FDC_in		 MACRO
1   117							 local @@loop
1   118							 push	 edx
1   119
1   120							 mov	 dx, 3f4h
1   121					 @@loop:
1   122							 in	 al, dx
1   123							 test	 al, 80h
1   124							 jz	 @@loop
1   125
1   126							 inc	 dx
1   127							 in	 al, dx
1   128
1   129							 pop	 edx
1   130							 ENDM
1   131					 ;----------------------------------------------------------------------------
1   132					 ; Debug purpose
1   133					 ;----------------------------------------------------------------------------
1   134					 FDC_al		 MACRO	 ps
1   135							 push	 ebx
1   136							 mov	 ebx, ps
1   137							 int	 0fdh
1   138							 pop	 ebx
1   139							 ENDM
1   140					 ;----------------------------------------------------------------------------
1   141					 ; Wait	for floppy interrupt
1   142					 ;----------------------------------------------------------------------------
1   143					 FDC_wait	 MACRO
1   144							 local @@loop
1   145							 push	 eax
1   146							 push	 fs
1   147
1   148							 mov	 ax, RData_Sel
1   149							 mov	 fs, ax
1   150
1   151					 @@loop:
1   152							 mov	 al, fs:[FloppyReady]
1   153							 cmp	 al, 0
1   154							 jz	 @@loop
1   155							 mov	 al, 0
1   156							 mov	 fs:[FloppyReady], al
1   157
1   158							 pop	 fs
1   159							 pop	 eax
1   160							 ENDM
1   161					 ;----------------------------------------------------------------------------
1   162					 ; Delay a while to wait for other stuff
1   163					 ;----------------------------------------------------------------------------
1   164					 MDelay		 MACRO length
1   165							 local @@loop
1   166							 push	 eax
1   167							 push	 ecx
1   168
1   169							 mov	 ecx, length
1   170					 @@loop:
1   171							 xor	 ax, ax
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 4
prcycle.ASM



1   172							 loop @@loop
1   173
1   174							 pop	 ecx
1   175							 pop	 eax
1   176							 ENDM
1   177					 ;----------------------------------------------------------------------------
1   178					 ; Calculate floppy start sector
1   179					 ; Return in AL
1   180					 ;----------------------------------------------------------------------------
1   181					 FDCSector	 MACRO	 sec
1   182							 push	 ebx
1   183							 push	 ecx
1   184
1   185							 mov	 ax, sec
1   186							 mov	 bl, 18
1   187							 div	 bl
1   188							 xor	 cx, cx
1   189							 mov	 cl, ah
1   190							 add	 cl, 1
1   191							 xor	 eax, eax
1   192							 mov	 al, cl
1   193
1   194							 pop	 ecx
1   195							 pop	 ebx
1   196							 ENDM
1   197					 ;----------------------------------------------------------------------------
1   198					 ; Calculate floppy Head
1   199					 ; Return in AL
1   200					 ;----------------------------------------------------------------------------
1   201					 FDCHead MACRO	 sec
1   202							 push	 ebx
1   203
1   204							 xor	 eax, eax
1   205							 mov	 ax, sec
1   206							 mov	 bl, 18
1   207							 div	 bl
1   208							 and	 ah, 0
1   209							 mov	 bl, 2
1   210							 div	 bl
1   211							 mov	 al, ah
1   212							 mov	 ah, 0
1   213
1   214							 pop	 ebx
1   215							 ENDM
1   216					 ;----------------------------------------------------------------------------
1   217					 ; Calculate floppy cylinder
1   218					 ; Return in AL
1   219					 ;----------------------------------------------------------------------------
1   220					 FDCCyl	 MACRO	 sec
1   221							 push	 ebx
1   222
1   223							 xor	 eax, eax
1   224							 mov	 ax, sec
1   225							 mov	 bl, 36
1   226							 div	 bl
1   227							 mov	 ah, 0
1   228
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 5
prcycle.ASM



1   229							 pop	 ebx
1   230							 ENDM
1   231					 ;----------------------------------------------------------------------------
1   232					 NewLineM	 MACRO		 ;prints a newline after puthex
1   233							 push	 eax
1   234							 mov	 al,0dh
1   235							 mov	 ah,14
1   236							 int	 10h
1   237							 mov	 al,0ah
1   238							 mov	 ah,14
1   239							 int	 10h
1   240							 pop	 eax
1   241							 ENDM
1   242
1   243					 ;----------------------------------------------------------------------------
1   244					 ;----------------------------------------------------------------------------
1   245					 EnableA20	 MACRO
1   246							 push	 ax
1   247							 in	 al,92h
1   248							 or	 al,00000010b
1   249							 out	 92h,al
1   250							 pop	 ax
1   251							 ENDM
1   252					 ;----------------------------------------------------------------------------
1   253
1   254					 ;----------------------------------------------------------------------------
1   255					 DisableA20	 MACRO
1   256							 push	 ax
1   257							 in	 al,92h
1   258							 and	 al,11111101b
1   259							 out	 92h,al
1   260							 pop	 ax
1   261							 ENDM
1   262					 ;----------------------------------------------------------------------------
1   263
1   264					 ;----------------------------------------------------------------------------
1   265					 JUMP16		 MACRO	 Selector,Offset
1   266							 DB	 0eah
1   267							 DW	 Offset
1   268							 DW	 Selector
1   269							 ENDM
1   270					 ;----------------------------------------------------------------------------
1   271
1   272					 JUMP32		 MACRO	 Selector,Offset
1   273							 DB	 0eah
1   274							 DW	 OFFSET
1   275							 DW	 0
1   276							 DW	 Selector
1   277							 ENDM
1   278					 ;----------------------------------------------------------------------------
1   279
1   280					 ;----------------------------------------------------------------------------
1   281					 CALL16		 MACRO	 Selector,Offset
1   282							 DB	 9ah
1   283							 DW	 Offset
1   284							 DW	 Selector
1   285							 ENDM
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 6
prcycle.ASM



1   286					 ;----------------------------------------------------------------------------
1   287
1   288					 CALL32		 MACRO	 Selector,Offset
1   289							 DB	 9ah
1   290							 DW	 Offset
1   291							 DW	 0
1   292							 DW	 Selector
1   293							 ENDM
1   294					 ;----------------------------------------------------------------------------
1   295	00000000			 Desc		 STRUC
1   296	00000000  01*(0000)		 LimitL		 DW	 0
1   297	00000002  01*(0000)		 BaseL		 DW	 0
1   298	00000004  01*(00)		 BaseM		 DB	 0
1   299	00000005  01*(00)		 Attributes	 DB	 0
1   300	00000006  01*(00)		 LimitH		 DB	 0
1   301	00000007  01*(00)		 BaseH		 DB	 0
1   302	00000008			 Desc		 ENDS
1   303					 ;----------------------------------------------------------------------------
1   304
1   305					 ;----------------------------------------------------------------------------
1   306	00000000			 Gate		 STRUC
1   307	00000000  01*(0000)		 OffsetL	 DW	 0
1   308	00000002  01*(0000)		 Selector	 DW	 0
1   309	00000004  01*(00)		 DCount		 DB	 0
1   310	00000005  01*(00)		 GType		 DB	 0
1   311	00000006  01*(0000)		 OffsetH	 DW	 0
1   312	00000008			 Gate		 ENDS
1   313					 ;----------------------------------------------------------------------------
1   314
1   315					 ;----------------------------------------------------------------------------
1   316	00000000			 PDesc		 STRUC
1   317	00000000  01*(0000)		 Limit		 DW	 0
1   318	00000002  01*(00000000)		 Base		 DD	 0
1   319	00000006			 PDesc		 ENDS
1   320					 ;----------------------------------------------------------------------------
1   321
1   322					 ;----------------------------------------------------------------------------
1   323	00000000			 TSS		 STRUC
1   324	00000000  01*(0000)		 TRLink		 DW	 0
1   325	00000002  01*(0000)				 DW	 0
1   326	00000004  01*(00000000)		 TRESP0		 DD	 0
1   327	00000008  01*(0000)		 TRSS0		 DW	 0
1   328	0000000A  01*(0000)				 DW	 0
1   329	0000000C  01*(00000000)		 TRESP1		 DD	 0
1   330	00000010  01*(0000)		 TRSS1		 DW	 0
1   331	00000012  01*(0000)				 DW	 0
1   332	00000014  01*(00000000)		 TRESP2		 DD	 0
1   333	00000018  01*(0000)		 TRSS2		 DW	 0
1   334	0000001A  01*(0000)				 DW	 0
1   335	0000001C  01*(00000000)		 TRCR3		 DD	 0
1   336	00000020  01*(00000000)		 TREIP		 DD	 0	;EIP
1   337	00000024  01*(00000000)		 TREFlag	 DD	 0	;EFLAGS
1   338	00000028  01*(00000000)		 TREAX		 DD	 0	;EAX
1   339	0000002C  01*(00000000)		 TRECX		 DD	 0	;ECX
1   340	00000030  01*(00000000)		 TREDX		 DD	 0	;EDX
1   341	00000034  01*(00000000)		 TREBX		 DD	 0	;EBX
1   342	00000038  01*(00000000)		 TRESP		 DD	 0	;ESP
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 7
prcycle.ASM



1   343	0000003C  01*(00000000)		 TREBP		 DD	 0	;EBP
1   344	00000040  01*(00000000)		 TRESI		 DD	 0	;ESI
1   345	00000044  01*(00000000)		 TREDI		 DD	 0	;EDI
1   346	00000048  01*(0000)		 TRES		 DW	 0	;ES
1   347	0000004A  01*(0000)				 DW	 0
1   348	0000004C  01*(0000)		 TRCS		 DW	 0
1   349	0000004E  01*(0000)				 DW	 0
1   350	00000050  01*(0000)		 TRSS		 DW	 0	;SS
1   351	00000052  01*(0000)				 DW	 0
1   352	00000054  01*(0000)		 TRDS		 DW	 0	;DS
1   353	00000056  01*(0000)				 DW	 0
1   354	00000058  01*(0000)		 TRFS		 DW	 0	;FS
1   355	0000005A  01*(0000)				 DW	 0
1   356	0000005C  01*(0000)		 TRGS		 DW	 0	;GS
1   357	0000005E  01*(0000)				 DW	 0
1   358	00000060  01*(0000)		 TRLDTR		 DW	 0
1   359	00000062  01*(0000)				 DW	 0
1   360	00000064  01*(0000)		 TRTrip		 DW	 0
1   361	00000066  01*(0068)		 TRIOMap	 DW	 $+2
1   362	00000068			 TSS		 ENDS
1   363					 ;----------------------------------------------------------------------------
1   364
1   365					 ;----------------------------------------------------------------------------
1   366		  = 0090		 ATDR		 EQU	 90h
1   367		  = 0092		 ATDW		 EQU	 92h
1   368		  = 0093		 ATDWA		 EQU	 93h
1   369		  = 0096		 ATSWA		 EQU	 96h
1   370		  = 0098		 ATCE		 EQU	 98h
1   371		  = 009A		 ATCER		 EQU	 9ah
1   372		  = 009C		 ATCCO		 EQU	 9ch
1   373		  = 009E		 ATCCOR		 EQU	 9eh
1   374					 ;----------------------------------------------------------------------------
1   375
1   376					 ;----------------------------------------------------------------------------
1   377		  = 0082		 ATLDT		 EQU	 82h
1   378		  = 0085		 ATTaskGate	 EQU	 85h
1   379		  = 0089		 AT386TSS	 EQU	 89h
1   380		  = 008C		 AT386CGate	 EQU	 8ch
1   381		  = 008E		 AT386IGate	 EQU	 8eh
1   382		  = 008F		 AT386TGate	 EQU	 8fh
1   383					 ;----------------------------------------------------------------------------
1   384
1   385					 ;----------------------------------------------------------------------------
1   386		  = 0000		 DPL0		 EQU	 00h ;DPL=0
1   387		  = 0020		 DPL1		 EQU	 20h ;DPL=1
1   388		  = 0040		 DPL2		 EQU	 40h ;DPL=2
1   389		  = 0060		 DPL3		 EQU	 60h ;DPL=3
1   390					 ;----------------------------------------------------------------------------
1   391
1   392					 ;----------------------------------------------------------------------------
1   393		  = 0000		 RPL0		 EQU	 00h ;RPL=0
1   394		  = 0001		 RPL1		 EQU	 01h ;RPL=1
1   395		  = 0002		 RPL2		 EQU	 02h ;RPL=2
1   396		  = 0003		 RPL3		 EQU	 03h ;RPL=3
1   397					 ;----------------------------------------------------------------------------
1   398
1   399					 ;----------------------------------------------------------------------------
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 8
prcycle.ASM



1   400		  = 0000		 IOPL0		 EQU	 0000h ;IOPL=0
1   401		  = 1000		 IOPL1		 EQU	 1000h ;IOPL=1
1   402		  = 2000		 IOPL2		 EQU	 2000h ;IOPL=2
1   403		  = 3000		 IOPL3		 EQU	 3000h ;IOPL=3
1   404					 ;----------------------------------------------------------------------------
1   405
1   406					 ;----------------------------------------------------------------------------
1   407		  = 0040		 D32		 EQU	 40h
1   408		  = 0080		 GL		 EQU	 80h
1   409		  = 0004		 TIL		 EQU	 04h
1   410		  = 00020000		 VMFL		 EQU	 00020000h ;VMF=1
1   411		  = 0002		 VMFLW		 EQU	 0002h
1   412		  = 0200		 IFL		 EQU	 00000200h ;IF=1
1   413		  = 00010000		 RFL		 EQU	 00010000h ;
1   414		  = 0001		 RFLW		 EQU	 0001h
1   415		  = 4000		 NTL		 EQU	 00004000h ;NT=1
1   416					 ;----------------------------------------------------------------------------
1   417
1   418					 ;----------------------------------------------------------------------------
1   419		  = 0001		 PL		 EQU	 1
1   420		  = 0000		 RWR		 EQU	 0
1   421		  = 0002		 RWW		 EQU	 2
1   422		  = 0000		 USS		 EQU	 0
1   423		  = 0004		 USU		 EQU	 4
1   424					 ;----------------------------------------------------------------------------
1   425		  = 0064		 HZ		 EQU	 100
1   426		  = 001234DC		 CLOCK_TICK_RATE EQU	 1193180
1   427		  = 2E9C		 LATCH		 EQU	 ((CLOCK_TICK_RATE+HZ/2)/HZ)
1   428					 ;----------------------------------------------------------------------------
1   429
    430					 INCLUDE	 DCYCLE.INC
1   431					 EXTRN		 PUTHEX32R:NEAR
1   432					 EXTRN		 WriteString:NEAR
1   433					 EXTRN		 ClearScreen:NEAR
1   434					 EXTRN		 GETKEYFORMENU:NEAR
1   435					 EXTRN		 NEWLINE:NEAR
1   436					 EXTRN		 GET_PARAMETER:NEAR
1   437					 EXTRN		 ResetPointer:NEAR
1   438					 EXTRN		 PRINTMEMR:NEAR
1   439
1   440
    441					 INCLUDE	 SHARMEM.INC
1   442					 ;Shared Memory	Constants between appilication and aoa
1   443		  = 0000		 S_Timer		 EQU		 00000000h ; software timer value, incremented by   +
    444					 timer interrupt
1   445		  = 0004		 S_SectorNo		 EQU		 00000004h ; 4 byte sector number and another 4	byte+
    446					 spare
1   447					 ; after this element, the GetSecBegin in prcycle stores another data value
1   448					 ;  with +2 location, so keep another 4	bytes as spare here
1   449		  = 000C		 S_IDTOffset		 EQU		 0000000Ch ; used by Timer interrupt
1   450		  = 0010		 S_Cycle_Count		 EQU		 00000010h
1   451					 ; This	is the count used by the Htimer	to calculate the processor clock speed,	which is    +
    452					 stored	in S_Clock_Hz
1   453		  = 0014		 S_Clock_Hz		 EQU		 00000014h ; This shared memory	has the	clock speed +
    454					 in Giga Hertz
1   455		  = 0018		 S_Error_Flag		 EQU		 00000018h ; error flag	indicating that	error	    +
    456					 occured in the	machine
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 9
prcycle.ASM



1   457		  = 001C		 S_Error_Code		 EQU		 0000001Ch ; error code	showing	the IDT	value
1   458		  = 0020		 S_IO_Function_Code	 EQU		 00000020h ; Function Code Indicating the type of   +
    459					 function 4 bytes
1   460					 ;each assembly	interface call will put	this code in memory
1   461		  = 0024		 S_APP_String		 EQU		 00000024h ; 40	bytes Used for storing a string
1   462					 ;all C++ programs and functions can store a string here to be used as a trace
1   463					 ; the string here indicates the last C++ function trace which can help	identify
1   464					 ; the trace code ran before an	error
1   465		  = 004C		 S_Lock1		 EQU		 0000004Ch ; 4 byte lock 0 DISPLAY
1   466		  = 0050		 S_Lock2		 EQU		 00000050h ; 4 byte lock 1 KBD
1   467		  = 0054		 S_Lock3		 EQU		 00000054h ; 4 byte lock 2
1   468		  = 0058		 S_Lock4		 EQU		 00000058h ; 4 byte lock 3
1   469		  = 005C		 S_TID1			 EQU		 0000005ch ; Task ID 1	   DISPLAY
1   470		  = 0060		 S_TID2			 EQU		 00000060h ; Task ID 2	   KBD
1   471		  = 0064		 S_TID3			 EQU		 00000064h ; Task ID 3
1   472		  = 0068		 S_TID4			 EQU		 00000068h ; Task ID 4
1   473		  = 0070		 S_InCount		 EQU		 00000070h ; 4 byte the	no of interrupt	pkts	    +
    474					 received
1   475		  = 0074		 S_OutCount		 EQU		 00000074h ; 4 byte the	no of pkts processed
1   476		  = 0078		 S_PID			 EQU		 00000078h ; 4 byte task id of the process running
1   477		  = 007C		 S_NTFLAG		 EQU		 0000007ch ; 4 byte CPU	NTFLAG
1   478		  = 0080		 S_CIRLISTSTATE		 EQU		 00000080h ; 4 byte cirlist condition
1   479		  = 0084		 S_InRecord		 EQU		 00000084h ; 4 byte in record for cirlist
1   480		  = 0088		 S_OutRecord		 EQU		 00000088h ; 4 byte out	record for cirlist
1   481		  = 008C		 S_ISRCount		 EQU		 0000008Ch ; 4 byte counter used to communicate	betn+
    482					 ISR Rtn and Poll Task
1   483		  = 0090		 S_ISRSTIFlag		 EQU		 00000090h ; 4 byte ISR	STI flag indicating its	    +
    484					 execution, no sti now...
1   485		  = 0094		 S_DUMMY		 EQU		 00000094h ; 8 byte dummy data
1   486		  = 009C		 S_IOBASE		 EQU		 0000009Ch ; 4 byte NIC	device address
1   487		  = 00A0		 S_EINIT_RET		 EQU		 000000a0h ; 4 byte Ethernet Init Ret code
1   488		  = 00A4		 S_Total_Tx_Count	 EQU		 000000a4h ; 4 byte counter counts total pkts	    +
    489					 xmitted
1   490		  = 00A8		 S_DPD_Count		 EQU		 000000a8h ; 4 byte counter
1   491		  = 00AC		 S_Suspend_Command	 EQU		 000000ach ; 4 byte value
1   492		  = 00B0		 S_Suspend_Delay	 EQU		 000000b0h ; 4 byte value
1   493		  = 00B4		 S_TCP_Tx_Count		 EQU		 000000b4h ; total packets sent	by application
1   494
1   495		  = 00B8		 S_TCP_SACK_Count	 EQU		 000000b8h ; total GET SYN ACK packets sent by	    +
    496					 application
1   497		  = 00BC		 S_TCP_GACK_Count	 EQU		 000000bch ; total GET ACK packets sent	by	    +
    498					 application
1   499		  = 00C0		 S_TCP_HDR_Count	 EQU		 000000c0h ; total header packets sent by	    +
    500					 application
1   501		  = 00C4		 S_TCP_DAT_Count	 EQU		 000000c4h ; total data	packets	sent by	application
1   502		  = 00C8		 S_TCP_FACK_Count	 EQU		 000000c8h ; total FIN ACK packets sent	by	    +
    503					 application
1   504		  = 00CC		 S_TCP_RESET_Count	 EQU		 000000cch ; total GET RESET packets sent by	    +
    505					 application
1   506		  = 00D0		 S_TCP_ARP_Count	 EQU		 000000d0h ; total GET ARP packets sent	by	    +
    507					 application
1   508
1   509		  = 0100		 S_ITCP_SACK_Count	 EQU		 00000100h ; total interrupts for SYN ACK packets
1   510		  = 0104		 S_ITCP_GACK_Count	 EQU		 00000104h ; total interrupts for GET ACK packets
1   511		  = 0108		 S_ITCP_HDR_Count	 EQU		 00000108h ; total interrupts for header packets
1   512		  = 010C		 S_ITCP_DAT_Count	 EQU		 0000010ch ; total interrrupts for data	packets
1   513		  = 0110		 S_ITCP_FACK_Count	 EQU		 00000110h ; total interrupts for FIN ACK packets
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 10
prcycle.ASM



1   514		  = 0114		 S_ITCP_RESET_Count	 EQU		 00000114h ; total interrupts for RESET	packets
1   515		  = 0118		 S_ITCP_ARP_Count	 EQU		 00000118h ; total interrupts for ARP packets
1   516		  = 011C		 S_ITCP_PRIOR_Count	 EQU		 0000011ch ; interrupt prior count before TCP	    +
    517					 transmissions
1   518					 ;--------------------------------------------------------------------------------
1   519		  = 0120		 S_RTC		     EQU	 00000120h ; real time clock
1   520		  = 0124		 S_DATE		     EQU	 00000124h ; date
1   521		  = 0128		 S_ERR		     EQU	 00000128h ; error
1   522		  = 0130		 S_RTCFLAG		 EQU		 00000130h ; flag
1   523
1   524		  = 0140		 S_LSError		 EQU		 00000140h ; Sector Error when reading floppy
1   525					 ;----------------------------------------------------
1   526		  = 0160		 S_Trace		 EQU		 00000160h ; 128 byte trace data
1   527
1   528					 ;----------------------------------------------------
1   529
1   530					 ; Base	of Shared memory between aoa and application
1   531					 ;--------------------------------------------
1   532		  = 8600		 S_Base			 EQU		 00008600h ; base address of shared memory
1   533
1   534					 ;--------------------------------------------
1   535					 ; Some	other constants
1   536					 ;change the following value if	loading	the program changes
1   537					 ;  most significant 2 bytes
1   538		  = 0011		 D_ADDROFFSET		 EQU		 0011h
1   539		  = 0010		 Video_Sel_Loc		 EQU		 10h
1   540
    541					 PUBLIC		 HexTable, IndexCnt, PrintData,RunFlag
    542					 PUBLIC		 MemoryOffset,MemFlag
    543					 ;******************************************************
    544					 ; MemoryOffset	is used	for printing memory or dump
    545					 ;******************************************************
    546					 EXTRN		 LoaderSize1:word,LoaderSize2:word,StartLogicalSecNum1:word,		    +
    547					 StartLogicalSecNum2:word
    548					 EXTRN		 LoadOffset1:dword,LoadOffset2:dword,ApplNum:byte,JumpOffset1:word,	    +
    549					 JumpOffset2:word
    550					 EXTRN		 BxPointer1:dword,LoadFlag:byte,LoaderSize1m:word,StartLogicalSecNum1m:word
    551					 EXTRN		 AOADisp:NEAR
    552					 ;EXTRN		  AOADisp:far
    553					 EXTRN		 aoaminil1:NEAR
    554					 EXTRN		 aoaminiw1:NEAR
    555					 EXTRN		 Other_Begin0:NEAR,Other_Begin1:NEAR,Other_Begin2:NEAR,	Other_Begin3,	    +
    556					 Other_Begin4, Other_Begin5
    557					 EXTRN		 Other_Begin6:NEAR,Other_Begin7:NEAR,Other_Begin10:NEAR, Other_Begin11,	    +
    558					 Other_Begin12,	Other_Begin13
    559					 EXTRN		 Other_Begin219:NEAR,Other_Begin246:NEAR
    560					 ;---------------------------------------------------------------------------
    561		  = 0020		 EOICOM		 =	 20h	 ; not used
    562		  = 0020		 ICREGP		 =	 20h	 ; not used
    563		  = 0021		 IMREGP		 =	 21h	 ; mask	register
    564		  = 0080		 RELOCATE1	 =	 80h	 ;Program reloaction in	BootMode
    565		  = 0000		 APPL1RELOCATE	 =	 000h	;Program reloaction in ApplicationMode
    566		  = 0000		 BaseOfCode	 =	 0000h	 ;Base of code from PE
    567					 ;RELOCATE1: The code is loaded	at '600' in BootMode includes PSP
    568					 ;So, the executable code is at	'800' which is '80h' for segment adresses
    569					 ;and we need to relocate accordingly.
    570					 ;***************************************************************************
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 11
prcycle.ASM



    571					 ;  Interupts in Protection Mode
    572					 ;  ;IDT Segment
    573					 ;  16 bit segment
    574					 ; whenever, interrupts	are added or deleted to	this segment
    575					 ;  make sure they add up to 256
    576					 ; otherwise, LIDT instruction will fail
    577					 ;***************************************************************************
    578
    579	    0000			 IDTSeg		 SEGMENT PARA USE16
    580	    0000			 IDT		 LABEL	 BYTE
    581							 REPT	 8
    582							 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    583					 Selector 0 -7
    584							 ENDM
1   585	    0000  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    586		  0000			 Selector 0 -7
1   587	    0008  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    588		  0000			 Selector 0 -7
1   589	    0010  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    590		  0000			 Selector 0 -7
1   591	    0018  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    592		  0000			 Selector 0 -7
1   593	    0020  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    594		  0000			 Selector 0 -7
1   595	    0028  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    596		  0000			 Selector 0 -7
1   597	    0030  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    598		  0000			 Selector 0 -7
1   599	    0038  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    600		  0000			 Selector 0 -7
    601	    0040  0167r	0098 00	8F    +			 Gate	 <HTimerBegin, Puthex32I_Sel,,AT386TGate,>	 ;08h: hardware	    +
    602		  0000			 timer interrupt
    603	    0048  0000r	0138 00	8F    +			 Gate	 <Keyboard_Int,	PCode_Sel,,AT386TGate,>		 ;09h: get a key
    604		  0000
    605	    0050  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    606		  0000			 Selector 10
    607	    0058  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    608		  0000			 Selector 11
    609	    0060  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    610		  0000			 Selector 12
    611	    0068  0AC3r	0038 00	8F    +			 Gate	 <OtherBegin13,Other_Sel,,AT386TGate,>		 ; Use this	    +
    612		  0000			 interrupt in PRCYCLE
    613	    0070  03E3r	0098 00	8F    +			 Gate	 <FDC_int, Puthex32I_Sel,,AT386TGate,>		 ;0eh: floppy	    +
    614		  0000			 interrupt 14
    615							 ; another print char exist so we can change
    616	    0078  0443r	0098 00	8F    +			 Gate	 <DisplayBegin,Puthex32I_Sel,,AT386TGate,>	 ;0fh: display a    +
    617		  0000			 character interrupt 15
    618
    619							 REPT	 99
    620							 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    621					 Selector 16 - 114
    622							 ENDM
1   623	    0080  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    624		  0000			 Selector 16 - 114
1   625	    0088  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    626		  0000			 Selector 16 - 114
1   627	    0090  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 12
prcycle.ASM



    628		  0000			 Selector 16 - 114
1   629	    0098  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    630		  0000			 Selector 16 - 114
1   631	    00A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    632		  0000			 Selector 16 - 114
1   633	    00A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    634		  0000			 Selector 16 - 114
1   635	    00B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    636		  0000			 Selector 16 - 114
1   637	    00B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    638		  0000			 Selector 16 - 114
1   639	    00C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    640		  0000			 Selector 16 - 114
1   641	    00C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    642		  0000			 Selector 16 - 114
1   643	    00D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    644		  0000			 Selector 16 - 114
1   645	    00D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    646		  0000			 Selector 16 - 114
1   647	    00E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    648		  0000			 Selector 16 - 114
1   649	    00E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    650		  0000			 Selector 16 - 114
1   651	    00F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    652		  0000			 Selector 16 - 114
1   653	    00F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    654		  0000			 Selector 16 - 114
1   655	    0100  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    656		  0000			 Selector 16 - 114
1   657	    0108  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    658		  0000			 Selector 16 - 114
1   659	    0110  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    660		  0000			 Selector 16 - 114
1   661	    0118  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    662		  0000			 Selector 16 - 114
1   663	    0120  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    664		  0000			 Selector 16 - 114
1   665	    0128  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    666		  0000			 Selector 16 - 114
1   667	    0130  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    668		  0000			 Selector 16 - 114
1   669	    0138  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    670		  0000			 Selector 16 - 114
1   671	    0140  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    672		  0000			 Selector 16 - 114
1   673	    0148  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    674		  0000			 Selector 16 - 114
1   675	    0150  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    676		  0000			 Selector 16 - 114
1   677	    0158  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    678		  0000			 Selector 16 - 114
1   679	    0160  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    680		  0000			 Selector 16 - 114
1   681	    0168  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    682		  0000			 Selector 16 - 114
1   683	    0170  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    684		  0000			 Selector 16 - 114
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 13
prcycle.ASM



1   685	    0178  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    686		  0000			 Selector 16 - 114
1   687	    0180  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    688		  0000			 Selector 16 - 114
1   689	    0188  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    690		  0000			 Selector 16 - 114
1   691	    0190  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    692		  0000			 Selector 16 - 114
1   693	    0198  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    694		  0000			 Selector 16 - 114
1   695	    01A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    696		  0000			 Selector 16 - 114
1   697	    01A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    698		  0000			 Selector 16 - 114
1   699	    01B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    700		  0000			 Selector 16 - 114
1   701	    01B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    702		  0000			 Selector 16 - 114
1   703	    01C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    704		  0000			 Selector 16 - 114
1   705	    01C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    706		  0000			 Selector 16 - 114
1   707	    01D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    708		  0000			 Selector 16 - 114
1   709	    01D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    710		  0000			 Selector 16 - 114
1   711	    01E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    712		  0000			 Selector 16 - 114
1   713	    01E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    714		  0000			 Selector 16 - 114
1   715	    01F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    716		  0000			 Selector 16 - 114
1   717	    01F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    718		  0000			 Selector 16 - 114
1   719	    0200  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    720		  0000			 Selector 16 - 114
1   721	    0208  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    722		  0000			 Selector 16 - 114
1   723	    0210  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    724		  0000			 Selector 16 - 114
1   725	    0218  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    726		  0000			 Selector 16 - 114
1   727	    0220  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    728		  0000			 Selector 16 - 114
1   729	    0228  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    730		  0000			 Selector 16 - 114
1   731	    0230  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    732		  0000			 Selector 16 - 114
1   733	    0238  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    734		  0000			 Selector 16 - 114
1   735	    0240  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    736		  0000			 Selector 16 - 114
1   737	    0248  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    738		  0000			 Selector 16 - 114
1   739	    0250  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    740		  0000			 Selector 16 - 114
1   741	    0258  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 14
prcycle.ASM



    742		  0000			 Selector 16 - 114
1   743	    0260  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    744		  0000			 Selector 16 - 114
1   745	    0268  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    746		  0000			 Selector 16 - 114
1   747	    0270  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    748		  0000			 Selector 16 - 114
1   749	    0278  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    750		  0000			 Selector 16 - 114
1   751	    0280  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    752		  0000			 Selector 16 - 114
1   753	    0288  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    754		  0000			 Selector 16 - 114
1   755	    0290  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    756		  0000			 Selector 16 - 114
1   757	    0298  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    758		  0000			 Selector 16 - 114
1   759	    02A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    760		  0000			 Selector 16 - 114
1   761	    02A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    762		  0000			 Selector 16 - 114
1   763	    02B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    764		  0000			 Selector 16 - 114
1   765	    02B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    766		  0000			 Selector 16 - 114
1   767	    02C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    768		  0000			 Selector 16 - 114
1   769	    02C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    770		  0000			 Selector 16 - 114
1   771	    02D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    772		  0000			 Selector 16 - 114
1   773	    02D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    774		  0000			 Selector 16 - 114
1   775	    02E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    776		  0000			 Selector 16 - 114
1   777	    02E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    778		  0000			 Selector 16 - 114
1   779	    02F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    780		  0000			 Selector 16 - 114
1   781	    02F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    782		  0000			 Selector 16 - 114
1   783	    0300  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    784		  0000			 Selector 16 - 114
1   785	    0308  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    786		  0000			 Selector 16 - 114
1   787	    0310  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    788		  0000			 Selector 16 - 114
1   789	    0318  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    790		  0000			 Selector 16 - 114
1   791	    0320  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    792		  0000			 Selector 16 - 114
1   793	    0328  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    794		  0000			 Selector 16 - 114
1   795	    0330  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    796		  0000			 Selector 16 - 114
1   797	    0338  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    798		  0000			 Selector 16 - 114
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 15
prcycle.ASM



1   799	    0340  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    800		  0000			 Selector 16 - 114
1   801	    0348  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    802		  0000			 Selector 16 - 114
1   803	    0350  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    804		  0000			 Selector 16 - 114
1   805	    0358  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    806		  0000			 Selector 16 - 114
1   807	    0360  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    808		  0000			 Selector 16 - 114
1   809	    0368  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    810		  0000			 Selector 16 - 114
1   811	    0370  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    812		  0000			 Selector 16 - 114
1   813	    0378  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    814		  0000			 Selector 16 - 114
1   815	    0380  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    816		  0000			 Selector 16 - 114
1   817	    0388  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    818		  0000			 Selector 16 - 114
1   819	    0390  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    820		  0000			 Selector 16 - 114
    821	    0398  0B82r	0038 00	8F    +			 Gate	 <OtherBegin73,Other_Sel,,AT386TGate,>		 ; 115 IRQ11 0x73
    822		  0000
    823
    824							 REPT	 3
    825							 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    826					 Selector 116-118
    827							 ENDM
1   828	    03A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    829		  0000			 Selector 116-118
1   830	    03A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    831		  0000			 Selector 116-118
1   832	    03B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    833		  0000			 Selector 116-118
    834
    835							 ;Ethernet Interrupt IRQ15 i.e.	0x77 0r	119
    836							 ; using Interrupt Gate	for Ethernet Interrupt ISR
    837	    03B8  0000r	0140 00	8E    +			 Gate	 <test2,EthernetReceive_Sel,,AT386IGate,>	 ; Ether Receive    +
    838		  0000			 Interrupt 119
    839							 ;in the application, we need to change	the EtherReceive address
    840							 ;Gate	  <OtherBegin0,Other_Sel,,AT386TGate,>		 ; not used 1
    841
    842							 REPT	 115
    843							 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    844					 Selector 120 -	234
    845							 ENDM
1   846	    03C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    847		  0000			 Selector 120 -	234
1   848	    03C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    849		  0000			 Selector 120 -	234
1   850	    03D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    851		  0000			 Selector 120 -	234
1   852	    03D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    853		  0000			 Selector 120 -	234
1   854	    03E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    855		  0000			 Selector 120 -	234
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 16
prcycle.ASM



1   856	    03E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    857		  0000			 Selector 120 -	234
1   858	    03F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    859		  0000			 Selector 120 -	234
1   860	    03F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    861		  0000			 Selector 120 -	234
1   862	    0400  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    863		  0000			 Selector 120 -	234
1   864	    0408  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    865		  0000			 Selector 120 -	234
1   866	    0410  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    867		  0000			 Selector 120 -	234
1   868	    0418  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    869		  0000			 Selector 120 -	234
1   870	    0420  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    871		  0000			 Selector 120 -	234
1   872	    0428  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    873		  0000			 Selector 120 -	234
1   874	    0430  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    875		  0000			 Selector 120 -	234
1   876	    0438  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    877		  0000			 Selector 120 -	234
1   878	    0440  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    879		  0000			 Selector 120 -	234
1   880	    0448  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    881		  0000			 Selector 120 -	234
1   882	    0450  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    883		  0000			 Selector 120 -	234
1   884	    0458  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    885		  0000			 Selector 120 -	234
1   886	    0460  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    887		  0000			 Selector 120 -	234
1   888	    0468  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    889		  0000			 Selector 120 -	234
1   890	    0470  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    891		  0000			 Selector 120 -	234
1   892	    0478  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    893		  0000			 Selector 120 -	234
1   894	    0480  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    895		  0000			 Selector 120 -	234
1   896	    0488  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    897		  0000			 Selector 120 -	234
1   898	    0490  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    899		  0000			 Selector 120 -	234
1   900	    0498  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    901		  0000			 Selector 120 -	234
1   902	    04A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    903		  0000			 Selector 120 -	234
1   904	    04A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    905		  0000			 Selector 120 -	234
1   906	    04B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    907		  0000			 Selector 120 -	234
1   908	    04B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    909		  0000			 Selector 120 -	234
1   910	    04C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    911		  0000			 Selector 120 -	234
1   912	    04C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 17
prcycle.ASM



    913		  0000			 Selector 120 -	234
1   914	    04D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    915		  0000			 Selector 120 -	234
1   916	    04D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    917		  0000			 Selector 120 -	234
1   918	    04E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    919		  0000			 Selector 120 -	234
1   920	    04E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    921		  0000			 Selector 120 -	234
1   922	    04F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    923		  0000			 Selector 120 -	234
1   924	    04F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    925		  0000			 Selector 120 -	234
1   926	    0500  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    927		  0000			 Selector 120 -	234
1   928	    0508  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    929		  0000			 Selector 120 -	234
1   930	    0510  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    931		  0000			 Selector 120 -	234
1   932	    0518  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    933		  0000			 Selector 120 -	234
1   934	    0520  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    935		  0000			 Selector 120 -	234
1   936	    0528  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    937		  0000			 Selector 120 -	234
1   938	    0530  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    939		  0000			 Selector 120 -	234
1   940	    0538  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    941		  0000			 Selector 120 -	234
1   942	    0540  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    943		  0000			 Selector 120 -	234
1   944	    0548  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    945		  0000			 Selector 120 -	234
1   946	    0550  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    947		  0000			 Selector 120 -	234
1   948	    0558  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    949		  0000			 Selector 120 -	234
1   950	    0560  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    951		  0000			 Selector 120 -	234
1   952	    0568  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    953		  0000			 Selector 120 -	234
1   954	    0570  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    955		  0000			 Selector 120 -	234
1   956	    0578  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    957		  0000			 Selector 120 -	234
1   958	    0580  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    959		  0000			 Selector 120 -	234
1   960	    0588  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    961		  0000			 Selector 120 -	234
1   962	    0590  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    963		  0000			 Selector 120 -	234
1   964	    0598  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    965		  0000			 Selector 120 -	234
1   966	    05A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    967		  0000			 Selector 120 -	234
1   968	    05A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    969		  0000			 Selector 120 -	234
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 18
prcycle.ASM



1   970	    05B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    971		  0000			 Selector 120 -	234
1   972	    05B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    973		  0000			 Selector 120 -	234
1   974	    05C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    975		  0000			 Selector 120 -	234
1   976	    05C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    977		  0000			 Selector 120 -	234
1   978	    05D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    979		  0000			 Selector 120 -	234
1   980	    05D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    981		  0000			 Selector 120 -	234
1   982	    05E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    983		  0000			 Selector 120 -	234
1   984	    05E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    985		  0000			 Selector 120 -	234
1   986	    05F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    987		  0000			 Selector 120 -	234
1   988	    05F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    989		  0000			 Selector 120 -	234
1   990	    0600  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    991		  0000			 Selector 120 -	234
1   992	    0608  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    993		  0000			 Selector 120 -	234
1   994	    0610  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    995		  0000			 Selector 120 -	234
1   996	    0618  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    997		  0000			 Selector 120 -	234
1   998	    0620  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    999		  0000			 Selector 120 -	234
1  1000	    0628  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1001		  0000			 Selector 120 -	234
1  1002	    0630  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1003		  0000			 Selector 120 -	234
1  1004	    0638  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1005		  0000			 Selector 120 -	234
1  1006	    0640  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1007		  0000			 Selector 120 -	234
1  1008	    0648  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1009		  0000			 Selector 120 -	234
1  1010	    0650  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1011		  0000			 Selector 120 -	234
1  1012	    0658  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1013		  0000			 Selector 120 -	234
1  1014	    0660  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1015		  0000			 Selector 120 -	234
1  1016	    0668  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1017		  0000			 Selector 120 -	234
1  1018	    0670  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1019		  0000			 Selector 120 -	234
1  1020	    0678  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1021		  0000			 Selector 120 -	234
1  1022	    0680  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1023		  0000			 Selector 120 -	234
1  1024	    0688  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1025		  0000			 Selector 120 -	234
1  1026	    0690  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 19
prcycle.ASM



   1027		  0000			 Selector 120 -	234
1  1028	    0698  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1029		  0000			 Selector 120 -	234
1  1030	    06A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1031		  0000			 Selector 120 -	234
1  1032	    06A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1033		  0000			 Selector 120 -	234
1  1034	    06B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1035		  0000			 Selector 120 -	234
1  1036	    06B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1037		  0000			 Selector 120 -	234
1  1038	    06C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1039		  0000			 Selector 120 -	234
1  1040	    06C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1041		  0000			 Selector 120 -	234
1  1042	    06D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1043		  0000			 Selector 120 -	234
1  1044	    06D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1045		  0000			 Selector 120 -	234
1  1046	    06E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1047		  0000			 Selector 120 -	234
1  1048	    06E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1049		  0000			 Selector 120 -	234
1  1050	    06F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1051		  0000			 Selector 120 -	234
1  1052	    06F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1053		  0000			 Selector 120 -	234
1  1054	    0700  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1055		  0000			 Selector 120 -	234
1  1056	    0708  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1057		  0000			 Selector 120 -	234
1  1058	    0710  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1059		  0000			 Selector 120 -	234
1  1060	    0718  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1061		  0000			 Selector 120 -	234
1  1062	    0720  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1063		  0000			 Selector 120 -	234
1  1064	    0728  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1065		  0000			 Selector 120 -	234
1  1066	    0730  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1067		  0000			 Selector 120 -	234
1  1068	    0738  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1069		  0000			 Selector 120 -	234
1  1070	    0740  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1071		  0000			 Selector 120 -	234
1  1072	    0748  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1073		  0000			 Selector 120 -	234
1  1074	    0750  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1075		  0000			 Selector 120 -	234
   1076
   1077	    0758  0000 00E8 00 85 0000			 Gate	 <,App1TSSS_Sel,,ATTaskGate,>			 ;0ebh:	Scheduler   +
   1078					 Task 235
   1079							 ;RKK0205
   1080							 ;Gate	  <,App1TSSE_Sel,,ATTaskGate,>			 ;0ech:	Error	    +
   1081					 Recovery Task 236
   1082	    0760  01AAr	0098 00	8F    +			 Gate	 <test1,Puthex32I_Sel,,AT386TGate,>		 ;0ech:	Error	    +
   1083		  0000			 Recovery Task 236
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 20
prcycle.ASM



   1084
   1085							 ;Gate	 <MEMFetch, Puthex32I_Sel,,AT386TGate,>		 ;0ech:	free to	use +
   1086					 236
   1087	    0768  0442r	0098 00	8F    +			 Gate	 <MEMFree, Puthex32I_Sel,,AT386TGate,>		 ;0edh:	free to	use +
   1088		  0000			 237
   1089	    0770  0412r	0098 00	8F    +			 Gate	 <MEMMalloc, Puthex32I_Sel,,AT386TGate,>	 ;0eeh:	malloc new  +
   1090		  0000			 memory	238
   1091	    0778  0000 00E0 00 85 0000			 Gate	 <,App1TSSC_Sel,,ATTaskGate,>			 ;0efh:	Application +
   1092					 1 Child 239
   1093	    0780  0248r	0098 00	8F    +			 Gate	 <scroll,Puthex32I_Sel,,AT386TGate,>		 ;0f0h:	scroll up   +
   1094		  0000			 one line 240
   1095	    0788  029Er	0098 00	8F    +			 Gate	 <CLScreen,Puthex32I_Sel,,AT386TGate,>		 ;0f1h:	clean screen+
   1096		  0000			 241
   1097	    0790  01E6r	0098 00	8F    +			 Gate	 <GetCursor,Puthex32I_Sel,,AT386TGate,>		 ;0f2h:	get the	    +
   1098		  0000			 cursor	postition 242
   1099	    0798  0217r	0098 00	8F    +			 Gate	 <SetCursor,Puthex32I_Sel,,AT386TGate,>		 ;0f3h:	set the	    +
   1100		  0000			 cursor	postion	243
   1101	    07A0  0000 0058 00 85 0000			 Gate	 <,WriteSecTSS_Sel,,ATTaskGate,>		 ;0f4h:	write one   +
   1102					 sector	at a time 244
   1103	    07A8  02D4r	0098 00	8F    +			 Gate	 <Getchar32,Puthex32I_Sel,,AT386TGate,>		 ;0f5h:	get a	    +
   1104		  0000			 character in protect mode 245
   1105	    07B0  0358r	0098 00	8F    +			 Gate	 <Getchar32Buff,Puthex32I_Sel,,AT386TGate,>	 ;0f6h:	get a	    +
   1106		  0000			 character from	the buffer
   1107	    07B8  0443r	0098 00	8F    +			 Gate	 <DisplayBegin,Puthex32I_Sel,,AT386TGate,>	 ;0f7h:	display	a   +
   1108		  0000			 character interrupt 247
   1109	    07C0  0000 00A8 00 85 0000			 Gate	 <,SearchTSS_Sel,,ATTaskGate,>			 ;0f8h:	Search	    +
   1110					 memory	for given value	248
   1111	    07C8  0000 0100 00 85 0000			 Gate	 <,App2TSS_Sel,,ATTaskGate,>			 ;0f9h:	Application +
   1112					 2 249
   1113	    07D0  0000 0050 00 85 0000			 Gate	 <,GetSecTSS_Sel,,ATTaskGate,>			 ;0fah:	read one    +
   1114					 sector	at a time 250
   1115	    07D8  0000 0048 00 85 0000			 Gate	 <,GetDecTSS_Sel,,ATTaskGate,>			 ;0fbh:	get decimal +
   1116					 251
   1117	    07E0  0000 0040 00 85 0000			 Gate	 <,GetCharTSS_Sel,,ATTaskGate,>			 ;0fch:	get	    +
   1118					 character 252
   1119	    07E8  0031r	0098 00	8F    +			 Gate	 <PUTHEX32P,Puthex32I_Sel,,AT386TGate,>		 ;0fdh:	Puthex32P   +
   1120		  0000			 253
   1121	    07F0  0000 00C8 00 85 0000			 Gate	 <,App1TSS_Sel,,ATTaskGate,>			 ;0feh:	Application +
   1122					 1 254
   1123	    07F8  0000 0060 00 85 0000			 Gate	 <,GKeyTSS_Sel,,ATTaskGate,>			 ;0ffh:	AOA display +
   1124					 255
   1125					 ;-------------------------------------------------------------------------
   1126		  = 0800		 IDTLen		 =	 $-IDT
   1127	    0800			 IDTSeg		 ENDS
   1128					 ;***************************************************************************
   1129					 ;  GDT	Segment
   1130					 ;  16 bit segment
   1131					 ;***************************************************************************
   1132	    0000			 GKeyLDTSeg	 SEGMENT PARA USE16
   1133
   1134	    0000			 GLDT		 LABEL	 BYTE
   1135
   1136	    0000  FFFF 0080s 00	98 00 +	 GKeyCode	 Desc	 <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>
   1137		  00
   1138		  = 0004		 GKeyCode_Sel	 =	 GKeyCode-GLDT+TIL
   1139	    0008  01FF 0080s 00	93 00 +	 GKeyStack	 Desc	 <DemoStack3Len-1,DemoStack3Seg+RELOCATE1,,ATDWA,,>
   1140		  00
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 21
prcycle.ASM



   1141		  = 000C		 GKeyStack_Sel	 =	 GKeyStack-GLDT+TIL
   1142					 ;--------------------------------------------------------------------------
   1143		  = 0002		 GKeyLDNum	 =	 ($-GLDT)/(SIZE	Desc)	 ;THE NUMBER OF	INITIAL	BASE
   1144		  = GKEYLDTSEG:0010	 GKeyLDTLen	 =	 $
   1145					 ;--------------------------------------------------------------------------
   1146	    0010			 GKeyLDTSeg	 ENDS
   1147					 ;***************************************************************************
   1148					 ;  GDT	Segment
   1149					 ;for general keyboard interrupt
   1150					 ;  16 bit segment
   1151					 ;***************************************************************************
   1152	    0000			 GetCharLDTSeg	    SEGMENT PARA USE16
   1153
   1154	    0000			 CLDT		 LABEL	 BYTE
   1155
   1156	    0000  FFFF 0080s 00	98 00 +	 GetCharCode	    Desc    <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>
   1157		  00
   1158		  = 0004		 GetCharCode_Sel    =	    GetCharCode-CLDT+TIL
   1159	    0008  01FF 0080s 00	93 00 +	 GetCharStack	    Desc    <GetCharStackLen-1,GetCharStackSeg+RELOCATE1,,ATDWA,,>
   1160		  00
   1161		  = 000C		 GetCharStack_Sel   =	    GetCharStack-CLDT+TIL
   1162					 ;--------------------------------------------------------------------------
   1163		  = 0002		 GetCharLDNum	    =	    ($-CLDT)/(SIZE Desc)    ;THE NUMBER	OF INITIAL BASE
   1164		  = GETCHARLDTSEG:0010	 GetCharLDTLen	    =	    $
   1165					 ;--------------------------------------------------------------------------
   1166	    0010			 GetCharLDTSeg	    ENDS
   1167					 ;***************************************************************************
   1168					 ;  SearchLDTSeg Segment
   1169					 ;  16 bit segment
   1170					 ;***************************************************************************
   1171	    0000			 SearchLDTSeg	   SEGMENT PARA	USE16
   1172
   1173	    0000			 SEARCHLDTS	       LABEL   BYTE
   1174
   1175	    0000  FFFF 0080s 00	98 00 +	 SearchCode	   Desc	   <0ffffh,PCodeSeg+RELOCATE1,,ATCE,,>
   1176		  00
   1177		  = 0004		 SearchCode_Sel	   =	   SearchCode-SEARCHLDTS+TIL
   1178	    0008  0111r	0080s 00 92 00+	 SearchData	   Desc	   <GlobalDataLen-1,GlobalDataSeg+RELOCATE1,,ATDW,,0h>
   1179		  00
   1180		  = 000C		 SearchData_Sel	   =	   SearchData-SEARCHLDTS+TIL
   1181	    0010  FFFF 0000 00 93 CF  +	 SearchForData	   Desc	   <0ffffh,0,0,93h,0cfh,0>
   1182		  00
   1183		  = 0014		 SearchForData_Sel =	   SearchForData-SEARCHLDTS+TIL
   1184	    0018  01FF 0080s 00	93 00 +	 SearchStack	   Desc	   <SearchStackLen-1,SearchStackSeg+RELOCATE1,,ATDWA,,>
   1185		  00
   1186		  = 001C		 SearchStack_Sel   =	   SearchStack-SEARCHLDTS+TIL
   1187					 ;--------------------------------------------------------------------------
   1188		  = 0004		 SearchLDNum	   =	   ($-SEARCHLDTS)/(SIZE	Desc)	 ;THE NUMBER OF	INITIAL	BASE
   1189		  = SEARCHLDTSEG:0020	 SearchLDTLen	   =	   $
   1190					 ;--------------------------------------------------------------------------
   1191	    0020			 SearchLDTSeg	   ENDS
   1192
   1193					 ;***************************************************************************
   1194	    0000			 GetDecLDTSeg	   SEGMENT PARA	USE16
   1195
   1196	    0000			 DLDT		 LABEL	 BYTE
   1197
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 22
prcycle.ASM



   1198	    0000  FFFF 0080s 00	98 00 +	 GetDecCode	   Desc	   <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>
   1199		  00
   1200		  = 0004		 GetDecCode_Sel	   =	   GetDecCode-DLDT+TIL
   1201	    0008  01FF 0080s 00	93 00 +	 GetDecStack	   Desc	   <GetDecStackLen-1,GetDecStackSeg+RELOCATE1,,ATDWA,,>
   1202		  00
   1203		  = 000C		 GetDecStack_Sel   =	   GetDecStack-DLDT+TIL
   1204					 ;--------------------------------------------------------------------------
   1205		  = 0002		 GetDecLDNum	   =	   ($-DLDT)/(SIZE Desc)	   ;THE	NUMBER OF INITIAL BASE
   1206		  = GETDECLDTSEG:0010	 GetDecLDTLen	   =	   $
   1207					 ;--------------------------------------------------------------------------
   1208	    0010			 GetDecLDTSeg	   ENDS
   1209					 ;***************************************************************************
   1210					 ;get sector LDT segment
   1211					 ;***************************************************************************
   1212	    0000			 GetSecLDTSeg	   SEGMENT PARA	USE16
   1213
   1214	    0000			 KLDT		 LABEL	 BYTE
   1215
   1216	    0000  FFFF 0080s 00	98 00 +	 GetSecCode	   Desc	   <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>
   1217		  00
   1218		  = 0004		 GetSecCode_Sel	   =	   GetSecCode-KLDT+TIL
   1219	    0008  01FF 0080s 00	93 00 +	 GetSecStack	   Desc	   <GetDecStackLen-1,GetDecStackSeg+RELOCATE1,,ATDWA,,>
   1220		  00
   1221		  = 000C		 GetSecStack_Sel   =	   GetSecStack-KLDT+TIL
   1222					 ;--------------------------------------------------------------------------
   1223		  = 0002		 GetSecLDNum	   =	   ($-KLDT)/(SIZE Desc)	   ;THE	NUMBER OF INITIAL BASE
   1224		  = GETSECLDTSEG:0010	 GetSecLDTLen	   =	   $
   1225					 ;--------------------------------------------------------------------------
   1226	    0010			 GetSecLDTSeg	   ENDS
   1227					 ;***************************************************************************
   1228					 ;Write	sector LDT segment
   1229					 ;***************************************************************************
   1230	    0000			 WriteSecLDTSeg	     SEGMENT PARA USE16
   1231
   1232	    0000			 WLDT		 LABEL	 BYTE
   1233
   1234	    0000  FFFF 0080s 00	98 00 +	 WriteSecCode	     Desc    <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>
   1235		  00
   1236		  = 0004		 WriteSecCode_Sel    =	     WriteSecCode-WLDT+TIL
   1237	    0008  01FF 0080s 00	93 00 +	 WriteSecStack	     Desc    <WriteSecStackLen-1,WriteSecStackSeg+RELOCATE1,,ATDWA,,>
   1238		  00
   1239		  = 000C		 WriteSecStack_Sel   =	     WriteSecStack-WLDT+TIL
   1240					 ;--------------------------------------------------------------------------
   1241		  = 0002		 WriteSecLDNum	     =	     ($-WLDT)/(SIZE Desc)    ;THE NUMBER OF INITIAL BASE
   1242		  = WRITESECLDTSEG:0010	 WriteSecLDTLen	     =	     $
   1243					 ;--------------------------------------------------------------------------
   1244	    0010			 WriteSecLDTSeg	     ENDS
   1245					 ;***************************************************************************
   1246	    0000			 App1LDTSeg	 SEGMENT PARA USE16
   1247					 ;----------------------------------------------------------------------------
   1248	    0000			 ALDT		 LABEL	 BYTE
   1249
   1250					 ;IApp1Code16	  Desc		 <IApp1CodeLen16-1,IApp1CodeSeg16+RELOCATE1,,ATCE,,>
   1251					 ;IApp1Code16_Sel =		 IApp1Code16-ALDT+TIL
   1252					 ;IApp1Code32	  Desc		 <IApp1CodeLen32-1,IApp1CodeSeg32+RELOCATE1,,ATCE,D32,>
   1253					 ;IApp1Code32_Sel =		 IApp1Code32-ALDT+TIL
   1254					 ;-----------------------------------------------------------------------------
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 23
prcycle.ASM



   1255					 ;  SET	APPLICATION 1 SEGMENT DESCRIPTORS
   1256					 ;App1Stack	  Desc	 <0ffffh,400h+APPL1RELOCATE,10h,ATDWA,,>  ;740h
   1257					 ;App1Stack	  Desc	 <0ffffh,40h+APPL1RELOCATE,10h,ATDWA,,>	 ;740h
   1258					 ;App1Stack	  Desc	 <0a00h,00h+APPL1RELOCATE,11h,ATSWA,,>	;
   1259					 ;App1Stack	  Desc	 <0ffffh,00h+APPL1RELOCATE,11h,ATSWA,,>	 ;
   1260					 ;App1Stack	  Desc	 <0fffh,00h+APPL1RELOCATE,23h,093h,0c0h,01h>  ;
   1261					 ;App1Stack	  Desc	 <0ffffh,00h+APPL1RELOCATE,11h,ATSWA,,>	 ;
   1262					 ;App1Stack	  Desc	 <0ffffh,00h+APPL1RELOCATE,0h,093h,0c0h,02h>  ;
   1263					 ;*************************************************
   1264					 ; The following stack segment will enable stack to
   1265					 ;  start at 01230000h RKK/LSUN	11-07-2003 working for
   1266					 ;  teststack example
   1267					 ; also	change ESP value to 00ffefffh in two places LARGESTACK
   1268					 ;  ---start of	stack 01230000h
   1269					 ;  ---	value in ESP + start of	stack --> top of stack
   1270					 ;  ---	Top of Stack is	01230000+00ffefff = 0222EFFFh
   1271					 ;  --	this is	good for 16M stack
   1272					 ;*************************************************
   1273					 ;App1Stack	  Desc	 <0ffffh,00h+APPL1RELOCATE,23h,093h,0cfh,01h>  ; last working
   1274	    0000  FFFF 0000 11 93 CF  +	 App1Stack	 Desc	 <0ffffh,00h+APPL1RELOCATE,11h,093h,0cfh,00h>  ; last working
   1275		  00
   1276		  = 0004		 App1Stack_Sel	 =	 App1Stack-ALDT+TIL
   1277					 ;------------------------------------------------------------------------------
   1278					 ;descriptor format
   1279					 ; Segment Limit (2 bytes LSB);	Base Address (2	bytes 15-0);Base Address (3rd byte 23-16);
   1280					 ;   P/DPL/S byte 5 1 00 1 0011;
   1281					 ;   G/B/00: 1100 byte 6; 0000 upper digit of limit byte 7
   1282					 ;   Base address is 01230000
   1283					 ;   Limit is 00fff*4k is 00fff000/
   1284					 ;   ESP shoud be initialized to 00ffefffh
   1285					 ;------------------------------------------------------------------------------
   1286					 ; App1Data
   1287					 ; App1Stack
   1288					 ; load	 0033; 0021; 0000; 0001; 1000 as parameters in the menu:
   1289					 ; point all ds, cs, ss	base values to 11
   1290					 ;------------------------------------------------------------------------------
   1291					 ;App1Data	  Desc	 <0ffffh,00h+APPL1RELOCATE,11h,ATDW,D32,>
   1292	    0008  FFFF 0000 11 92 CF  +	 App1Data	 Desc	<0ffffh,00h+APPL1RELOCATE,11h,ATDW,0cfh,0h> ; global bit set
   1293		  00
   1294		  = 000C		 App1Data_Sel	 =	 App1Data-ALDT+TIL
   1295	    0010  FFFF 0000 11 98 CF  +	 App1Code	 Desc	 <0ffffh,BaseOfCode+APPL1RELOCATE,11h,ATCE,0cfh,0h>
   1296		  00
   1297					 ;App1Code	  Desc		 <0ffffh,BaseOfCode+APPL1RELOCATE,20h,ATCE,0cfh,0h>  ;	    +
   1298					 global	bit set
   1299		  = 0014		 App1Code_Sel	 =	 App1Code-ALDT+TIL
   1300	    0018  292B 0014 00 EC 0000	 App1_Sch_Gate	   Gate	   <292Bh,App1Code_Sel,,AT386CGate+DPL3,>
   1301
   1302		  = 001C		 App1_Sch_Sel		 =	 App1_Sch_Gate-ALDT+TIL
   1303
   1304					 ;App1_Code	   Desc		 <0ffffh,292bh,11h,ATCE,0cfh,0h>
   1305					 ;App1Code	  Desc		 <0ffffh,BaseOfCode+APPL1RELOCATE,20h,ATCE,0cfh,0h>  ;	    +
   1306					 global	bit set
   1307					 ;App1_Code_Sel	   =		 App1_Code-ALDT+TIL
   1308
   1309					 ;--------------------------------------------------------------------------------
   1310					 ;App1Stack0	   Desc		 <400h,0h+APPL1RELOCATE,11h,ATSWA+DPL0,,>
   1311	    0020  FFFF 0000 00 93 C0  +	 App1Stack0	  Desc	 <0ffffh,00h+APPL1RELOCATE,0h,093h,0c0h,03h>  ;
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 24
prcycle.ASM



   1312		  03
   1313		  = 0024		 App1Stack0_Sel	  =	 App1Stack0-ALDT+TIL
   1314					 ;App1Stack1	   Desc		 <400h,0h+APPL1RELOCATE,11h,ATSWA+DPL1,,>
   1315	    0028  FFFF 0000 00 93 C0  +	 App1Stack1	  Desc	 <0ffffh,00h+APPL1RELOCATE,0h,093h,0c0h,04h>  ;
   1316		  04
   1317		  = 002C		 App1Stack1_Sel	  =	 App1Stack1-ALDT+TIL
   1318					 ;App1Stack2	   Desc		 <400h,0h+APPL1RELOCATE,11h,ATSWA+DPL3,,>
   1319	    0030  FFFF 0000 00 93 C0  +	 App1Stack2	  Desc	 <0ffffh,00h+APPL1RELOCATE,0h,093h,0c0h,05h>  ;
   1320		  05
   1321		  = 0034		 App1Stack2_Sel	  =	 App1Stack2-ALDT+TIL
   1322					 ;----------------------------------------------------------------------------
   1323		  = 0007		 App1LDNum	 =	 ($-ALDT)/(SIZE	Desc)	 ;THE NUMBER OF	INITIAL	BASE
   1324		  = APP1LDTSEG:0038	 App1LDTLen	 =	 $
   1325					 ;----------------------------------------------------------------------------
   1326	    0038			 App1LDTSeg	 ENDS
   1327					 ;--------------------------------------------------------------------------
   1328					 ;***************************************************************************
   1329	    0000			 App2LDTSeg	 SEGMENT PARA USE16
   1330					 ;----------------------------------------------------------------------------
   1331	    0000			 A2LDT		  LABEL	  BYTE
   1332
   1333	    0000  0A00 0000 41 96 00  +	 App2Stack	 Desc	 <0a00h,0h+APPL1RELOCATE,41h,ATSWA,,>  ;740h
   1334		  00
   1335		  = 0004		 App2Stack_Sel	 =	 App2Stack-A2LDT+TIL
   1336	    0008  FFFF 0000 41 92 40  +	 App2Data	 Desc	<0ffffh,APPL1RELOCATE,41h,ATDW,D32,>
   1337		  00
   1338					 ;App2Data	  Desc	 <0ffffh,00h+APPL1RELOCATE,11h,ATDW,0cfh,0h> ; global bit set
   1339
   1340		  = 000C		 App2Data_Sel	 =	 App2Data-A2LDT+TIL
   1341	    0010  FFFF 0000 40 98 CF  +	 App2Code	 Desc	 <0ffffh,BaseOfCode+APPL1RELOCATE,40h,ATCE,0cfh,0h>
   1342		  00
   1343					 ;App2Code	  Desc		 <0ffffh,BaseOfCode+APPL1RELOCATE,11h,ATCE,0cfh,0h>
   1344		  = 0014		 App2Code_Sel	 =	 App2Code-A2LDT+TIL
   1345					 ;----------------------------------------------------------------------------
   1346		  = 0003		 App2LDNum	 =	 ($-A2LDT)/(SIZE Desc)		 ;THE NUMBER OF	INITIAL	BASE
   1347		  = APP2LDTSEG:0018	 App2LDTLen	 =	 $
   1348					 ;----------------------------------------------------------------------------
   1349	    0018			 App2LDTSeg	 ENDS
   1350					 ;--------------------------------------------------------------------------
   1351					 ;***************************************************************************
   1352					 ;   GkeyTSSSeg	Segment
   1353					 ;   16	bit segment
   1354					 ;   This is a 32 bit TSS format (386 and higher)
   1355					 ;***************************************************************************
   1356	    0000			 GKeyTSSSeg	 SEGMENT PARA USE16
   1357	    0000  00000000				 DD	 0			 ;LINK
   1358	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1359	    0008  ???? ????				 DW	 ?,?
   1360	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1361	    0010  ???? ????				 DW	 ?,?
   1362	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1363	    0018  ???? ????				 DW	 ?,?
   1364	    001C  00000000				 DD	 0			 ;CR3
   1365	    0020  039Er	0000				 DW	 GKeyBegin,0		 ;EIP
   1366	    0024  00000000				 DD	 0			 ;EFLAGS
   1367	    0028  00000000				 DD	 0			 ;EAX
   1368	    002C  00000000				 DD	 0			 ;ECX
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 25
prcycle.ASM



   1369	    0030  00000000				 DD	 0			 ;EDX
   1370	    0034  00000000				 DD	 0			 ;EBX
   1371	    0038  0200 0000				 DW	 DemoStack3Len,0	  ;ESP
   1372	    003C  00000000				 DD	 0			 ;EBP
   1373	    0040  00000000				 DD	 0			 ;ESI
   1374	    0044  00000000				 DD	 0			 ;EDI
   1375	    0048  0008 0000				 DW	 Normal_Sel,0		 ;ES
   1376	    004C  0004 0000				 DW	 GKeyCode_Sel,0		 ;CS
   1377	    0050  000C 0000				 DW	 GKeyStack_Sel,0	 ;SS
   1378	    0054  0008 0000				 DW	 Normal_Sel,0		 ;DS
   1379	    0058  0008 0000				 DW	 Normal_Sel,0		 ;FS
   1380	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1381	    0060  0068 0000				 DW	 GKeyLDT_Sel,0		 ;LDTR
   1382	    0064  0000					 DW	 0			 ;TRAP SIGN
   1383	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1384	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1385		  = GKEYTSSSEG:0069	 GKeyTSSLen	 =	 $
   1386					 ;----------------------------------------------------------------------------
   1387	    0069			 GKeyTSSSeg	 ENDS
   1388					 ;***************************************************************************
   1389					 ;   SearchTSSSeg Segment
   1390					 ;   16	bit segment
   1391					 ;   This is a 32 bit TSS format (386 and higher)
   1392					 ;***************************************************************************
   1393	    0000			 SearchTSSSeg	   SEGMENT PARA	USE16
   1394	    0000  00000000				 DD	 0			 ;LINK
   1395	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1396	    0008  ???? ????				 DW	 ?,?
   1397	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1398	    0010  ???? ????				 DW	 ?,?
   1399	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1400	    0018  ???? ????				 DW	 ?,?
   1401	    001C  00000000				 DD	 0			 ;CR3
   1402	    0020  0486r	0000				 DW	 SearchBegin,0		 ;EIP
   1403	    0024  00000000				 DD	 0			 ;EFLAGS
   1404	    0028  00000000				 DD	 0			 ;EAX
   1405	    002C  00000000				 DD	 0			 ;ECX
   1406	    0030  00000000				 DD	 0			 ;EDX
   1407	    0034  00000000				 DD	 0			 ;EBX
   1408	    0038  0200 0000				 DW	 SearchStackLen,0	 ;ESP
   1409	    003C  00000000				 DD	 0			 ;EBP
   1410	    0040  00000000				 DD	 0			 ;ESI
   1411	    0044  00000000				 DD	 0			 ;EDI
   1412	    0048  0014 0000				 DW	 SearchForData_Sel,0		;ES
   1413	    004C  0004 0000				 DW	 SearchCode_Sel,0	 ;CS
   1414	    0050  001C 0000				 DW	 SearchStack_Sel,0	 ;SS
   1415	    0054  000C 0000				 DW	 SearchData_Sel,0	     ;DS
   1416	    0058  000C 0000				 DW	 SearchData_Sel,0	     ;FS
   1417	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1418	    0060  00A0 0000				 DW	 SearchLDT_Sel,0	 ;LDTR
   1419	    0064  0000					 DW	 0			 ;TRAP SIGN
   1420	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1421	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1422		  = SEARCHTSSSEG:0069	 SearchTSSLen	   =	   $
   1423					 ;----------------------------------------------------------------------------
   1424	    0069			 SearchTSSSeg	   ENDS
   1425
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 26
prcycle.ASM



   1426					 ;***************************************************************************
   1427					 ;   GkeyTSSSeg	Segment
   1428					 ;   16	bit segment
   1429					 ;   This is a 32 bit TSS format (386 and higher)
   1430					 ;***************************************************************************
   1431	    0000			 GetCharTSSSeg	    SEGMENT PARA USE16
   1432	    0000  00000000				 DD	 0			 ;LINK
   1433	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1434	    0008  ???? ????				 DW	 ?,?
   1435	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1436	    0010  ???? ????				 DW	 ?,?
   1437	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1438	    0018  ???? ????				 DW	 ?,?
   1439	    001C  00000000				 DD	 0			 ;CR3
   1440	    0020  0299r	0000				 DW	 GetCharBegin,0		    ;EIP
   1441	    0024  00000000				 DD	 0			 ;EFLAGS
   1442	    0028  00000000				 DD	 0			 ;EAX
   1443	    002C  00000000				 DD	 0			 ;ECX
   1444	    0030  00000000				 DD	 0			 ;EDX
   1445	    0034  00000000				 DD	 0			 ;EBX
   1446	    0038  0200 0000				 DW	 GetCharStackLen,0	    ;ESP
   1447	    003C  00000000				 DD	 0			 ;EBP
   1448	    0040  00000000				 DD	 0			 ;ESI
   1449	    0044  00000000				 DD	 0			 ;EDI
   1450	    0048  0008 0000				 DW	 Normal_Sel,0		 ;ES
   1451	    004C  0004 0000				 DW	 GetCharCode_Sel,0	    ;CS
   1452	    0050  000C 0000				 DW	 GetCharStack_Sel,0	    ;SS
   1453	    0054  0008 0000				 DW	 Normal_Sel,0		 ;DS
   1454	    0058  0008 0000				 DW	 Normal_Sel,0		 ;FS
   1455	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1456	    0060  0070 0000				 DW	 GetCharLDT_Sel,0	    ;LDTR
   1457	    0064  0000					 DW	 0			 ;TRAP SIGN
   1458	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1459	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1460		  = GETCHARTSSSEG:0069	 GetCharTSSLen	    =	    $
   1461					 ;----------------------------------------------------------------------------
   1462	    0069			 GetCharTSSSeg	    ENDS
   1463
   1464					 ;******************************************************************************
   1465					 ;***************************************************************************
   1466					 ;   GetDecTSSSeg Segment
   1467					 ;   16	bit segment
   1468					 ;   This is a 32 bit TSS format (386 and higher)
   1469					 ;***************************************************************************
   1470	    0000			 GetDecTSSSeg	   SEGMENT PARA	USE16
   1471	    0000  00000000				 DD	 0			 ;LINK
   1472	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1473	    0008  ???? ????				 DW	 ?,?
   1474	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1475	    0010  ???? ????				 DW	 ?,?
   1476	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1477	    0018  ???? ????				 DW	 ?,?
   1478	    001C  00000000				 DD	 0			 ;CR3
   1479	    0020  02FFr	0000				 DW	 GetDecBegin,0		   ;EIP
   1480	    0024  00000000				 DD	 0			 ;EFLAGS
   1481	    0028  00000000				 DD	 0			 ;EAX
   1482	    002C  00000000				 DD	 0			 ;ECX
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 27
prcycle.ASM



   1483	    0030  00000000				 DD	 0			 ;EDX
   1484	    0034  00000000				 DD	 0			 ;EBX
   1485	    0038  0200 0000				 DW	 GetDecStackLen,0	 ;ESP
   1486	    003C  00000000				 DD	 0			 ;EBP
   1487	    0040  00000000				 DD	 0			 ;ESI
   1488	    0044  00000000				 DD	 0			 ;EDI
   1489	    0048  0008 0000				 DW	 Normal_Sel,0		 ;ES
   1490	    004C  0004 0000				 DW	 GetDecCode_Sel,0	   ;CS
   1491	    0050  000C 0000				 DW	 GetDecStack_Sel,0	   ;SS
   1492	    0054  0008 0000				 DW	 Normal_Sel,0		 ;DS
   1493	    0058  0008 0000				 DW	 Normal_Sel,0		 ;FS
   1494	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1495	    0060  0078 0000				 DW	 GetDecLDT_Sel,0	   ;LDTR
   1496	    0064  0000					 DW	 0			 ;TRAP SIGN
   1497	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1498	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1499		  = GETDECTSSSEG:0069	 GetDecTSSLen	   =	   $
   1500					 ;----------------------------------------------------------------------------
   1501	    0069			 GetDecTSSSeg	   ENDS
   1502
   1503					 ;******************************************************************************
   1504					 ;   GetSecTSSSeg Segment
   1505					 ;   16	bit segment
   1506					 ;   This is a 32 bit TSS format (386 and higher)
   1507					 ;    Read one sector task
   1508					 ;***************************************************************************
   1509	    0000			 GetSecTSSSeg	   SEGMENT PARA	USE16
   1510	    0000  00000000				 DD	 0			 ;LINK
   1511	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1512	    0008  ???? ????				 DW	 ?,?
   1513	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1514	    0010  ???? ????				 DW	 ?,?
   1515	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1516	    0018  ???? ????				 DW	 ?,?
   1517	    001C  00000000				 DD	 0			 ;CR3
   1518	    0020  0414r	0000				 DW	 GetSecBegin,0		   ;EIP
   1519	    0024  00000000				 DD	 0			 ;EFLAGS
   1520	    0028  00000000				 DD	 0			 ;EAX
   1521	    002C  00000000				 DD	 0			 ;ECX
   1522	    0030  00000000				 DD	 0			 ;EDX
   1523	    0034  00000000				 DD	 0			 ;EBX
   1524	    0038  0200 0000				 DW	 GetSecStackLen,0	 ;ESP
   1525	    003C  00000000				 DD	 0			 ;EBP
   1526	    0040  00000000				 DD	 0			 ;ESI
   1527	    0044  00000000				 DD	 0			 ;EDI
   1528	    0048  0008 0000				 DW	 Normal_Sel,0		 ;ES
   1529	    004C  0004 0000				 DW	 GetSecCode_Sel,0	 ;CS
   1530	    0050  000C 0000				 DW	 GetSecStack_Sel,0	 ;SS
   1531	    0054  0008 0000				 DW	 Normal_Sel,0		 ;DS
   1532	    0058  0008 0000				 DW	 Normal_Sel,0		 ;FS
   1533	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1534	    0060  0080 0000				 DW	 GetSecLDT_Sel,0	 ;LDTR
   1535	    0064  0000					 DW	 0			 ;TRAP SIGN
   1536	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1537	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1538		  = GETSECTSSSEG:0069	 GetSecTSSLen	   =	   $
   1539					 ;----------------------------------------------------------------------------
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 28
prcycle.ASM



   1540	    0069			 GetSecTSSSeg	   ENDS
   1541					 ;******************************************************************************
   1542					 ;******************************************************************************
   1543					 ;   WriteSecTSSSeg Segment
   1544					 ;   16	bit segment
   1545					 ;   This is a 32 bit TSS format (386 and higher)
   1546					 ;    Write one	sector task
   1547					 ;***************************************************************************
   1548	    0000			 WriteSecTSSSeg	     SEGMENT PARA USE16
   1549	    0000  00000000				 DD	 0			 ;LINK
   1550	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1551	    0008  ???? ????				 DW	 ?,?
   1552	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1553	    0010  ???? ????				 DW	 ?,?
   1554	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1555	    0018  ???? ????				 DW	 ?,?
   1556	    001C  00000000				 DD	 0			 ;CR3
   1557	    0020  04BEr	0000				 DW	 WriteSecBegin,0	 ;EIP
   1558	    0024  00000000				 DD	 0			 ;EFLAGS
   1559	    0028  00000000				 DD	 0			 ;EAX
   1560	    002C  00000000				 DD	 0			 ;ECX
   1561	    0030  00000000				 DD	 0			 ;EDX
   1562	    0034  00000000				 DD	 0			 ;EBX
   1563	    0038  0200 0000				 DW	 GetSecStackLen,0	   ;ESP
   1564	    003C  00000000				 DD	 0			 ;EBP
   1565	    0040  00000000				 DD	 0			 ;ESI
   1566	    0044  00000000				 DD	 0			 ;EDI
   1567	    0048  0008 0000				 DW	 Normal_Sel,0		 ;ES
   1568	    004C  0004 0000				 DW	 GetSecCode_Sel,0	 ;CS
   1569	    0050  000C 0000				 DW	 GetSecStack_Sel,0	 ;SS
   1570	    0054  0008 0000				 DW	 Normal_Sel,0		 ;DS
   1571	    0058  0008 0000				 DW	 Normal_Sel,0		 ;FS
   1572	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1573	    0060  0080 0000				 DW	 GetSecLDT_Sel,0	 ;LDTR
   1574	    0064  0000					 DW	 0			 ;TRAP SIGN
   1575	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1576	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1577		  = WRITESECTSSSEG:0069	 WriteSecTSSLen	     =	     $
   1578					 ;----------------------------------------------------------------------------
   1579	    0069			 WriteSecTSSSeg	     ENDS
   1580					 ;******************************************************************************
   1581					 ; Application 1 TSS
   1582					 ; This	is a 32	bit TSS	format (386 and	higher)
   1583					 ; ALL the Selectors for the Segment registers being initialized in the
   1584					 ; TSS Segment must be located in the App1LDTSeg
   1585					 ;	 If we want to run a 16	bit internal application open up the
   1586					 ;	 two comments	 I.	 DW	 IApp1Begin16,0
   1587					 ;			 II.	 DW	 IApp1Code16_Sel,0
   1588					 ;
   1589					 ;	 If we want to run a 32	bit internal application open up the
   1590					 ;	 two comments	 I.	 DW	 IApp1Begin32,0
   1591					 ;			 II.	 DW	 IApp1Code32_Sel,0
   1592					 ;******************************************************************************
   1593	00000000			 App1TSSSeg	 SEGMENT PARA USE32
   1594
   1595	00000000			 App1TaskTSS	 LABEL	 BYTE
   1596	00000000  00000000				 DD	 0			 ;LINK
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 29
prcycle.ASM



   1597	00000004  0000FFFF				 DD	 0ffffh			 ;stack	0 length
   1598	00000008  00000024				 DD	 App1Stack0_Sel		 ;stack	selector for 0 level
   1599	0000000C  0000FFFF				 DD	 0ffffh				 ;stack	1 length
   1600	00000010  0000002C				 DD	 App1Stack1_Sel		 ;stack	selector for 1 level
   1601	00000014  0000FFFF				 DD	 0ffffh			   ;stack 2 length
   1602	00000018  00000034				 DD	 App1Stack2_Sel		 ;stack	selector for 2 level
   1603	0000001C  00000000				 DD	 0			 ;CR3
   1604	00000020  00000000				 DD	 0h			 ;EIP
   1605						 ;	 DD	 3202h			   ;EFLAGS
   1606	00000024  00000202				 DD	 0202h			   ;EFLAGS
   1607	00000028  00000000				 DD	 0			 ;EAX
   1608	0000002C  00000000				 DD	 0			 ;ECX
   1609	00000030  00000000				 DD	 0			 ;EDX
   1610	00000034  00000000				 DD	 0			 ;EBX
   1611							 ;DW	  0ffffh,0		 ;App1StackLen,0 ;ESP
   1612							 ;DW	  0d00h,0		 ;App1StackLen,0 ;ESP
   1613							 ;DW	  0ffffh,0013h		 ;App1StackLen,0 ;ESP
   1614							 ;dd	 01ffffh
   1615							 ;dd	 0fffffh
   1616							 ;dd	 0000ffffh
   1617							 ;dd	 00ffefffh		  ;LARGESTACK works for	teststack example
   1618	00000038  01E84800				 dd	 01e84800h		  ; 32 M
   1619							 ;dd	 01ff0000h
   1620							 ;dd	 0000ffffh
   1621							 ; because we use the stack dowside, system will add statck start address by+
   1622					 esp
   1623							 ; this	will be	the actual start address and stack will	go down
   1624							 ; for ex: if the code starts at 00111000h and PSP is at 00110000h
   1625							 ;  we would like to start stack at 00110d00h, in order	to achieve this
   1626							 ;  we can set esp a value of 0d00h, base value	in the selector	will be	0h
   1627							 ;    and the limit will be 0a00h so that 0200h	will be	left for PSP
   1628	0000003C  00000000				 DD	 0			 ;EBP
   1629	00000040  00000000				 DD	 0			 ;ESI
   1630	00000044  00000000				 DD	 0			 ;EDI
   1631	00000048  000C 0000				 DW	 App1Data_Sel,0		 ;ES
   1632	0000004C  0014 0000				 DW	 App1Code_Sel,0		 ;CS
   1633	00000050  0004 0000				 DW	 App1Stack_Sel,0	 ;SS
   1634	00000054  000C 0000				 DW	 App1Data_Sel,0		 ;DS
   1635	00000058  0000 0000				 DW	 0,0			 ;FS
   1636	0000005C  0000 0000				 DW	 0,0			 ;GS
   1637	00000060  00D8 0000				 DW	 App1LDT_Sel,0		 ;LDTR also there in GDT
   1638	00000064  0000					 DW	 0			 ;TRAP SIGN
   1639	00000066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1640	00000068  07*(00)				 DB	 7 DUP(0)		 ;I/O MAPPING Rounding it to 112 bytes in   +
   1641					 the user memory space
   1642	0000006F  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1643		  = APP1TSSSEG:0070	 App1TSSLen	 =	 $			 ; Length of the segment a constant
   1644					 ; this	stored in memory at SizeOf_TSS1	as a word
   1645					 ;----------------------------------------------------------------------------
   1646	00000070			 App1TSSSeg	 ENDS
   1647
   1648					 ;***************************************************************************
   1649	    0000			 App2TSSSeg	 SEGMENT PARA USE16
   1650	    0000			 App2TaskTSS	 LABEL	 BYTE
   1651	    0000  00000000				 DD	 0			 ;LINK
   1652	    0004  00000000				 DD	 0h			 ;stack	0 length
   1653	    0008  00000000				 DD	 0h			 ;stack	selector for 0 level
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 30
prcycle.ASM



   1654	    000C  00000000				 DD	 0h			 ;stack	1 length
   1655	    0010  00000000				 DD	 0h			 ;stack	selector for 1 level
   1656	    0014  00000000				 DD	 0h			 ;stack	2 length
   1657	    0018  00000000				 DD	 0h			 ;stack	selector for 2 level
   1658	    001C  00000000				 DD	 0			 ;CR3
   1659	    0020  00000000				 DD	 0h			 ;EIP
   1660	    0024  000000CA				 DD	 0202			    ;EFLAGS
   1661	    0028  00000000				 DD	 0			 ;EAX
   1662	    002C  00000000				 DD	 0			 ;ECX
   1663	    0030  00000000				 DD	 0			 ;EDX
   1664	    0034  00000000				 DD	 0			 ;EBX
   1665	    0038  0D00 0000				 DW	 0d00h,0		 ;App1StackLen,0 ;ESP
   1666	    003C  00000000				 DD	 0			 ;EBP
   1667	    0040  00000000				 DD	 0			 ;ESI
   1668	    0044  00000000				 DD	 0			 ;EDI
   1669	    0048  000C 0000				 DW	 App2Data_Sel,0		 ;ES
   1670	    004C  0014 0000				 DW	 App2Code_Sel,0		 ;CS
   1671	    0050  0004 0000				 DW	 App2Stack_Sel,0	 ;SS
   1672	    0054  000C 0000				 DW	 App2Data_Sel,0		 ;DS
   1673	    0058  0000 0000				 DW	 0,0			 ;FS
   1674	    005C  0000 0000				 DW	 0,0			 ;GS
   1675	    0060  0110 0000				 DW	 App2LDT_Sel,0		 ;LDTR
   1676	    0064  0000					 DW	 0			 ;TRAP SIGN
   1677	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1678	    0068  0397*(00)				 DB	 919 DUP(0)		 ;I/O MAPPING
   1679	    03FF  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1680		  = APP2TSSSEG:0400	 App2TSSLen	 =	 $
   1681					 ;----------------------------------------------------------------------------
   1682	    0400			 App2TSSSeg	 ENDS
   1683
   1684					 ;***************************************************************************
   1685					 ; DemoLDTSeg Segment
   1686					 ; 16 bit segment
   1687					 ;***************************************************************************
   1688	    0000			 DemoLDTSeg	 SEGMENT PARA USE16
   1689
   1690	    0000			 DemoLDT	 LABEL	 BYTE
   1691	    0000  01FF 0080s 00	92 40 +	 DemoStack0		 Desc	 <DemoStack0Len-1,DemoStack0Seg+RELOCATE1,,ATDW+DPL0,D32,>
   1692		  00
   1693	    0008  01F5 0080s 00	B2 40 +	 DemoStack1		 Desc	 <DemoStack1Len-1,DemoStack1Seg+RELOCATE1,,ATDW+DPL1,D32,>
   1694		  00
   1695	    0010  01FF 0080s 00	F2 00 +	 DemoStack3		 Desc	 <DemoStack3Len-1,DemoStack3Seg+RELOCATE1,,ATDW+DPL3,,>
   1696		  00
   1697	    0018  0463r	0080s 00 F8 40+	 DemoCode		 Desc	 <DemoCodeLen-1,DemoCodeSeg+RELOCATE1,,ATCE+DPL3,D32,>
   1698		  00
   1699	    0020  0463r	0080s 00 98 40+	 T32Code		 Desc	 <DemoCodeLen-1,DemoCodeSeg+RELOCATE1,,ATCE,D32,>
   1700		  00
   1701	    0028  0463r	0080s 00 98 40+	 ProtCode		 Desc <DemoCodeLen-1,DemoCodeSeg+RELOCATE1,,ATCE,D32,>
   1702		  00
   1703	    0030  0017r	0080s 00 92 40+	 ProtModeProcData	 Desc <ProtModeProcDataLen-1,ProtModeProcDataSeg+RELOCATE1,,ATDW,   +
   1704		  00			 D32,0h>
   1705					 ; only	BaseL is shifted in InitLDT, so	enter the value	one digit less or left shifted by   +
   1706					 one digit
   1707					 ; for example 8400h offset should be enetered as 840h,	InitLDT	will shift and make it 8400h
   1708	    0038  FFFF 0000 00 92 CF  +	 PrintMemProcData	 Desc	 <0ffffh,0h,0h,ATDW,0cfh,0h>	      ;for loading fs
   1709		  00
   1710	    0040  FFFF 0000 10 92 CF  +	 StartAddress		 Desc	 <0ffffh,0h,10h,ATDW,0cfh,0h>	    ;above 1M descriptor
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 31
prcycle.ASM



   1711		  00
   1712	    0048  FFFF 0840 00 92 00  +	 Buffer			 Desc	 <0ffffh,840h,,ATDW,,>	     ;for loading es
   1713		  00
   1714
   1715					 ; You need to add RDataSeg and	RELOCATE1 here so that the base	value will be
   1716					 ; taken care off
   1717					 ; Do not use DS if you	want to	address	real memory data as DS is already
   1718					 ; being used for protected mode data using ASSUME
   1719					 ; Use es instead to solve this	problem
   1720	    0050  FFFF 0080s 00	92 00 +	 RealData		 Desc	 <0ffffh,RDataSeg+RELOCATE1,,ATDW,,>	   ;for	loading	fs
   1721		  00
   1722	    0058  FFFF 0000 00 98 40  +	 GotoPCode		 Desc	 <0ffffh,APPL1RELOCATE,,ATCE,D32,>
   1723		  00
   1724					 ;------------------------------------------------------------------------
   1725		  = 000C		 DemoLDNum	 =	 ($-DemoLDT)/(SIZE Desc)
   1726					 ;------------------------------------------------------------------------
   1727		  = 0004		 DemoStack0_Sel		 =	 DemoStack0-DemoLDT+TIL+RPL0
   1728		  = 000D		 DemoStack1_Sel		 =	 DemoStack1-DemoLDT+TIL+RPL1
   1729		  = 0017		 DemoStack3_Sel		 =	 DemoStack3-DemoLDT+TIL+RPL3
   1730		  = 001F		 DemoCode_Sel		 =	 DemoCode-DemoLDT+TIL+RPL3
   1731		  = 0024		 T32Code_Sel		 =	 T32Code-DemoLDT+TIL
   1732		  = 002C		 ProtCode_Sel		 =	 ProtCode-DemoLDT+TIL
   1733		  = 0034		 ProtModeProcData_Sel	 =	 ProtModeProcData-DemoLDT+TIL
   1734		  = 003C		 PrintMemProcData_Sel	 =	 PrintMemProcData-DemoLDT+TIL
   1735		  = 0054		 RealData_Sel		 =	 RealData-DemoLDT+TIL
   1736		  = 0044		 StartAddress_Sel	 =	 StartAddress-DemoLDT+TIL
   1737		  = 004C		 Buffer_Sel		 =	 Buffer-DemoLDT+TIL
   1738
   1739		  = 005C		 GotoPCode_Sel		 =	 GotoPCode-DemoLDT+TIL
   1740					 ;------------------------------------------------------------------------
   1741	    0060  0007r	0024 00	EC    +	 ToT32GateA		 Gate	 <T32Begin,T32Code_Sel,,AT386CGate+DPL3,>
   1742		  0000
   1743	    0068  002Ar	0024 00	EC    +	 ToT32GateB		 Gate	 <T32End,T32Code_Sel,,AT386CGate+DPL3,>
   1744		  0000
   1745	    0070  0031r	002C 00	EC    +	 ProtModeProcGate1	 Gate	 <PUTHEX32P,ProtCode_Sel,,AT386CGate+DPL3,>
   1746		  0000
   1747	    0078  008Cr	002C 00	EC    +	 App_Scheduler_Gate	 Gate	 <APPSCHEDULE,ProtCode_Sel,,AT386CGate+DPL3,>
   1748		  0000
   1749	    0080  0099r	002C 00	EC    +	 ProtModeProcGate2	 Gate	 <PRINTMEMP,ProtCode_Sel,,AT386CGate+DPL3,>
   1750		  0000
   1751	    0088  00CFr	002C 00	EC    +	 ProtModeProcGate3	 Gate	 <PRINTSTP, ProtCode_Sel,,AT386CGate+DPL3,>
   1752		  0000
   1753	    0090  012Ar	002C 00	EC    +	 RDWTMemGate		 Gate	 <RDWTMEM,  ProtCode_Sel,,AT386CGate+DPL3,>
   1754		  0000
   1755
   1756	    0098  0000 005C 00 EC 0000	 GotoPGate		 Gate	 <0h,GotoPCode_Sel,,AT386CGate+DPL3,>
   1757					 ;-----------------------------------------------------------------------
   1758		  = 00A0		 DemoLDTLen		 =	 $-DemoLDT
   1759					 ;------------------------------------------------------------------------
   1760		  = 0064		 ToT32A_Sel		 =	 ToT32GateA-DemoLDT+TIL
   1761		  = 006C		 ToT32B_Sel		 =	 ToT32GateB-DemoLDT+TIL
   1762		  = 0074		 Puthex32PGate_Sel	 =	 ProtModeProcGate1-DemoLDT+TIL
   1763		  = 007C		 App_Scheduler_Sel	 =	 App_Scheduler_Gate-DemoLDT+TIL
   1764		  = 0084		 PrintmemPGate_Sel	 =	 ProtModeProcGate2-DemoLDT+TIL
   1765		  = 008C		 PrintStackPGate_Sel	 =     ProtModeProcGate3-DemoLDT+TIL
   1766		  = 0094		 RDWTMemPGate_Sel	 =     RDWTMemGate-DemoLDT+TIL
   1767
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 32
prcycle.ASM



   1768		  = 009C		 GotoPGate_Sel	 =	 GotoPGate-DemoLDT+TIL
   1769					 ;----------------------------------------------------------------------------
   1770	    00A0			 DemoLDTSeg	 ENDS
   1771					 ;----------------------------------------------------------------------------
   1772
   1773					 ;***************************************************************************
   1774					 ; DemoTSSSeg Segment
   1775					 ; 16 bit segment
   1776					 ;***************************************************************************
   1777	    0000			 DemoTSSSeg	 SEGMENT PARA USE16
   1778	    0000  00000000				 DD	 0
   1779	    0004  00000200				 DD	 DemoStack0Len
   1780	    0008  00000004				 DD	 DemoStack0_Sel
   1781	    000C  000001F6				 DD	 DemoStack1Len
   1782	    0010  0000000D				 DD	 DemoStack1_Sel
   1783	    0014  00000000				 DD	 0
   1784	    0018  00000000				 DD	 0
   1785	    001C  00000000				 DD	 0			   ;CR3
   1786	    0020  00000000				 DD	 0			   ;EIP
   1787	    0024  00000000				 DD	 0			   ;EFLAGS
   1788	    0028  00000000				 DD	 0			   ;EAX
   1789	    002C  00000000				 DD	 0			   ;ECX
   1790	    0030  00000000				 DD	 0			   ;EDX
   1791	    0034  00000000				 DD	 0			   ;EBX
   1792	    0038  00000000				 DD	 0			   ;ESP
   1793	    003C  00000000				 DD	 0			   ;EBP
   1794	    0040  00000000				 DD	 0			   ;ESI
   1795	    0044  00000000				 DD	 0			   ;EDI
   1796	    0048  00000000				 DD	 0			   ;ES
   1797	    004C  00000000				 DD	 0			   ;CS
   1798	    0050  00000000				 DD	 0			   ;SS
   1799	    0054  00000000				 DD	 0			   ;DS
   1800	    0058  00000000				 DD	 0			   ;FS
   1801	    005C  00000000				 DD	 0			   ;GS
   1802	    0060  00000028				 DD	 DemoLDT_Sel		   ;LDT
   1803	    0064  0000					 DW	 0
   1804	    0066  0068r					 DW	 $+2
   1805	    0068  FFFF					 DW	 0ffffh
   1806					 ;----------------------------------------------------------------------------
   1807		  = DEMOTSSSEG:006A	 DemoTSSLen	 =	 $
   1808					 ;----------------------------------------------------------------------------
   1809	    006A			 DemoTSSSeg	 ENDS
   1810					 ;----------------------------------------------------------------------------
   1811
   1812					 ;***************************************************************************
   1813					 ; DemoStack0Seg Segment
   1814					 ;  32 bit segment
   1815					 ;***************************************************************************
   1816	00000000			 DemoStack0Seg	 SEGMENT DWORD STACK USE32
   1817		  = 0200		 DemoStack0Len	 =	 512
   1818	00000000  0200*(??)				 DB	 DemoStack0Len DUP(?)
   1819	00000200			 DemoStack0Seg	 ENDS
   1820					 ;--------------------------------------------------------------------------
   1821					 ;***************************************************************************
   1822					 ; DemoStack1Seg Segment
   1823					 ;  32 bit segment
   1824					 ;***************************************************************************
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 33
prcycle.ASM



   1825	00000000			 DemoStack1Seg	 SEGMENT DWORD STACK USE32
   1826		  = 01F6		 DemoStack1Len	 =	 502
   1827	00000000  54				 DB	 'T'
   1828	00000001  44				 DB	 'D'
   1829	00000002  4F				 DB	 'O'
   1830	00000003  53				 DB	 'S'
   1831	00000004  43				 DB	 'C'
   1832	00000005  32				 DB	 '2'
   1833	00000006  30				 DB	 '0'
   1834	00000007  30				 DB	 '0'
   1835	00000008  38				 DB	 '8'
   1836	00000009  54				 DB	 'T'
   1837	0000000A  01F6*(4B)				 DB	 DemoStack1Len DUP('K')
   1838	00000200			 DemoStack1Seg	 ENDS
   1839
   1840					 ;-------------------------------------------------------------------------
   1841					 ;***************************************************************************
   1842					 ; DemoStack3Seg Segment
   1843					 ;  16 bit segment
   1844					 ;***************************************************************************
   1845	    0000			 DemoStack3Seg	 SEGMENT PARA USE16
   1846		  = 0200		 DemoStack3Len	 =	 512
   1847	    0000  0200*(00)				 DB	 DemoStack3Len DUP(0)
   1848					 ;-------------------------------------------------------------------------
   1849	    0200			 DemoStack3Seg	 ENDS
   1850					 ;-------------------------------------------------------------------------
   1851					 ;***************************************************************************
   1852					 ; GetCharStackSeg Segment
   1853					 ;  16 bit segment
   1854					 ;***************************************************************************
   1855	    0000			 GetCharStackSeg   SEGMENT PARA	USE16
   1856		  = 0200		 GetCharStackLen   =	   512
   1857	    0000  0200*(00)				 DB	 GetCharStackLen DUP(0)
   1858					 ;-------------------------------------------------------------------------
   1859	    0200			 GetCharStackSeg   ENDS
   1860					 ;-------------------------------------------------------------------------
   1861					 ;***************************************************************************
   1862					 ; SearchStackSeg Segment
   1863					 ;  16 bit segment
   1864					 ;***************************************************************************
   1865	    0000			 SearchStackSeg	  SEGMENT PARA USE16
   1866		  = 0200		 SearchStackLen	  =	  512
   1867	    0000  0200*(00)				 DB	 SearchStackLen	DUP(0)
   1868					 ;-------------------------------------------------------------------------
   1869	    0200			 SearchStackSeg	  ENDS
   1870					 ;-------------------------------------------------------------------------
   1871					 ;***************************************************************************
   1872					 ;***************************************************************************
   1873					 ; GetDecStackSeg Segment
   1874					 ;  16 bit segment
   1875					 ;***************************************************************************
   1876	    0000			 GetDecStackSeg	  SEGMENT PARA USE16
   1877		  = 0200		 GetDecStackLen	  =	  512
   1878	    0000  0200*(00)				 DB	 GetDecStackLen	DUP(0)
   1879					 ;-------------------------------------------------------------------------
   1880	    0200			 GetDecStackSeg	  ENDS
   1881					 ;***************************************************************************
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 34
prcycle.ASM



   1882					 ; GetSecStackSeg Segment
   1883					 ;  16 bit segment
   1884					 ;***************************************************************************
   1885	    0000			 GetSecStackSeg	  SEGMENT PARA USE16
   1886		  = 0200		 GetSecStackLen	  =	  512
   1887	    0000  0200*(00)				 DB	 GetSecStackLen	DUP(0)
   1888					 ;-------------------------------------------------------------------------
   1889	    0200			 GetSecStackSeg	  ENDS
   1890					 ;***************************************************************************
   1891					 ; WriteSecStackSeg Segment
   1892					 ;  16 bit segment
   1893					 ;***************************************************************************
   1894	    0000			 WriteSecStackSeg   SEGMENT PARA USE16
   1895		  = 0200		 WriteSecStackLen   =	    512
   1896	    0000  0200*(00)				 DB	 WriteSecStackLen DUP(0)
   1897					 ;-------------------------------------------------------------------------
   1898	    0200			 WriteSecStackSeg   ENDS
   1899					 ;-------------------------------------------------------------------------
   1900					 ;***************************************************************************
   1901					 ; App1StackSeg	Segment
   1902					 ;  32 bit segment
   1903					 ;***************************************************************************
   1904	00000000			 App1StackSeg	SEGMENT	DWORD STACK USE32
   1905		  = 0200		 App1StackLen	=	512
   1906	00000000  0200*(??)				 DB	 App1StackLen DUP(?)
   1907	00000200			 App1StackSeg	ENDS
   1908					 ;-------------------------------------------------------------------------
   1909					 ;***************************************************************************
   1910					 ; ProtModeProcDataSeg Segment
   1911					 ; All the protected mode data will go into this segment.
   1912					 ;  32 bit segment
   1913					 ;***************************************************************************
   1914	00000000			 ProtModeProcDataSeg	    SEGMENT public PARA	USE32
   1915
   1916	00000000  30 31	32 33 34 35 36+	 HexTableP	  DB	  '0123456789ABCDEF'
   1917		  37 38	39 41 42 43 44+
   1918		  45 46
   1919	00000010  ????????		 IndexCntP	  DD	  ?
   1920	00000014  ????????		 PrintDataP	  DD	  ?
   1921
   1922		  =		      +	 ProtModeProcDataLen	 =	 $
   1923		  PROTMODEPROCDATASEG:0
   1924		  018
   1925
   1926	00000018			 ProtModeProcDataSeg	    ENDS
   1927					 ;--------------------------------------------------------------------------
   1928					 ;***************************************************************************
   1929					 ; GlobalDataSeg Segment
   1930					 ; All the Global data will be stored in this segment.
   1931					 ;  32 bit segment
   1932					 ;***************************************************************************
   1933	    0000			 GlobalDataSeg	      SEGMENT public PARA USE16	'GlobalData'
   1934
   1935	    0000  50 51	52 53 54 55 56+	 Dummydata	 DB	 'PQRSTUVWXYZ'
   1936		  57 58	59 5A
   1937
   1938	    000B  ??			 StoreChar		 DB	 ?
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 35
prcycle.ASM



   1939	    000C  ????????		 StoreDec		 DD	 ?
   1940	    0010  0100*(00)		 SearchKey		 DB	 256 dup(0)
   1941	    0110  0000			 SearchLen		 dw	 0
   1942
   1943		  = GLOBALDATASEG:0112	 GlobalDataLen	   =	   $
   1944
   1945	    0112			 GlobalDataSeg	      ENDS
   1946
   1947					 ;**************************************************************************
   1948					 ;sample test code for otherbegin code to place	it in C++
   1949					 ;  this code never gets invoked as it will be over ridden by IDT and GDT entries
   1950					 ;**************************************************************************
   1951	00000000			 IntExceptionSeg    SEGMENT PARA USE32
   1952	00000000			 IntException		 PROC FAR
   1953
   1954	00000000  CF					 iretd
   1955	00000001			 IntException ENDP
   1956		  =		      +	 IntExceptionCodeLen	 =  $
   1957		  INTEXCEPTIONSEG:0001
   1958					 ;----------------------------------------------------------------------------
   1959	00000001			 IntExceptionSeg ENDS
   1960
   1961					 ;**************************************************************************
   1962					 ;Sample Test Code Segment
   1963					 ; When	C++ application	ethernet receive ISR is	not setup, this	ISR will
   1964					 ;  run
   1965					 ;--------------------------------------------------------------------------
   1966	00000000			 EthernetReceive    SEGMENT PARA USE32
   1967							 ;ASSUME  CS:EthernetReceive;,ds:ProtModeProcDataSeg;
   1968	00000000			 test2 PROC FAR
   1969	00000000  FA					 cli
   1970	00000001  50					 push	 eax
   1971	00000002  53					 push	 ebx
   1972	00000003  52					 push	 edx
   1973	00000004  0F A0					 push	 fs
   1974
   1975	00000006  66| B8 00C0				 mov	 ax, MEMData_Sel ; zero	base in	protected mode
   1976	0000000A  8E E0					 mov	 fs, ax
   1977	0000000C  BB 00008600				 mov	 ebx,S_Base	 ;base of shared memory	between	aoa and	application
   1978	00000011  83 C3	00				 add	 ebx,S_Timer		 ;index	of timer in shared memory
   1979	00000014  64: 8B 03				 mov	 eax, fs:[ebx]
   1980	00000017  64: 89 03				 mov	 fs:[ebx], eax
   1981	0000001A  BB 00000294				 mov	 ebx, 660
   1982	0000001F  CD FD					 int	 0fdh
   1983
   1984	00000021  66| B8 0049				 mov	 ax, 'I'
   1985	00000025  BB 00000280				 mov	 ebx, 640
   1986	0000002A  CD F7					 int	 0f7h
   1987
   1988							 ;-----------------------------------------
   1989							 ;print	the status of ethernet card
   1990	0000002C  66| B8 0300				 mov	 ax, 300h
   1991	00000030  66| 8B D0				 mov	 dx, ax
   1992	00000033  66| 83 C2 0E				 add	 dx, 0Eh
   1993	00000037  66| ED				 in	 ax, dx
   1994	00000039  BB 00000320				 mov	 ebx, 800
   1995	0000003E  CD FD					 int	 0fdh
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 36
prcycle.ASM



   1996							 ;-----------------------------------
   1997							 ; discard the packet in the ethernet buffer
   1998
   1999	00000040  33 D2					 xor	 edx, edx
   2000	00000042  33 C0					 xor	 eax, eax
   2001	00000044  66| B8 0300				 mov	 ax, 300h
   2002	00000048  66| 8B D0				 mov	 dx, ax	; dx:IO_BASE
   2003	0000004B  66| 83 C2 0E				 add	 dx, 0Eh
   2004	0000004F  66| B8 0801				 mov	 ax, 800h+1h
   2005	00000053  66| EF				 out	 dx, ax
   2006	00000055			 Wait_Command_End2:
   2007	00000055  66| ED				 in	 ax, dx
   2008	00000057  66| 25 1000				 and	 ax, 1000h
   2009							 ;jnz	  Wait_Command_End2
   2010							 ;print	the status of ethernet card
   2011
   2012	0000005B  66| B8 0300				 mov	 ax, 300h
   2013	0000005F  66| 8B D0				 mov	 dx, ax
   2014	00000062  66| 83 C2 0E				 add	 dx, 0Eh
   2015	00000066  66| ED				 in	 ax, dx
   2016	00000068  BB 00000334				 mov	 ebx, 820
   2017	0000006D  CD FD					 int	 0fdh
   2018
   2019							 ;Discard Data header.
   2020	0000006F  66| B8 4000				 mov	 ax, 4000h
   2021	00000073  66| EF				 out	 dx, ax
   2022	00000075			 Wait_Command_End1:
   2023	00000075  66| ED				 in	 ax, dx
   2024	00000077  66| 25 1000				 and	 ax, 1000h
   2025							 ;jnz	  Wait_Command_End1
   2026
   2027							 ;print	the status of ethernet card
   2028	0000007B  66| B8 0300				 mov	 ax, 300h
   2029	0000007F  66| 8B D0				 mov	 dx, ax
   2030	00000082  66| 83 C2 0E				 add	 dx, 0Eh
   2031	00000086  66| ED				 in	 ax, dx
   2032	00000088  BB 00000348				 mov	 ebx, 840
   2033	0000008D  CD FD					 int	 0fdh
   2034	0000008F  66| B8 004A				 mov	 ax, 'J'
   2035	00000093  BB 00000280				 mov	 ebx, 640
   2036	00000098  CD F7					 int	 0f7h
   2037							 ;-----------------------------------
   2038							 ; Acknowledge the interrupt with the ethernet card
   2039	0000009A  66| BA 0300				 mov	 dx, 300h
   2040	0000009E  66| 83 C2 0E				 add	 dx, 0eh
   2041	000000A2  66| B8 6811				 mov	 ax, 6811h
   2042	000000A6  66| EF				 out	 dx, ax
   2043	000000A8			 Wait_Command_End:
   2044	000000A8  66| ED				 in	 ax, dx
   2045	000000AA  66| 25 1000				 and	 ax, 1000h
   2046							 ;jnz	  Wait_Command_End
   2047	000000AE  66| ED				 in	 ax, dx
   2048	000000B0  BB 0000035C				 mov	 ebx, 860
   2049	000000B5  CD FD					 int	 0fdh
   2050
   2051	000000B7  66| B8 004B				 mov	 ax, 'K'
   2052	000000BB  BB 00000280				 mov	 ebx, 640
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 37
prcycle.ASM



   2053	000000C0  CD F7					 int	 0f7h
   2054							 ;-----------------------------------------------------
   2055							 ; Acknowledge the interrupt in	the PCI	2
   2056	000000C2  66| BA 00A0				 mov	 dx, 0A0h
   2057	000000C6  B0 20					 mov	 al, 20h
   2058	000000C8  EE					 out	 dx, al
   2059							 ;--------------------------------------------------------
   2060							 ; Acknowledge the interrupt in	the PCI	1
   2061							 ; this	is because the interupt	int PCI	2 is through PCI 1
   2062	000000C9  66| BA 0020				 mov	 dx, 20h
   2063	000000CD  B0 20					 mov	 al, 20h
   2064	000000CF  EE					 out	 dx, al
   2065							 ;--------------------------------------------------------
   2066							 ; Disable the Ethernet	Card Interrupt
   2067							 ;mov	 dx, 0A1h
   2068							 ;in	 al, dx
   2069							 ;or	 al, 80h
   2070							 ;out	 dx, al
   2071
   2072							 ;--------------------------------------------------------
   2073							 ; Disable the Ethernet	Card Interrupt
   2074							 ;mov	 dx, 0A1h
   2075							 ;in	 al, dx
   2076							 ;and	 al, 7Fh
   2077							 ;out	 dx, al
   2078
   2079	000000D0  66| B8 004C				 mov	 ax, 'L'
   2080	000000D4  BB 00000280				 mov	 ebx, 640
   2081	000000D9  CD F7					 int	 0f7h
   2082
   2083	000000DB  0F A1					 pop	 fs
   2084	000000DD  5A					 pop	 edx
   2085	000000DE  5B					 pop	 ebx
   2086	000000DF  58					 pop	 eax
   2087	000000E0  FB					 sti
   2088	000000E1  CF					 iretd
   2089	000000E2			 test2 ENDP
   2090
   2091		  =		      +	 EthernetReceiveCodeLen	    =  $
   2092		  ETHERNETRECEIVE:00E2
   2093					 ;----------------------------------------------------------------------------
   2094	000000E2			 EthernetReceive ENDS
   2095
   2096					 ;**************************************************************************
   2097					 ;DemoCodeSeg Segment
   2098					 ;  32 bit segment
   2099					 ;  In ProtectedMode all the segments are 32bit
   2100					 ;**************************************************************************
   2101	00000000			 DemoCodeSeg	 SEGMENT PARA USE32
   2102							 ASSUME	 CS:DemoCodeSeg,ds:ProtModeProcDataSeg;, es:RDataSeg
   2103					 ;-------------------------------------------------------------------------
   2104					 ; Do not use 16 bit ds	in democodeseg
   2105					 ;***************************************************************************
   2106					 ; DemoBegin Procedure
   2107					 ;  invoked from T32Begin using	a call gate
   2108					 ;  III.
   2109					 ;***************************************************************************
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 38
prcycle.ASM



   2110	00000000			 DemoBegin	 PROC	 FAR
   2111
   2112							 CALL32	 ToT32B_Sel,0  ; IV.
1  2113	00000000  9A					 DB	 9ah
1  2114	00000001  0000					 DW	 0
1  2115	00000003  0000					 DW	 0
1  2116	00000005  006C					 DW	 ToT32B_Sel
   2117							 ; using a call	gate it	will go	to T32End
   2118							 ; 32 bit to 32	bit gate and call
   2119	00000007			 DemoBegin	 ENDP
   2120					 ;-------------------------------------------------------------------------
   2121					 ;***************************************************************************
   2122					 ; T32Begin Procedure
   2123					 ;  called from	a call gate 16 bit to 32 bit segment transfer
   2124					 ;***************************************************************************
   2125	00000007			 T32Begin	 PROC	 FAR
   2126					 ;-----------------------------------------
   2127	00000007  B0 50					 mov	 al,'P'
   2128	00000009  BB 00000F9E				 mov	 ebx,3998
   2129	0000000E  CD F7					 int	 0f7h
   2130
   2131
   2132					 ;------------------------------------------------
   2133	00000010			 Skip:
   2134					 ;-----------------------------------------
   2135	00000010  66| B8 0004				 mov	 ax,DemoStack0_Sel
   2136	00000014  8E D0					 mov	 ss,ax
   2137	00000016  BC 00000200				 mov	 esp,DemoStack0Len
   2138	0000001B  6A 17					 push	 DWORD PTR DemoStack3_Sel
   2139	0000001D  68 00000200				 push	 DemoStack3Len
   2140	00000022  6A 1F					 push	 DWORD PTR DemoCode_Sel
   2141	00000024  68 00000000r				 push	 OFFSET	DemoBegin
   2142					 ;-------------------------------------------
   2143					 ; III.
   2144					 ; 32 bit to 32	bit transfer using stack
   2145					 ; destination address selector	and offset is
   2146					 ; pushed onto stack and using return it will
   2147					 ; pop the stack to jump to DemoBegin location
   2148					 ;-------------------------------------------
   2149	00000029  CB					 retf
   2150	0000002A			 T32Begin	 ENDP
   2151					 ;--------------------------------------------------------------------------
   2152					 ;***************************************************************************
   2153					 ; T32End Procedure
   2154					 ; IV.
   2155					 ;  invoked from DemoBegin using a call	gate
   2156					 ;***************************************************************************
   2157	0000002A			 T32End		 PROC	 FAR
   2158					 ;--------------------------------------------------------
   2159							 JUMP32	 TempCode_Sel,<OFFSET ToReal> ;	V.
1  2160	0000002A  EA					 DB	 0eah
1  2161	0000002B  01FCr					 DW	 OFFSET	ToReal
1  2162	0000002D  0000					 DW	 0
1  2163	0000002F  0030					 DW	 TempCode_Sel
   2164					 ;--------------------------------------------------------
   2165							 ; using a descriptor now it will go back
   2166							 ; to 16 bit protected mode label ToReal
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 39
prcycle.ASM



   2167							 ; and it is on	its way	to real	mode
   2168							 ; this	will be	a 32 bit segment to 16 bit
   2169							 ; segment transfer using a descriptor
   2170	00000031			 T32End		 ENDP
   2171					 ;***************************************************************************
   2172					 ; PUTHEX32P Procedure
   2173					 ;***************************************************************************
   2174					 ;This procedure prints	the value in EAX in hex-format in PMode.
   2175					 ;Usage	in PMode: load eax with	a value, load ebx with the position of the screen
   2176					 ;and call this	procedure 'CALL32  ProtModeProcGate1_Sel,0'
   2177					 ; This	procedure automatically	increments ebx value to	the next location
   2178					 ;---------------------------------------------------------------------------
   2179	00000031			 PUTHEX32P	 PROC	 FAR
   2180	00000031  51				 PUSH	 ECX
   2181	00000032  57				 PUSH	 EDI
   2182	00000033  1E				 PUSH	 DS
   2183	00000034  50				 push	 eax
   2184
   2185	00000035  53				 push	 ebx
   2186	00000036  50				 push	 eax
   2187
   2188	00000037  66| B8 0090			 mov	 ax,Puthex32Data_Sel
   2189	0000003B  8E D8				 mov	 ds,ax
   2190
   2191	0000003D  58				 pop	 eax
   2192	0000003E  5B				 pop	 ebx
   2193
   2194	0000003F  A3 00000014r			 MOV	 PrintDataP, eax	 ; save	data in	memory
   2195	00000044  B9 00000008			 MOV	 ecx, 8			 ; eight characters
   2196	00000049			 PutHexLoopP:
   2197	00000049  A1 00000014r			 MOV	 eax, PrintDataP	 ; data	in eax
   2198	0000004E  25 F0000000			 AND	 eax, 0F0000000h	 ; select first	nibble
   2199	00000053  C1 C0	04			 ROL	 eax,4			 ; get the count on right
   2200	00000056  A3 00000010r			 MOV	 IndexCntP, eax		 ; store the index
   2201	0000005B  8B 3D	00000010r		 MOV	 edi, IndexCntP
   2202	00000061  8A 87	00000000r		 MOV	 al, BYTE PTR HexTableP[edi]  ;	get hex	character
   2203
   2204	00000067  83 C3	02			 add	 ebx,2			 ; Next	character
   2205	0000006A  CD F7				 int	 0f7h
   2206
   2207	0000006C  A1 00000014r			 MOV	 eax, PrintDataP	 ; get the stored data
   2208	00000071  C1 E0	04			 SHL	 eax, 4			 ; shift to next nibble
   2209	00000074  A3 00000014r			 MOV	 PrintDataP, eax	 ; store remaining data
   2210	00000079  E2 CE				 LOOP	 PutHexLoopP		 ; print all 8 hex characters
   2211
   2212	0000007B  58				 pop	 eax
   2213	0000007C  1F				 POP	 DS
   2214	0000007D  5F				 POP	 EDI
   2215	0000007E  59				 POP	 ECX
   2216					 ;---------------------------------------------------------------------------------
   2217					 ;changed this code on 7-7-2004
   2218	0000007F  52				 push	 edx
   2219	00000080  9C				 pushfd	; turn off NT flag in the CPU not in the TSS
   2220						 ; so that CPU will return to its application during IRETD not to
   2221						 ;  exit from the task using link field	in the TSS
   2222	00000081  5A				 pop	 edx
   2223	00000082  81 E2	FFFFBFFF		 AND	 edx, 0FFFFBFFFh
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 40
prcycle.ASM



   2224	00000088  52				 push	 edx
   2225	00000089  9D				 popfd
   2226	0000008A  5A				 pop	 edx
   2227					 ;--------------------------------------------------------------------------------
   2228	0000008B  CF				 IRETD
   2229	0000008C			 PUTHEX32P	 ENDP
   2230					 ;***************************************************************************
   2231					 ; TEST	Procedure
   2232					 ;***************************************************************************
   2233					 ;This procedure prints	the value in EAX in hex-format in PMode.
   2234					 ;Usage	in PMode: load eax with	a value, load ebx with the position of the screen
   2235					 ;and call this	procedure 'CALL32  ProtModeProcGate1_Sel,0'
   2236					 ;---------------------------------------------------------------------------
   2237	0000008C			 APPSCHEDULE	 PROC	 FAR
   2238	0000008C  50				 push	 eax
   2239	0000008D  53				 push	 ebx
   2240	0000008E  B0 41				 mov	 al,'A'
   2241	00000090  BB 000005DC			 mov	 ebx,1500
   2242	00000095  CD F7				 int	 0f7h
   2243	00000097  5B				 pop	 ebx
   2244	00000098  58				 pop	 eax
   2245
   2246	00000099			 APPSCHEDULE	 ENDP
   2247
   2248					 ;***************************************************************************
   2249					 ;This Procedure prints	the memory in hex-format in Protected mode
   2250					 ;place	the memory location in EAX and position	to display in EBX and call.
   2251					 ;***************************************************************************
   2252	00000099			 PRINTMEMP	 PROC	 FAR
   2253
   2254	00000099  51				 PUSH	 ECX
   2255	0000009A  56				 PUSH	 ESI
   2256	0000009B  57				 PUSH	 EDI
   2257	0000009C  1E				 PUSH	 DS
   2258	0000009D  0F A0				 push	 fs
   2259
   2260	0000009F  50				 push	 eax
   2261	000000A0  66| B8 0034			 mov	 ax,ProtModeProcData_Sel
   2262	000000A4  8E D8				 mov	 ds,ax
   2263	000000A6  58				 pop	 eax
   2264
   2265	000000A7  50				 push	 eax
   2266	000000A8  66| B8 003C			 mov	 ax,PrintMemProcData_Sel
   2267	000000AC  8E E0				 mov	 fs,ax
   2268	000000AE  58				 pop	 eax
   2269
   2270	000000AF  BB 00000320			 mov	 ebx,800		  ; use	CursorPos = 2 or 800 to	start
   2271	000000B4  8B F8				 mov	 edi,eax		  ;
   2272	000000B6  B9 00000080			 mov	 ecx,128
   2273
   2274	000000BB				 memloop:
   2275	000000BB  64: 8B 07			 mov	 eax,fs:[edi]
   2276	000000BE  CD FD				 int	 0fdh
   2277
   2278	000000C0  83 C3	04			 add	 ebx,4
   2279	000000C3  83 C7	04			 add	 edi,4
   2280	000000C6  E2 F3				 loop	 memloop
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 41
prcycle.ASM



   2281
   2282	000000C8  0F A1				 pop	 fs
   2283	000000CA  1F				 POP	 DS
   2284	000000CB  5F				 POP	 EDI
   2285	000000CC  5E				 POP	 ESI
   2286	000000CD  59				 POP	 ECX
   2287	000000CE  CB				 RETF
   2288
   2289	000000CF			 PRINTMEMP	 ENDP
   2290					 ;***************************************************************************
   2291					 ; Print Stack Procedure
   2292					 ;  When printing stack, make sure you do not exceed the limit of the stack
   2293					 ;  ex.	when you print DemoStack0 then the limit is DemoStack0Len
   2294					 ; eax must have number	of bytes to print
   2295					 ; ebx must have the starting point of display to print
   2296					 ; esp is used as current stack	pointer
   2297					 ; ss  is used as current stack	segment
   2298					 ; the printing	is done	from current esp to the	top of the stack
   2299					 ; user	must make sure that you	are not	exceeding the limits of	the stack
   2300					 ;-------------------------------
   2301					 ;    |		  |
   2302					 ;    |-----------|  SS	 Limit
   2303					 ;    |	contents  |
   2304					 ;    |		  |
   2305					 ;    |		  |
   2306					 ;    |-----------| <--- ESP
   2307					 ;    |	EMPTY	  |
   2308					 ;    |		  |
   2309					 ;    ------------- 0
   2310					 ;    Stack Growing Downward
   2311					 ; -----------------------------
   2312					 ;   push ebp  do not disturb ebp in a call
   2313					 ;   mov ebp, esp
   2314					 ;   you must not disturb ESP in a call
   2315					 ;     if you are using	the stack
   2316					 ;   you must save and restore ESP in a	call
   2317					 ;   pop ebp   resore ebp when you return
   2318					 ;------------------------------
   2319					 ;***************************************************************************
   2320	000000CF			 PRINTSTP PROC FAR
   2321
   2322	000000CF  55				 push	 ebp	    ; save bp
   2323	000000D0  8B EC				 mov	 ebp,esp
   2324
   2325	000000D2  56				 push	 esi
   2326	000000D3  51				 push	 ecx
   2327	000000D4  57				 push	 edi
   2328	000000D5  52				 push	 edx
   2329					 ;-----------------------------------------------------------
   2330					 ; set DS for accessing	protected mode data for	PUTHEX32P rtn
   2331					 ;-----------------------------------------------------------
   2332	000000D6  1E				 push	 ds
   2333
   2334	000000D7  50				 push	 eax	  ; save eax on	stack
   2335	000000D8  66| B8 0034			 mov	 ax,ProtModeProcData_Sel
   2336	000000DC  8E D8				 mov	 ds,ax
   2337	000000DE  58				 pop	 eax	  ; restore eax	value passed
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 42
prcycle.ASM



   2338					 ; starting point of printing on display at ebx
   2339	000000DF  8B F8				 mov	 edi,eax  ; no of stack	entries	or bytes to print
   2340	000000E1  BA 00000010			 mov	 edx, 16  ; next line counter
   2341
   2342	000000E6  BE 00000000			 mov	 esi, 0	  ; starting point of print
   2343	000000EB			 LOOPSTACK1:
   2344	000000EB  8B 44	35 00			 mov	 eax,ss:[ebp+esi]
   2345
   2346	000000EF  50				 push	 eax
   2347	000000F0  53				 push	 ebx
   2348	000000F1  B8 00000000			 mov	 eax,0
   2349	000000F6  0F 00	C8			 str	 ax
   2350	000000F9  BB 00000460			 mov	 ebx,1120
   2351	000000FE  CD FD				 int	 0fdh
   2352	00000100  5B				 pop	 ebx
   2353	00000101  58				 pop	 eax
   2354
   2355						 CALL32	 Puthex32PGate_Sel, 0
1  2356	00000102  9A					 DB	 9ah
1  2357	00000103  0000					 DW	 0
1  2358	00000105  0000					 DW	 0
1  2359	00000107  0074					 DW	 Puthex32PGate_Sel
   2360
   2361	00000109  83 C3	02			 add	 ebx, 2
   2362
   2363	0000010C  83 EA	02			 sub	 edx, 2	 ; line	counter
   2364	0000010F  83 FA	00			 cmp	 edx, 0	 ; ready to go to next line
   2365	00000112  75 08				 JNZ	 NONEWLINEP
   2366	00000114  83 C3	10			 add	 ebx, 16 ; next	line pointer
   2367	00000117  BA 00000010			 mov	 edx, 16
   2368	0000011C			     NONEWLINEP:
   2369	0000011C  83 C6	04			 add	 esi,4
   2370	0000011F  3B FE				 cmp	 edi,esi
   2371	00000121  75 C8				 JNZ	 LOOPSTACK1
   2372
   2373	00000123  1F				 pop	 ds
   2374	00000124  5A				 pop	 edx
   2375	00000125  5F				 pop	 edi
   2376	00000126  59				 pop	 ecx
   2377	00000127  5E				 pop	 esi
   2378	00000128  5D				 pop	 ebp	     ; restore reg values
   2379
   2380	00000129  CB				 RETF
   2381
   2382	0000012A			 PRINTSTP ENDP		     ; end of procedure
   2383					 ;***************************************************************************
   2384					 ; This	proc copies the	data from 0000:[8400] to above 1 meg memmory
   2385					 ; staring from	the address given in the descriptor StartAddress_Sel
   2386					 ; and gets the	offset from BxPointer1.
   2387					 ; Dont	use ds to get the BxPointer1 as	BxPointer1 is in 16 bit	Dataseg
   2388					 ; because the default dataseg for this	code segment is	a 32 bit dataseg
   2389					 ; because of the ASSUME directive
   2390					 ; when	user input the offset value for	the program to be loaded
   2391					 ;  it is stored in LoadOffset1	and then it is transferred to BxPointer1
   2392					 ; then	BxPointer1 is used to store each sector	in the memory
   2393					 ; LoadOffset1 contains	the 32 bit offset entered by the user for app1
   2394					 ;***************************************************************************
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 43
prcycle.ASM



   2395
   2396	0000012A			 RDWTMEM	 PROC	 FAR
   2397
   2398	0000012A  66| B8 0054				 mov	 ax,RealData_Sel
   2399	0000012E  8E E8					 mov	 gs,ax		 ;real data segment
   2400
   2401							 ; offset is stored at BxPointer1 in memory prload.asm
   2402	00000130  65: 67| A1 0000e			 mov	 eax,gs:[BxPointer1]
   2403	00000135  BB 00000F76				 mov	 ebx,3958	 ; print offset	at the bottom of screen
   2404	0000013A  CD FD					 int	 0fdh		 ;   puthex32 gate to print
   2405
   2406							 ;int 0f5h		 ; wait	for the	keyboard
   2407							 ; real	mode interrupts	do not work here
   2408
   2409	0000013C  66| B8 0044				 mov	 ax,StartAddress_Sel
   2410	00000140  8E E0					 mov	 fs,ax		 ; start addr above 1M
   2411
   2412	00000142  66| B8 004C				 mov	 ax,Buffer_Sel	 ; 8400	buffer location	select
   2413	00000146  8E C0					 mov	 es,ax
   2414
   2415	00000148  BE 00000000				 mov	 esi,0h		 ; pointer for buffer
   2416	0000014D  65: 67| 8B 3E	0000e			 mov	 edi,gs:[BxPointer1]
   2417	00000153  B9 00000080				 mov	 ecx,128	 ;one sector
   2418							 ; copy	all words in the sector	to above 1M
   2419	00000158			 ReadWrite1:
   2420	00000158  26: 8B 06				 mov	 eax,es:[esi]
   2421	0000015B  64: 89 07				 mov	 fs:[edi],eax
   2422
   2423	0000015E  83 C6	04				 add	 esi,4
   2424	00000161  83 C7	04				 add	 edi,4
   2425
   2426	00000164  E2 F2					 LOOP	 ReadWrite1
   2427
   2428	00000166  CB					 RETF
   2429
   2430	00000167			 RDWTMEM	 ENDP
   2431					 ;----------------------------------------------------------------------------
   2432					 ;***************************************************************************
   2433					 ;HTimerBegin Procedure
   2434					 ; Now it will just display it.
   2435					 ; Whenever a hardware timer 08h arrives, this procedure will be called	thu
   2436					 ;  the	interrupt gate
   2437					 ; we start our	timer value with 0 and increment the value in memory each
   2438					 ; time	the interrupt comes, i.e. every	55 milli seconds
   2439					 ;***************************************************************************
   2440	00000167			 HTimerBegin PROC FAR
   2441	00000167  FA					 cli
   2442	00000168  50					 push	 eax
   2443	00000169  53					 push	 ebx
   2444	0000016A  52					 push	 edx
   2445	0000016B  0F A0					 push	 fs
   2446
   2447	0000016D  B8 00000054				 mov	 eax, 'T'
   2448	00000172  BB 00000F9C				 mov	 ebx, 3996
   2449	00000177  CD F7					 int	 0f7h
   2450
   2451	00000179  66| B8 00C0				 mov	 ax, MEMData_Sel ; zero	base in	protected mode
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 44
prcycle.ASM



   2452	0000017D  8E E0					 mov	 fs, ax
   2453	0000017F  BB 00008600				 mov	 ebx,S_Base	 ;base of shared memory	between	aoa and	application
   2454	00000184  83 C3	00				 add	 ebx,S_Timer		 ;index	of timer in shared memory
   2455
   2456	00000187  64: 8B 03				 mov	 eax, fs:[ebx]
   2457	0000018A  40					 inc	 eax
   2458	0000018B  64: 89 03				 mov	 fs:[ebx], eax
   2459
   2460	0000018E  66| BA 0020				 mov	 dx, 20h
   2461	00000192  B0 20					 mov	 al, 20h
   2462	00000194  EE					 out	 dx, al
   2463	00000195  EB 00					 jmp	 $+2
   2464
   2465							 ;mov	 ax, 'H'
   2466							 ;mov	 ebx, 3990
   2467							 ;int	 0f7h
   2468
   2469	00000197  0F A1					 pop	 fs
   2470	00000199  5A					 pop	 edx
   2471	0000019A  5B					 pop	 ebx
   2472	0000019B  58					 pop	 eax
   2473							 ;-----------------------------------------------------------------
   2474							 ;changed this code on 7-7-2004
   2475	0000019C  52					 push	 edx  ;save edx	on the stack
   2476	0000019D  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2477							 ; so that CPU will return to its application during IRETD not to
   2478							 ;  exit from the task using link field	in the TSS
   2479	0000019E  5A					 pop	 edx ; get the flags into edx
   2480	0000019F  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh ; reset NT flag
   2481	000001A5  52					 push	 edx		 ; store in the	stack
   2482	000001A6  9D					 popfd			 ; get the flags into flag register
   2483	000001A7  5A					 pop	 edx ; restore edx
   2484							 ;-----------------------------------------------------------------
   2485	000001A8  FB					 sti
   2486
   2487	000001A9  CF					 iretd
   2488	000001AA			 HTimerBegin ENDP
   2489
   2490
   2491	000001AA			 test1 PROC FAR
   2492	000001AA  FA					 cli
   2493	000001AB  50					 push	 eax
   2494	000001AC  53					 push	 ebx
   2495	000001AD  52					 push	 edx
   2496	000001AE  0F A0					 push	 fs
   2497
   2498							 ;mov	 eax, 'T'
   2499							 ;mov	 ebx, 800
   2500							 ;int	 0f7h
   2501
   2502	000001B0  66| B8 00C0				 mov	 ax, MEMData_Sel ; zero	base in	protected mode
   2503	000001B4  8E E0					 mov	 fs, ax
   2504	000001B6  BB 00008600				 mov	 ebx,S_Base	 ;base of shared memory	between	aoa and	application
   2505	000001BB  83 C3	00				 add	 ebx,S_Timer		 ;index	of timer in shared memory
   2506
   2507	000001BE  64: 8B 03				 mov	 eax, fs:[ebx]
   2508							 ;inc	 eax
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 45
prcycle.ASM



   2509	000001C1  64: 89 03				 mov	 fs:[ebx], eax
   2510
   2511	000001C4  BB 00000294				 mov	 ebx, 660
   2512	000001C9  CD FD					 int	 0fdh
   2513
   2514	000001CB  66| BA 0020				 mov	 dx, 20h
   2515	000001CF  B0 20					 mov	 al, 20h
   2516	000001D1  EE					 out	 dx, al	 ; read	timer interrupt
   2517	000001D2  EB 00					 jmp	 $+2
   2518
   2519	000001D4  66| B8 0049				 mov	 ax, 'I'
   2520	000001D8  BB 00000280				 mov	 ebx, 640
   2521	000001DD  CD F7					 int	 0f7h
   2522
   2523	000001DF  0F A1					 pop	 fs
   2524	000001E1  5A					 pop	 edx
   2525	000001E2  5B					 pop	 ebx
   2526	000001E3  58					 pop	 eax
   2527	000001E4  FB					 sti
   2528	000001E5  CF					 iretd
   2529	000001E6			 test1 ENDP
   2530
   2531
   2532
   2533
   2534
   2535					 ;-----------------------------------------------------------------
   2536					 ; get the current cursor postion
   2537					 ; return it in	ax
   2538	000001E6			 GetCursor	 proc far
   2539	000001E6  52					 push	 edx
   2540	000001E7  53					 push	 ebx
   2541
   2542	000001E8  33 C0					 xor	 eax, eax
   2543	000001EA  66| BA 03D4				 mov	 dx, 3d4h
   2544	000001EE  B0 0F					 mov	 al, 0fh
   2545	000001F0  EE					 out	 dx, al
   2546	000001F1  66| BA 03D5				 mov	 dx, 3d5h
   2547	000001F5  EC					 in	 al, dx
   2548	000001F6  8A D8					 mov	 bl, al
   2549
   2550	000001F8  66| BA 03D4				 mov	 dx, 3d4h
   2551	000001FC  B0 0E					 mov	 al, 0eh
   2552	000001FE  EE					 out	 dx, al
   2553	000001FF  66| BA 03D5				 mov	 dx, 3d5h
   2554	00000203  EC					 in	 al, dx
   2555	00000204  8A E0					 mov	 ah, al
   2556	00000206  8A C3					 mov	 al, bl
   2557
   2558	00000208  5B					 pop	 ebx
   2559	00000209  5A					 pop	 edx
   2560
   2561					 ;---------------------------------------------------------------------------------
   2562					 ;changed this code on 7-7-2004
   2563							 ;cli
   2564	0000020A  52					 push	 edx
   2565	0000020B  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 46
prcycle.ASM



   2566							 ; so that CPU will return to its application during IRETD not to
   2567							 ;  exit from the task using link field	in the TSS
   2568	0000020C  5A					 pop	 edx;
   2569	0000020D  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2570	00000213  52					 push	 edx
   2571	00000214  9D					 popfd
   2572	00000215  5A					 pop	 edx
   2573							 ;sti
   2574					 ;--------------------------------------------------------------------------------
   2575
   2576	00000216  CF					 iretd
   2577	00000217			 GetCursor	 endp
   2578
   2579					 ;--------------------------------------------------------------------------------
   2580					 ; set cursor postion
   2581					 ; ax hodes the	cursor value
   2582					 ;--------------------------------------------------------------------------------
   2583	00000217			 SetCursor	 proc far
   2584	00000217  50					 push	 eax
   2585	00000218  52					 push	 edx
   2586	00000219  53					 push	 ebx
   2587
   2588	0000021A  8B D8					 mov	 ebx, eax
   2589	0000021C  66| BA 03D4				 mov	 dx, 3d4h
   2590	00000220  B0 0F					 mov	 al, 0fh
   2591	00000222  EE					 out	 dx, al
   2592	00000223  66| BA 03D5				 mov	 dx, 3d5h
   2593	00000227  8A C3					 mov	 al, bl
   2594	00000229  EE					 out	 dx, al
   2595
   2596	0000022A  66| BA 03D4				 mov	 dx, 3d4h
   2597	0000022E  B0 0E					 mov	 al, 0eh
   2598	00000230  EE					 out	 dx, al
   2599	00000231  66| BA 03D5				 mov	 dx, 3d5h
   2600	00000235  8A C7					 mov	 al, bh
   2601	00000237  EE					 out	 dx, al
   2602
   2603	00000238  5B					 pop	 ebx
   2604	00000239  5A					 pop	 edx
   2605	0000023A  58					 pop	 eax
   2606					 ;---------------------------------------------------------------------------------
   2607					 ;changed this code on 7-7-2004
   2608							 ;cli
   2609	0000023B  52					 push	 edx
   2610	0000023C  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2611							 ; so that CPU will return to its application during IRETD not to
   2612							 ;  exit from the task using link field	in the TSS
   2613	0000023D  5A					 pop	 edx;
   2614	0000023E  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2615	00000244  52					 push	 edx
   2616	00000245  9D					 popfd
   2617	00000246  5A					 pop	 edx
   2618							 ;sti
   2619					 ;--------------------------------------------------------------------------------
   2620	00000247  CF					 iretd
   2621	00000248			 SetCursor	 endp
   2622
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 47
prcycle.ASM



   2623					 ;--------------------------------------------------------------------------------
   2624					 ; scroll one line up
   2625					 ;--------------------------------------------------------------------------------
   2626	00000248			 scroll		 proc far
   2627	00000248  51					 push	 ecx
   2628	00000249  57					 push	 edi
   2629	0000024A  56					 push	 esi
   2630	0000024B  06					 push	 es
   2631	0000024C  1E					 push	 ds
   2632
   2633	0000024D  66| B8 0010				 mov	 ax, Video_Sel
   2634	00000251  8E E0					 mov	 fs, ax
   2635
   2636	00000253  66| B9 0780				 mov	 cx, 1920
   2637	00000257  66| BB 0000				 mov	 bx, 0
   2638	0000025B			 Movenext:
   2639	0000025B  66| 64: 67| 8B 87   +			 mov	 ax, fs:[bx+160]
   2640		  00A0
   2641	00000262  66| 64: 67| 89 07			 mov	 fs:[bx], ax
   2642	00000267  66| 83 C3 02				 add	 bx, 2
   2643	0000026B  E2 EE					 loop	 Movenext
   2644
   2645	0000026D  66| B9 0050				 mov	 cx, 80
   2646	00000271  66| BB 0EFF				 mov	 bx, 3839
   2647	00000275  66| B8 0000				 mov	 ax, 0
   2648	00000279			 Clearnext:
   2649	00000279  66| 64: 67| 89 07			 mov	 fs:[bx], ax
   2650	0000027E  66| 83 C3 02				 add	 bx, 2
   2651	00000282  E2 F5					 loop	 Clearnext
   2652
   2653	00000284  66| B8 0780				 mov	 ax, 1920
   2654	00000288  CD F3					 int	 0f3h
   2655
   2656	0000028A  1F					 pop	 ds
   2657	0000028B  07					 pop	 es
   2658	0000028C  5E					 pop	 esi
   2659	0000028D  5F					 pop	 edi
   2660	0000028E  59					 pop	 ecx
   2661					 ;---------------------------------------------------------------------------------
   2662					 ;changed this code on 7-7-2004
   2663	0000028F  FA					 cli
   2664	00000290  52					 push	 edx
   2665	00000291  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2666							 ; so that CPU will return to its application during IRETD not to
   2667							 ;  exit from the task using link field	in the TSS
   2668	00000292  5A					 pop	 edx
   2669	00000293  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2670	00000299  52					 push	 edx
   2671	0000029A  9D					 popfd
   2672	0000029B  5A					 pop	 edx
   2673	0000029C  FB					 sti
   2674					 ;--------------------------------------------------------------------------------
   2675	0000029D  CF					 iretd
   2676	0000029E			 scroll		 endp
   2677
   2678					 ; clean screen
   2679	0000029E			 CLScreen	 PROC far
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 48
prcycle.ASM



   2680	0000029E  53					 push	 ebx
   2681	0000029F  51					 push	 ecx
   2682	000002A0  50					 push	 eax
   2683	000002A1  0F A0					 push	 fs
   2684
   2685	000002A3  66| B9 07D0				 mov	 cx, 2000
   2686	000002A7  66| B8 0010				 mov	 ax, Video_Sel
   2687	000002AB  8E E0					 mov	 fs,ax
   2688	000002AD  66| BB 0000				 mov	 bx, 0
   2689	000002B1  66| B8 0000				 mov	 ax,0
   2690	000002B5  66| 64: 67| 89 07		 next:	 mov	 Word ptr fs:[bx], ax
   2691	000002BA  66| 83 C3 02				 add	 bx,2
   2692	000002BE  E2 F5					 loop	 next
   2693
   2694	000002C0  0F A1					 pop	 fs
   2695	000002C2  58					 pop	 eax
   2696	000002C3  59					 pop	 ecx
   2697	000002C4  5B					 pop	 ebx
   2698					 ;---------------------------------------------------------------------------------
   2699					 ;changed this code on 7-7-2004
   2700	000002C5  FA					 cli
   2701	000002C6  52					 push	 edx
   2702	000002C7  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2703							 ; so that CPU will return to its application during IRETD not to
   2704							 ;  exit from the task using link field	in the TSS
   2705	000002C8  5A					 pop	 edx
   2706	000002C9  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2707	000002CF  52					 push	 edx
   2708	000002D0  9D					 popfd
   2709	000002D1  5A					 pop	 edx
   2710	000002D2  FB					 sti
   2711					 ;--------------------------------------------------------------------------------
   2712
   2713	000002D3  CF					 iretd
   2714	000002D4			 CLScreen	 ENDP
   2715
   2716					 ;------------------------------------------------------
   2717					 ; return a character in al
   2718					 ;------------------------------------------------------
   2719	000002D4			 Getchar32	 PROC FAR
   2720	000002D4  53					 push	 ebx
   2721	000002D5  51					 push	 ecx
   2722	000002D6  52					 push	 edx
   2723	000002D7  56					 push	 esi
   2724	000002D8  0F A0					 push	 fs
   2725
   2726	000002DA  66| B8 0018				 mov	 ax, RData_Sel
   2727	000002DE  8E E0					 mov	 fs, ax
   2728
   2729	000002E0  B8 00000308r				 mov	 eax, offset KKQ
   2730	000002E5  8B F0					 mov	 esi, eax
   2731
   2732	000002E7  33 C0					 xor	 eax, eax
   2733	000002E9  CD F2					 int	 0f2h
   2734	000002EB  66| 8B D0				 mov	 dx, ax
   2735	000002EE  66| 52				 push	 dx
   2736	000002F0  66| BB 0002				 mov	 bx, 2
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 49
prcycle.ASM



   2737	000002F4  66| F7 E3				 mul	 bx
   2738	000002F7  66| 5A				 pop	 dx
   2739	000002F9  8B C8					 mov	 ecx, eax
   2740
   2741	000002FB			 WaitChar:
   2742	000002FB  64: 67| 8A 1E	0407r			 mov	 bl, fs:[KHead]
   2743	00000301  64: 67| 8A 3E	0408r			 mov	 bh, fs:[KTail]
   2744	00000307  3A DF					 cmp	 bl, bh
   2745	00000309  74 F0					 je	 WaitChar
   2746
   2747	0000030B  33 DB					 xor	 ebx, ebx
   2748	0000030D  64: 67| 8A 1E	0408r			 mov	 bl, fs:[KTail]
   2749	00000313  03 F3					 add	 esi, ebx
   2750	00000315  64: 8A 06				 mov	 al, byte ptr fs:[esi]
   2751
   2752	00000318  80 FB	FE				 cmp	 bl, 254
   2753	0000031B  74 04					 jz	 RoundChar
   2754	0000031D  FE C3					 inc	 bl
   2755	0000031F  EB 02					 jmp	 UpdateChar
   2756	00000321			 RoundChar:
   2757	00000321  B3 00					 mov	 bl, 0
   2758	00000323			 UpdateChar:
   2759	00000323  64: 67| 88 1E	0408r			 mov	 fs:[KTail], bl
   2760
   2761	00000329  50					 push	 eax
   2762	0000032A  3C 0D					 cmp	 al, 13
   2763	0000032C  74 04					 jz	 NDisp
   2764	0000032E  8B D9					 mov	 ebx, ecx
   2765	00000330  CD F7					 int	 0f7h  ; echo the character
   2766	00000332			 NDisp:
   2767	00000332  66| 42				 inc	 dx
   2768	00000334  66| 81 FA 07D0			 cmp	 dx, 2000
   2769	00000339  7C 04					 jl	 CursorOK
   2770	0000033B  CD F0					 int	 0f0h
   2771	0000033D  EB 05					 jmp	 Charout
   2772	0000033F			 CursorOK:
   2773	0000033F  66| 8B C2				 mov	 ax, dx
   2774	00000342  CD F3					 int	 0f3h
   2775	00000344			 Charout:
   2776
   2777	00000344  58					 pop	 eax
   2778
   2779	00000345  0F A1					 pop	 fs
   2780	00000347  5E					 pop	 esi
   2781	00000348  5A					 pop	 edx
   2782	00000349  59					 pop	 ecx
   2783	0000034A  5B					 pop	 ebx
   2784
   2785					 ;---------------------------------------------------------------------------------
   2786					 ;changed this code on 7-7-2004
   2787							 ;cli
   2788	0000034B  52					 push	 edx
   2789	0000034C  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2790							 ; so that CPU will return to its application during IRETD not to
   2791							 ;  exit from the task using link field	in the TSS
   2792	0000034D  5A					 pop	 edx
   2793	0000034E  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 50
prcycle.ASM



   2794	00000354  52					 push	 edx
   2795	00000355  9D					 popfd
   2796	00000356  5A					 pop	 edx
   2797							 ;sti
   2798	00000357  CF					 iretd
   2799	00000358			 Getchar32	 ENDP
   2800					 ;-------------------------------------------------------------------------------------------
   2801					 --
   2802					 ; This	is there is a char in the Keybord buffer it will return	the char else it will return+
   2803					 -1
   2804					 ;--------------------------------------------------------------------------------
   2805
   2806	00000358			 Getchar32Buff	 PROC FAR
   2807							 ;cli
   2808	00000358  53					 push	 ebx
   2809	00000359  51					 push	 ecx
   2810	0000035A  52					 push	 edx
   2811	0000035B  56					 push	 esi
   2812	0000035C  0F A0					 push	 fs
   2813
   2814	0000035E  66| B8 0018				 mov	 ax, RData_Sel
   2815	00000362  8E E0					 mov	 fs, ax
   2816
   2817	00000364  B8 00000308r				 mov	 eax, offset KKQ
   2818	00000369  8B F0					 mov	 esi, eax
   2819
   2820	0000036B  33 C0					 xor	 eax, eax
   2821	0000036D  CD F2					 int	 0f2h
   2822	0000036F  66| 8B D0				 mov	 dx, ax
   2823	00000372  66| 52				 push dx
   2824	00000374  66| BB 0002				 mov	 bx, 2
   2825	00000378  66| F7 E3				 mul	 bx
   2826	0000037B  66| 5A				 pop	 dx
   2827	0000037D  8B C8					 mov	 ecx, eax
   2828
   2829	0000037F			 WaitChar1:
   2830	0000037F  64: 67| 8A 1E	0407r			 mov	 bl, fs:[KHead]
   2831	00000385  64: 67| 8A 3E	0408r			 mov	 bh, fs:[KTail]
   2832	0000038B  3A DF					 cmp	 bl, bh
   2833	0000038D  75 07					 jne	 getc
   2834	0000038F  66| B8 00FE				 mov	 ax,0FEh
   2835	00000393  50					 push	 eax
   2836	00000394  EB 39					 jmp	 Charout1
   2837
   2838	00000396  33 DB			 getc:	 xor	 ebx, ebx
   2839	00000398  64: 67| 8A 1E	0408r			 mov	 bl, fs:[KTail]
   2840	0000039E  03 F3					 add	 esi, ebx
   2841	000003A0  64: 8A 06				 mov	 al, byte ptr fs:[esi]
   2842
   2843	000003A3  80 FB	FE				 cmp	 bl, 254
   2844	000003A6  74 04					 jz	 RoundChar1
   2845	000003A8  FE C3					 inc	 bl
   2846	000003AA  EB 02					 jmp	 UpdateChar1
   2847	000003AC			 RoundChar1:
   2848	000003AC  B3 00					 mov	 bl, 0
   2849	000003AE			 UpdateChar1:
   2850	000003AE  64: 67| 88 1E	0408r			 mov	 fs:[KTail], bl
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 51
prcycle.ASM



   2851
   2852	000003B4  50					 push	 eax
   2853	000003B5  3C 0D					 cmp	 al, 13
   2854	000003B7  74 04					 jz	 NDisp1
   2855	000003B9  8B D9					 mov	 ebx, ecx
   2856	000003BB  CD F7					 int	 0f7h
   2857						 ; echo	the character
   2858	000003BD			 NDisp1:
   2859	000003BD  66| 42				 inc	 dx
   2860	000003BF  66| 81 FA 07D0			 cmp	 dx, 2000
   2861	000003C4  7C 04					 jl	 CursorOK1
   2862	000003C6  CD F0					 int	 0f0h
   2863	000003C8  EB 05					 jmp	 Charout1
   2864	000003CA			 CursorOK1:
   2865	000003CA  66| 8B C2				 mov	 ax, dx
   2866	000003CD  CD F3					 int	 0f3h
   2867	000003CF			 Charout1:
   2868	000003CF  58					 pop	 eax
   2869
   2870	000003D0  0F A1					 pop	 fs
   2871	000003D2  5E					 pop esi
   2872	000003D3  5A					 pop	 edx
   2873	000003D4  59					 pop	 ecx
   2874	000003D5  5B					 pop	 ebx
   2875							 ;sti
   2876					 ;---------------------------------------------------------------------------------
   2877					 ;changed this code on 7-7-2004
   2878							 ;cli
   2879	000003D6  52					 push	 edx
   2880	000003D7  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2881							 ; so that CPU will return to its application during IRETD not to
   2882							 ;  exit from the task using link field	in the TSS
   2883	000003D8  5A					 pop	 edx
   2884	000003D9  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2885	000003DF  52					 push	 edx
   2886	000003E0  9D					 popfd
   2887	000003E1  5A					 pop	 edx
   2888							 ;sti
   2889					 ;--------------------------------------------------------------------------------
   2890	000003E2  CF					 iretd
   2891	000003E3			 Getchar32Buff	 ENDP
   2892
   2893					 ;-----------------------------------------------------------------
   2894					 ; FDC_int
   2895					 ; Floppy interrupt handler
   2896					 ;-----------------------------------------------------------------
   2897	000003E3			 FDC_int	 PROC FAR
   2898	000003E3  50					 push	 eax
   2899	000003E4  53					 push	 ebx
   2900	000003E5  52					 push	 edx
   2901	000003E6  0F A0					 push	 fs
   2902
   2903	000003E8  66| B8 0018				 mov	 ax, RData_Sel
   2904	000003EC  8E E0					 mov	 fs, ax
   2905
   2906	000003EE  B0 01					 mov	 al, 1
   2907	000003F0  64: 67| A2 01E3r			 mov	 fs:[FloppyReady], al
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 52
prcycle.ASM



   2908
   2909	000003F5  66| BA 0020				 mov	 dx, 20h
   2910	000003F9  B0 20					 mov	 al, 20h
   2911	000003FB  EE					 out	 dx, al
   2912
   2913	000003FC  0F A1					 pop	 fs
   2914	000003FE  5A					 pop	 edx
   2915	000003FF  5B					 pop	 ebx
   2916	00000400  58					 pop	 eax
   2917					 ;---------------------------------------------------------------------------------
   2918					 ;changed this code on 7-7-2004
   2919	00000401  FA					 cli
   2920	00000402  52					 push	 edx
   2921	00000403  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2922							 ; so that CPU will return to its application during IRETD not to
   2923							 ;  exit from the task using link field	in the TSS
   2924	00000404  5A					 pop	 edx
   2925	00000405  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2926	0000040B  52					 push	 edx
   2927	0000040C  9D					 popfd
   2928	0000040D  5A					 pop	 edx
   2929	0000040E  FB					 sti
   2930					 ;--------------------------------------------------------------------------------
   2931
   2932	0000040F  CF					 iretd
   2933	00000410			 FDC_int	 ENDP
   2934					 ;-----------------------------------------------------------------
   2935					 ;***************************************************************************
   2936					 ;Memory interface entry
   2937					 ;  This interrupt is not used at this point
   2938					 ; It can be used for other purposes
   2939					 ; The procedure is kept to make sure that there 256 interrupts	in IDT
   2940					 ;***************************************************************************
   2941	00000410			 MEMInterface	 PROC	 FAR
   2942
   2943	00000410  CF					 iretd
   2944	00000411			 MEMInterface	 ENDP
   2945					 ;***************************************************************************
   2946					 ;Store	a value	in memory
   2947					 ;  This interrupt is not used at this point
   2948					 ; It can be used for other purposes
   2949					 ; The procedure is kept to make sure that there 256 interrupts	in IDT
   2950					 ;***************************************************************************
   2951	00000411			 getTaskPtr	 PROC	 FAR;
   2952					 ;
   2953					 ;		 push	 gs
   2954					 ;
   2955					 ;		 mov	 ax, RData_Sel		 ; real	data segment base
   2956					 ;		 mov	 gs, ax			 ; gs has real data segment base
   2957					 ;
   2958					 ;		 mov	 eax, gs:[APP1TSSAddr]	 ;get APP1TSSSeg Address
   2959					 ;
   2960					 ;		 pop	 gs
   2961					 ;
   2962					 ;		 iretd
   2963	00000411			 getTaskPtr	 ENDP
   2964					 ;***************************************************************************
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 53
prcycle.ASM



   2965					 ;Fetch	a value	from memory
   2966					 ;  This interrupt is not used at this point
   2967					 ; It can be used for other purposes
   2968					 ; The procedure is kept to make sure that there 256 interrupts	in IDT
   2969					 ;***************************************************************************
   2970	00000411			 MEMFetch	 PROC	 FAR
   2971
   2972	00000411  CF					 iretd
   2973	00000412			 MEMFetch	 ENDP
   2974					 ;***************************************************************************
   2975					 ; This	is a Malloc() type funtion
   2976					 ;   Unused space in memory outside compiler reachable area in main memory
   2977					 ;   User manage his own memory, system	has base and limit of memory areas
   2978					 ; return no of	bytes of memory	available in eax and address ptr as return value
   2979					 ; int AOAmalloc(int*)	using INT 0EEh
   2980					 ; ebx has the no of bytes and eax has the pointer
   2981					 ;***************************************************************************
   2982	00000412			 MEMMalloc	 PROC	 FAR
   2983	00000412  51					 push	 ecx		; save called values
   2984	00000413  56					 push	 esi
   2985	00000414  0F A0					 push	 fs
   2986	00000416  0F A8					 push	 gs
   2987
   2988						 ;	 mov	 ax, MEMData_Sel ;this data selector has 0 base
   2989						 ;	 mov	 fs, ax		 ; 0 base
   2990	00000418  66| B8 0018				 mov	 ax, RData_Sel	 ; real	data segment base
   2991	0000041C  8E E8					 mov	 gs, ax		 ; gs has real data segment base
   2992
   2993	0000041E  65: 67| A1 040Dr			 mov	 eax, gs:[MEMBase] ; get MEMBase value in memory 0200 0000
   2994	00000423  65: 67| 8B 0E	0409r			 mov	 ecx, gs:[MemLimit]; get MEMLimit value	in memory 0400 0000
   2995	00000429  2B C8					 sub	 ecx, eax	 ; total no of bytes of	memory available
   2996	0000042B  8B D9					 mov	 ebx, ecx	 ; Return ebx pointer, which is	the size of memory  +
   2997					 allocated
   2998
   2999	0000042D  0F A9					 pop	 gs   ;	pop all	restored values
   3000	0000042F  0F A1					 pop	 fs
   3001	00000431  5E					 pop	 esi
   3002	00000432  59					 pop	 ecx
   3003					 ;---------------------------------------------------------------------------------
   3004					 ;changed this code on 7-7-2004
   3005	00000433  FA					 cli
   3006	00000434  52					 push	 edx
   3007	00000435  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   3008							 ; so that CPU will return to its application during IRETD not to
   3009							 ;  exit from the task using link field	in the TSS
   3010	00000436  5A					 pop	 edx
   3011	00000437  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   3012	0000043D  52					 push	 edx
   3013	0000043E  9D					 popfd
   3014	0000043F  5A					 pop	 edx
   3015	00000440  FB					 sti
   3016					 ;--------------------------------------------------------------------------------
   3017
   3018	00000441  CF					 iretd
   3019	00000442			 MEMMalloc	 ENDP
   3020					 ;***************************************************************************
   3021					 ; MEMFree to free memory
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 54
prcycle.ASM



   3022					 ; not used at this point
   3023					 ; it can be used for other interrupt
   3024					 ;***************************************************************************
   3025	00000442			 MEMFree PROC	 FAR
   3026
   3027	00000442  CF					 iretd
   3028	00000443			 MEMFree	 ENDP
   3029					 ;***************************************************************************
   3030					 ; ebx has the position	and al has the character to display
   3031					 ;***************************************************************************
   3032	00000443			 DisplayBegin	 PROC	 FAR
   3033	00000443  FA					 cli
   3034	00000444  06					 push	 es
   3035	00000445  50				 push	 eax	  ;save	eax
   3036	00000446  50					 push	 eax
   3037
   3038	00000447  66| B8 0010				 mov	 ax,Video_Sel
   3039	0000044B  8E C0					 mov	 es,ax
   3040	0000044D  58					 pop	 eax
   3041							 ;mov	  ah,17h
   3042							 ;mov	 ah, 7
   3043	0000044E  B4 1F				 mov	 ah, 1fh
   3044	00000450  66| 26: 89 03			 mov	 WORD PTR es:[ebx],ax
   3045	00000454  58					 pop	 eax
   3046	00000455  07					 pop	 es
   3047
   3048						 ;-----------------------------------------------------------------
   3049							 ;changed this code on 7-7-2004
   3050	00000456  52					 push	 edx
   3051	00000457  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   3052							 ; so that CPU will return to its application during IRETD not to
   3053							 ;  exit from the task using link field	in the TSS
   3054	00000458  5A					 pop	 edx
   3055	00000459  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   3056	0000045F  52					 push	 edx
   3057	00000460  9D					 popfd
   3058	00000461  5A					 pop	 edx
   3059						 ;-----------------------------------------------------------------
   3060	00000462  FB					 sti
   3061	00000463  CF					 iretd
   3062
   3063	00000464			 DisplayBegin	 ENDP
   3064
   3065					 ;----------------------------------------------------------------------------
   3066		  = DEMOCODESEG:0464	 DemoCodeLen	 =	 $
   3067					 ;----------------------------------------------------------------------------
   3068	00000464			 DemoCodeSeg	 ENDS
   3069					 ;----------------------------------------------------------------------------
   3070					 ;----------------------------------------------------------------------------
   3071					 ; PCodeSeg
   3072					 ; 16 bit segment for protect mode procedures which have to be in 16 bit segment
   3073					 ;____________________________________________________________________________
   3074	    0000			 PCodeSeg	 SEGMENT PARA public USE16 'CODE'
   3075							 ASSUME	 CS:PCodeSeg,DS:RDataSeg
   3076					 ;***************************************************************************
   3077					 ;Keyboard_Int Procedure
   3078					 ; OUR Hardware	keyboard INTERRUPT
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 55
prcycle.ASM



   3079					 ;***************************************************************************
   3080	    0000			 Keyboard_Int PROC FAR
   3081	    0000  66| 50				 push	 eax
   3082	    0002  66| 53				 push	 ebx
   3083	    0004  66| 51				 push	 ecx
   3084	    0006  66| 52				 push	 edx
   3085	    0008  66| 56				 push	 esi
   3086	    000A  1E					 push	 ds
   3087	    000B  0F A0					 push	 fs
   3088
   3089	    000D  B8 0018				 MOV	 AX, RData_sel		  ;Set up addressing
   3090	    0010  8E E0					 MOV	 fS, AX
   3091	    0012  8E D8					 mov	 ds, ax
   3092	    0014  FA					 cli	 ; disable interrupt
   3093
   3094	    0015  BA 0060				 mov	 dx, 60h ; get a char from keyboard buffer
   3095	    0018  EC					 in	 al, dx
   3096
   3097	    0019  A2 0306r				 mov	 scan, al
   3098	    001C  66| 0F B6 06 0306r			 movzx	 eax, scan
   3099	    0022  E9 03C9				 JMP L_keybd2
   3100	    0025			 L_keybd3:
   3101	    0025  66| 33 C0				 XOR EAX,EAX
   3102	    0028  A2 0301r				 MOV CtrlStat, AL
   3103	    002B  E9 0423				 JMP L_keybd1
   3104	    002E			 L_keybd4:
   3105	    002E  66| 33 C0				 XOR EAX,EAX
   3106	    0031  A2 0302r				 MOV AltStat, AL
   3107	    0034  E9 041A				 JMP L_keybd1
   3108	    0037			 L_keybd5:
   3109	    0037  B0 00					 mov al, 0	 ; release shift key
   3110	    0039  A2 0300r				 MOV ShiftStat,	AL
   3111	    003C  E9 0412				 JMP L_keybd1
   3112	    003F			 L_keybd6:
   3113	    003F  B0 00					 mov al, 0	 ; release shift key
   3114	    0041  A2 0300r				 MOV ShiftStat,	AL
   3115	    0044  E9 040A				 JMP L_keybd1
   3116	    0047			 L_keybd7:
   3117	    0047  66| B8 00000001			 MOV EAX,1
   3118	    004D  A2 0301r				 MOV CtrlStat, AL
   3119	    0050  E9 03FE				 JMP L_keybd1
   3120	    0053			 L_keybd8:
   3121	    0053  66| B8 00000001			 MOV EAX,1
   3122	    0059  A2 0302r				 MOV AltStat, AL
   3123	    005C  E9 03F2				 JMP L_keybd1
   3124	    005F			 L_keybd9:
   3125	    005F  66| 0F BE 06 0300r			 MOVSX EAX,ShiftStat
   3126	    0065  66| B9 00000002			 MOV ECX,2
   3127	    006B  66| 0B C1				 OR EAX,ECX
   3128	    006E  B0 01					 mov al, 1	 ; press shift key
   3129	    0070  A2 0300r				 MOV ShiftStat,	AL
   3130	    0073  E9 03DB				 JMP L_keybd1
   3131	    0076			 L_keybd10:
   3132	    0076  66| 0F BE 06 0300r			 MOVSX EAX,ShiftStat
   3133	    007C  66| B9 00000001			 MOV ECX,1
   3134	    0082  66| 0B C1				 OR EAX,ECX
   3135	    0085  B0 01					 mov al, 1	 ; press shift key
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 56
prcycle.ASM



   3136	    0087  A2 0300r				 MOV ShiftStat,	AL
   3137	    008A  E9 03C4				 JMP L_keybd1
   3138	    008D			 L_keybd11:
   3139	    008D  FE 06	0304r				 INC CapLock
   3140	    0091  66| 0F BE 06 0304r			 MOVSX EAX,CapLock
   3141	    0097  66| B9 00000001			 MOV ECX,1
   3142	    009D  66| 23 C1				 AND EAX,ECX
   3143	    00A0  A2 0304r				 MOV CapLock, AL
   3144							 KeyboardLED NumLock, CapLock
1  3145
1  3146	    00A3  B3 00					 mov bl, 0
1  3147	    00A5  A0 0304r				 mov al, CapLock
1  3148	    00A8  3C 00					 cmp al, 0
1  3149	    00AA  74 03					 jz ??0000
1  3150	    00AC  80 CB	04				 or bl,	4
1  3151	    00AF			 ??0000:
1  3152	    00AF  A0 0303r				 mov al, NumLock
1  3153	    00B2  3C 00					 cmp al, 0
1  3154	    00B4  74 03					 jz ??0001
1  3155	    00B6  80 CB	02				 or bl,	2
1  3156	    00B9			 ??0001:
1  3157	    00B9  BA 0064				 mov dx, 64h	 ; set CapLock LED
1  3158	    00BC			 ??0002:
1  3159	    00BC  EC					 in al,	dx
1  3160	    00BD  24 02					 and al, 2
1  3161	    00BF  75 FB					 jnz ??0002
1  3162
1  3163	    00C1  BA 0060				 mov dx, 60h	 ; write LED command
1  3164	    00C4  B0 ED					 mov al, 0edh
1  3165	    00C6  EE					 out dx, al
1  3166
1  3167	    00C7  BA 0064				 mov dx, 64h
1  3168	    00CA			 ??0003:
1  3169	    00CA  EC					 in al,	dx
1  3170	    00CB  24 02					 and al, 2
1  3171	    00CD  75 FB					 jnz ??0003
1  3172
1  3173	    00CF  BA 0060				 mov dx, 60h
1  3174	    00D2  8A C3					 mov al, bl
1  3175	    00D4  EE					 out dx, al
1  3176
1  3177	    00D5  BA 0064				 mov dx, 64h
1  3178	    00D8			 ??0004:
1  3179	    00D8  EC					 in al,	dx
1  3180	    00D9  24 02					 and al, 2
1  3181	    00DB  75 FB					 jnz ??0004
1  3182
   3183	    00DD  E9 0371				 JMP L_keybd1
   3184	    00E0			 L_keybd12:
   3185	    00E0  FE 06	0303r				 INC NumLock
   3186	    00E4  66| 0F BE 06 0303r			 MOVSX EAX,NumLock
   3187	    00EA  66| B9 00000001			 MOV ECX,1
   3188	    00F0  66| 23 C1				 AND EAX,ECX
   3189	    00F3  A2 0303r				 MOV NumLock, AL
   3190							 KeyboardLED NumLock, CapLock
1  3191
1  3192	    00F6  B3 00					 mov bl, 0
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 57
prcycle.ASM



1  3193	    00F8  A0 0304r				 mov al, CapLock
1  3194	    00FB  3C 00					 cmp al, 0
1  3195	    00FD  74 03					 jz ??0005
1  3196	    00FF  80 CB	04				 or bl,	4
1  3197	    0102			 ??0005:
1  3198	    0102  A0 0303r				 mov al, NumLock
1  3199	    0105  3C 00					 cmp al, 0
1  3200	    0107  74 03					 jz ??0006
1  3201	    0109  80 CB	02				 or bl,	2
1  3202	    010C			 ??0006:
1  3203	    010C  BA 0064				 mov dx, 64h	 ; set CapLock LED
1  3204	    010F			 ??0007:
1  3205	    010F  EC					 in al,	dx
1  3206	    0110  24 02					 and al, 2
1  3207	    0112  75 FB					 jnz ??0007
1  3208
1  3209	    0114  BA 0060				 mov dx, 60h	 ; write LED command
1  3210	    0117  B0 ED					 mov al, 0edh
1  3211	    0119  EE					 out dx, al
1  3212
1  3213	    011A  BA 0064				 mov dx, 64h
1  3214	    011D			 ??0008:
1  3215	    011D  EC					 in al,	dx
1  3216	    011E  24 02					 and al, 2
1  3217	    0120  75 FB					 jnz ??0008
1  3218
1  3219	    0122  BA 0060				 mov dx, 60h
1  3220	    0125  8A C3					 mov al, bl
1  3221	    0127  EE					 out dx, al
1  3222
1  3223	    0128  BA 0064				 mov dx, 64h
1  3224	    012B			 ??0009:
1  3225	    012B  EC					 in al,	dx
1  3226	    012C  24 02					 and al, 2
1  3227	    012E  75 FB					 jnz ??0009
1  3228
   3229	    0130  E9 031E				 JMP L_keybd1
   3230
   3231	    0133			 L_keybd13:
   3232	    0133  FE 06	0305r				 INC ScrLock
   3233	    0137  66| 0F BE 06 0305r			 MOVSX EAX,ScrLock
   3234	    013D  66| B9 00000001			 MOV ECX,1
   3235	    0143  66| 23 C1				 AND EAX,ECX
   3236	    0146  A2 0305r				 MOV ScrLock, AL
   3237	    0149  E9 0305				 JMP L_keybd1
   3238	    014C			 L_keybd14:
   3239	    014C  66| 0F BE 06 0306r			 MOVSX EAX,scan
   3240	    0152  66| B9 00000080			 MOV ECX,128
   3241	    0158  66| 23 C1				 AND EAX,ECX
   3242	    015B  0F 85	028D				 JNZ L_keybd15
   3243	    015F  66| B8 000001E4r			 MOV EAX,OFFSET	keyTable1
   3244	    0165  66| 8B F0				 MOV ESI, EAX
   3245	    0168  66| 0F BE 06 0306r			 MOVSX EAX,scan
   3246	    016E  66| 03 F0				 ADD ESI,EAX
   3247	    0171  66| 67| 0F BE	06			 MOVSX EAX,BYTE	PTR [ESI]
   3248	    0176  A2 0307r				 MOV ascii, AL
   3249	    0179  66| 0F BE 06 0307r			 MOVSX EAX,ascii
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 58
prcycle.ASM



   3250	    017F  66| 83 F8 61				 CMP EAX,97
   3251	    0183  0F 9D	C0				 SETGE AL
   3252	    0186  22 C0					 AND AL,AL
   3253	    0188  74 45					 JZ L_keybd20
   3254	    018A  66| 0F BE 06 0307r			 MOVSX EAX,ascii
   3255	    0190  66| 83 F8 7A				 CMP EAX,122
   3256	    0194  0F 9E	C0				 SETLE AL
   3257	    0197  22 C0					 AND AL,AL
   3258	    0199  74 34					 JZ L_keybd20
   3259	    019B  66| 0F BE 06 0300r			 MOVSX EAX,ShiftStat
   3260	    01A1  66| 23 C0				 AND EAX,EAX
   3261	    01A4  74 0E					 JZ L_keybd18
   3262	    01A6  66| 0F BE 06 0304r			 MOVSX EAX,CapLock
   3263	    01AC  66| 23 C0				 AND EAX,EAX
   3264	    01AF  0F 94	C0				 SETZ AL
   3265	    01B2  22 C0					 AND AL,AL
   3266	    01B4			 L_keybd18:
   3267	    01B4  75 19					 JNZ L_keybd20
   3268	    01B6  66| 0F BE 06 0304r			 MOVSX EAX,CapLock
   3269	    01BC  66| 23 C0				 AND EAX,EAX
   3270	    01BF  74 0E					 JZ L_keybd20
   3271	    01C1  66| 0F BE 06 0300r			 MOVSX EAX,ShiftStat
   3272	    01C7  66| 23 C0				 AND EAX,EAX
   3273	    01CA  0F 94	C0				 SETZ AL
   3274	    01CD  22 C0					 AND AL,AL
   3275	    01CF			 L_keybd20:
   3276	    01CF  74 15					 JZ L_keybd21
   3277	    01D1  66| 0F BE 06 0307r			 MOVSX EAX,ascii
   3278	    01D7  66| B9 00000020			 MOV ECX,32
   3279	    01DD  66| 2B C1				 SUB EAX,ECX
   3280	    01E0  A2 0307r				 MOV ascii, AL
   3281	    01E3  E9 01C0				 JMP L_keybd24
   3282	    01E6			 L_keybd21:
   3283	    01E6  66| 0F BE 06 0300r			 MOVSX EAX,ShiftStat
   3284	    01EC  66| 23 C0				 AND EAX,EAX
   3285	    01EF  0F 84	01B3				 JZ L_keybd23
   3286	    01F3  66| 0F BE 06 0307r			 MOVSX EAX,ascii
   3287	    01F9  E9 0108				 JMP L_keybd25
   3288	    01FC			 L_keybd26:
   3289	    01FC  66| B8 00000021			 MOV EAX,33
   3290	    0202  A2 0307r				 MOV ascii, AL
   3291	    0205  E9 019E				 JMP L_keybd24
   3292	    0208			 L_keybd27:
   3293	    0208  66| B8 00000040			 MOV EAX,64
   3294	    020E  A2 0307r				 MOV ascii, AL
   3295	    0211  E9 0192				 JMP L_keybd24
   3296	    0214			 L_keybd28:
   3297	    0214  66| B8 00000023			 MOV EAX,35
   3298	    021A  A2 0307r				 MOV ascii, AL
   3299	    021D  E9 0186				 JMP L_keybd24
   3300	    0220			 L_keybd29:
   3301	    0220  66| B8 00000024			 MOV EAX,36
   3302	    0226  A2 0307r				 MOV ascii, AL
   3303	    0229  E9 017A				 JMP L_keybd24
   3304	    022C			 L_keybd30:
   3305	    022C  66| B8 00000025			 MOV EAX,37
   3306	    0232  A2 0307r				 MOV ascii, AL
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 59
prcycle.ASM



   3307	    0235  E9 016E				 JMP L_keybd24
   3308	    0238			 L_keybd31:
   3309	    0238  66| B8 0000005E			 MOV EAX,94
   3310	    023E  A2 0307r				 MOV ascii, AL
   3311	    0241  E9 0162				 JMP L_keybd24
   3312	    0244			 L_keybd32:
   3313	    0244  66| B8 00000026			 MOV EAX,38
   3314	    024A  A2 0307r				 MOV ascii, AL
   3315	    024D  E9 0156				 JMP L_keybd24
   3316	    0250			 L_keybd33:
   3317	    0250  66| B8 0000002A			 MOV EAX,42
   3318	    0256  A2 0307r				 MOV ascii, AL
   3319	    0259  E9 014A				 JMP L_keybd24
   3320	    025C			 L_keybd34:
   3321	    025C  66| B8 00000028			 MOV EAX,40
   3322	    0262  A2 0307r				 MOV ascii, AL
   3323	    0265  E9 013E				 JMP L_keybd24
   3324	    0268			 L_keybd35:
   3325	    0268  66| B8 00000029			 MOV EAX,41
   3326	    026E  A2 0307r				 MOV ascii, AL
   3327	    0271  E9 0132				 JMP L_keybd24
   3328	    0274			 L_keybd36:
   3329	    0274  66| B8 0000005F			 MOV EAX,95
   3330	    027A  A2 0307r				 MOV ascii, AL
   3331	    027D  E9 0126				 JMP L_keybd24
   3332	    0280			 L_keybd37:
   3333	    0280  66| B8 0000002B			 MOV EAX,43
   3334	    0286  A2 0307r				 MOV ascii, AL
   3335	    0289  E9 011A				 JMP L_keybd24
   3336	    028C			 L_keybd38:
   3337	    028C  66| B8 0000000F			 MOV EAX,15
   3338	    0292  A2 0307r				 MOV ascii, AL
   3339	    0295  E9 010E				 JMP L_keybd24
   3340	    0298			 L_keybd39:
   3341	    0298  66| B8 0000007B			 MOV EAX,123
   3342	    029E  A2 0307r				 MOV ascii, AL
   3343	    02A1  E9 0102				 JMP L_keybd24
   3344	    02A4			 L_keybd40:
   3345	    02A4  66| B8 0000007D			 MOV EAX,125
   3346	    02AA  A2 0307r				 MOV ascii, AL
   3347	    02AD  E9 00F6				 JMP L_keybd24
   3348	    02B0			 L_keybd41:
   3349	    02B0  66| B8 0000003A			 MOV EAX,58
   3350	    02B6  A2 0307r				 MOV ascii, AL
   3351	    02B9  E9 00EA				 JMP L_keybd24
   3352	    02BC			 L_keybd42:
   3353	    02BC  66| B8 00000022			 MOV EAX,34
   3354	    02C2  A2 0307r				 MOV ascii, AL
   3355	    02C5  E9 00DE				 JMP L_keybd24
   3356	    02C8			 L_keybd43:
   3357	    02C8  66| B8 0000007E			 MOV EAX,126
   3358	    02CE  A2 0307r				 MOV ascii, AL
   3359	    02D1  E9 00D2				 JMP L_keybd24
   3360	    02D4			 L_keybd44:
   3361	    02D4  66| B8 0000007C			 MOV EAX,124
   3362	    02DA  A2 0307r				 MOV ascii, AL
   3363	    02DD  E9 00C6				 JMP L_keybd24
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 60
prcycle.ASM



   3364	    02E0			 L_keybd45:
   3365	    02E0  66| B8 0000003C			 MOV EAX,60
   3366	    02E6  A2 0307r				 MOV ascii, AL
   3367	    02E9  E9 00BA				 JMP L_keybd24
   3368	    02EC			 L_keybd46:
   3369	    02EC  66| B8 0000003E			 MOV EAX,62
   3370	    02F2  A2 0307r				 MOV ascii, AL
   3371	    02F5  E9 00AE				 JMP L_keybd24
   3372	    02F8			 L_keybd47:
   3373	    02F8  66| B8 0000003F			 MOV EAX,63
   3374	    02FE  A2 0307r				 MOV ascii, AL
   3375	    0301  E9 00A2				 JMP L_keybd24
   3376	    0304			 L_keybd25:
   3377	    0304  66| 83 F8 2F				 CMP EAX,47
   3378	    0308  74 EE					 JE L_keybd47
   3379	    030A  66| 83 F8 2E				 CMP EAX,46
   3380	    030E  74 DC					 JE L_keybd46
   3381	    0310  66| 83 F8 2C				 CMP EAX,44
   3382	    0314  74 CA					 JE L_keybd45
   3383	    0316  66| 83 F8 5C				 CMP EAX,92
   3384	    031A  74 B8					 JE L_keybd44
   3385	    031C  66| 83 F8 60				 CMP EAX,96
   3386	    0320  74 A6					 JE L_keybd43
   3387	    0322  66| 83 F8 27				 CMP EAX,39
   3388	    0326  74 94					 JE L_keybd42
   3389	    0328  66| 83 F8 3B				 CMP EAX,59
   3390	    032C  74 82					 JE L_keybd41
   3391	    032E  66| 83 F8 5D				 CMP EAX,93
   3392	    0332  0F 84	FF6E				 JE L_keybd40
   3393	    0336  66| 83 F8 5B				 CMP EAX,91
   3394	    033A  0F 84	FF5A				 JE L_keybd39
   3395	    033E  66| 83 F8 09				 CMP EAX,9
   3396	    0342  0F 84	FF46				 JE L_keybd38
   3397	    0346  66| 83 F8 3D				 CMP EAX,61
   3398	    034A  0F 84	FF32				 JE L_keybd37
   3399	    034E  66| 83 F8 2D				 CMP EAX,45
   3400	    0352  0F 84	FF1E				 JE L_keybd36
   3401	    0356  66| 83 F8 30				 CMP EAX,48
   3402	    035A  0F 84	FF0A				 JE L_keybd35
   3403	    035E  66| 83 F8 39				 CMP EAX,57
   3404	    0362  0F 84	FEF6				 JE L_keybd34
   3405	    0366  66| 83 F8 38				 CMP EAX,56
   3406	    036A  0F 84	FEE2				 JE L_keybd33
   3407	    036E  66| 83 F8 37				 CMP EAX,55
   3408	    0372  0F 84	FECE				 JE L_keybd32
   3409	    0376  66| 83 F8 36				 CMP EAX,54
   3410	    037A  0F 84	FEBA				 JE L_keybd31
   3411	    037E  66| 83 F8 35				 CMP EAX,53
   3412	    0382  0F 84	FEA6				 JE L_keybd30
   3413	    0386  66| 83 F8 34				 CMP EAX,52
   3414	    038A  0F 84	FE92				 JE L_keybd29
   3415	    038E  66| 83 F8 33				 CMP EAX,51
   3416	    0392  0F 84	FE7E				 JE L_keybd28
   3417	    0396  66| 83 F8 32				 CMP EAX,50
   3418	    039A  0F 84	FE6A				 JE L_keybd27
   3419	    039E  66| 83 F8 31				 CMP EAX,49
   3420	    03A2  0F 84	FE56				 JE L_keybd26
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 61
prcycle.ASM



   3421	    03A6			 L_keybd23:
   3422	    03A6			 L_keybd24:
   3423	    03A6  66| B8 00000308r			 mov eax, offset KKQ
   3424	    03AC  66| 8B F0				 mov esi, eax
   3425	    03AF  64: 8A 1E 0407r			 mov bl, fs:[KHead]
   3426	    03B4  64: 8A 3E 0408r			 mov bh, fs:[KTail]
   3427
   3428	    03B9  80 FB	FE				 cmp bl, 254
   3429	    03BC  75 04					 jnz Nottail
   3430	    03BE  B3 00					 mov bl, 0
   3431	    03C0  EB 02					 jmp Cmpequal
   3432	    03C2			 Nottail:
   3433	    03C2  FE C3					 inc bl
   3434	    03C4			 Cmpequal:
   3435	    03C4  3A DF					 cmp bl, bh
   3436	    03C6  0F 84	0087				 je L_keybd1 ; keyboard	buffer full
   3437
   3438	    03CA  66| 33 DB				 xor ebx, ebx
   3439	    03CD  64: 8A 1E 0407r			 mov bl, fs:[KHead]
   3440	    03D2  66| 03 F3				 add esi, ebx
   3441	    03D5  A0 0307r				 mov al, ascii
   3442	    03D8  64: 67| 88 06				 mov fs:[esi], al
   3443
   3444	    03DC  80 FB	FE				 cmp bl, 254
   3445	    03DF  72 04					 jb Nottail2
   3446
   3447	    03E1  B3 00					 mov bl, 0
   3448	    03E3  EB 02					 jmp Cmpequal2
   3449	    03E5			 Nottail2:
   3450	    03E5  FE C3					 inc bl
   3451	    03E7			 Cmpequal2:
   3452	    03E7  64: 88 1E 0407r			 mov fs:[KHead], bl
   3453	    03EC			 L_keybd15:
   3454	    03EC  EB 63					 JMP L_keybd1
   3455	    03EE			 L_keybd2:
   3456	    03EE  66| 83 F8 46				 CMP EAX,70
   3457	    03F2  0F 84	FD3D				 JE L_keybd13
   3458	    03F6  66| 83 F8 45				 CMP EAX,69
   3459	    03FA  0F 84	FCE2				 JE L_keybd12
   3460	    03FE  66| 83 F8 3A				 CMP EAX,58
   3461	    0402  0F 84	FC87				 JE L_keybd11
   3462	    0406  66| 83 F8 36				 CMP EAX,54
   3463	    040A  0F 84	FC68				 JE L_keybd10
   3464	    040E  66| 83 F8 2A				 CMP EAX,42
   3465	    0412  0F 84	FC49				 JE L_keybd9
   3466	    0416  66| 83 F8 38				 CMP EAX,56
   3467	    041A  0F 84	FC35				 JE L_keybd8
   3468	    041E  66| 83 F8 1D				 CMP EAX,29
   3469	    0422  0F 84	FC21				 JE L_keybd7
   3470	    0426  66| 3D 000000B6			 CMP EAX,182
   3471	    042C  0F 84	FC0F				 JE L_keybd6
   3472	    0430  66| 3D 000000AA			 CMP EAX,170
   3473	    0436  0F 84	FBFD				 JE L_keybd5
   3474	    043A  66| 3D 000000B8			 CMP EAX,184
   3475	    0440  0F 84	FBEA				 JE L_keybd4
   3476	    0444  66| 3D 0000009D			 CMP EAX,157
   3477	    044A  0F 84	FBD7				 JE L_keybd3
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 62
prcycle.ASM



   3478	    044E  E9 FCFB				 JMP L_keybd14
   3479	    0451			 L_keybd1:
   3480	    0451  E4 61					 in al,	61h	 ; acknowledge the key
   3481	    0453  8A E0					 mov ah, al
   3482	    0455  0C 80					 or al,	80h
   3483	    0457  E6 61					 out 61h, al
   3484	    0459  8A C4					 mov al, ah
   3485	    045B  E6 61					 out 61h, al
   3486
   3487	    045D  B0 20					 MOV AL,20h			  ;Tell	interrupt handler we're	done
   3488	    045F  E6 20					 OUT 20h,AL
   3489	    0461  FB					 STI				  ;enable interrupts
   3490
   3491	    0462  0F A1					 pop	 fs
   3492	    0464  1F					 pop	 ds
   3493	    0465  66| 5E				 pop	 esi
   3494	    0467  66| 5A				 pop	 edx
   3495	    0469  66| 59				 pop	 ecx
   3496	    046B  66| 5B				 pop	 ebx
   3497	    046D  66| 58				 pop	 eax
   3498					 ;---------------------------------------------------------------------------------
   3499					 ;changed this code on 7-7-2004
   3500	    046F  FA					 cli
   3501	    0470  66| 52				 push	 edx
   3502	    0472  66| 9C				 pushfd	; turn off NT flag in the CPU not in the TSS
   3503							 ; so that CPU will return to its application during IRETD not to
   3504							 ;  exit from the task using link field	in the TSS
   3505	    0474  66| 5A				 pop	 edx
   3506	    0476  66| 81 E2 FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   3507	    047D  66| 52				 push	 edx
   3508	    047F  66| 9D				 popfd
   3509	    0481  66| 5A				 pop	 edx
   3510	    0483  FB					 sti
   3511					 ;--------------------------------------------------------------------------------
   3512	    0484  66| CF		 iretd
   3513	    0486			 Keyboard_Int ENDP
   3514
   3515					 ;***************************************************************************
   3516					 ;SearchBegin Procedure
   3517					 ; Find	a given	pattern	in memory
   3518					 ; fs has RDataSel
   3519					 ; es has base 0 descriptor for	4GB limit SearchForData_Sel
   3520					 ; searches memory from	00000000h to 10000000h
   3521					 ;***************************************************************************
   3522	    0486			 SearchBegin	 PROC	 FAR
   3523
   3524	    0486  66| B8 00000010r			 mov	 eax, offset SearchKey
   3525	    048C  66| 8B F8				 mov	 edi, eax
   3526	    048F  66| 33 C9				 xor	 ecx, ecx
   3527	    0492  66| 33 D2				 xor	 edx, edx
   3528	    0495			 GtChar:
   3529
   3530	    0495  CD FC					 int	 0fch	; get a	character at a time to read pattern
   3531	    0497  64: A0 000Br				 mov	 al, fs:[StoreChar] ; store the	char temporarily
   3532	    049B  3C 0D					 cmp	 al, 0dh	 ; check if it is end of line
   3533	    049D  74 08					 je	 Search	 ; if it is end	of line	then search
   3534
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 63
prcycle.ASM



   3535	    049F  41					 inc	 cx	 ; get next character
   3536	    04A0  67| 88 07				 mov	 byte ptr [edi], al ; move the character to key	storage
   3537	    04A3  66| 47				 inc	 edi	 ; next	poitner	for key
   3538	    04A5  EB EE					 jmp	 GtChar	 ; loop	until end of line
   3539
   3540	    04A7				 Search:
   3541	    04A7  64: 89 0E 0110r			 mov	 fs:[SearchLen], cx	 ; Key length
   3542
   3543							 ; Serch between 00000000H and 10000000H
   3544	    04AC  66| BA 00000320			 mov	 edx, 800  ; starting point of printing	on the screen
   3545	    04B2  66| 33 C0				 xor	 eax, eax
   3546	    04B5  66| 8B F8				 mov	 edi, eax  ; destination index with 0 value
   3547	    04B8  66| B9 00000000			 mov	 ecx, 0	   ; start counter 4 byte with 0 value
   3548
   3549	    04BE  66| B8 00000010r			 mov	 eax, offset SearchKey	; offset only
   3550	    04C4  66| 8B F0				 mov	 esi, eax  ; offset in the source index
   3551	    04C7  64: 8B 0E 0110r			 mov	 cx, fs:[SearchLen]  ; 4 byte length
   3552
   3553	    04CC				 Search1:
   3554
   3555	    04CC  64: 67| 8A 1E				 mov	 bl, byte ptr fs:[esi] ; get first byte	of the key
   3556	    04D0  26: 67| 3A 1F				 cmp	 bl, byte ptr es:[edi] ; starting from 00000000h
   3557	    04D4  74 0D					 jz	 Search2   ; first char	matched	go for next char
   3558
   3559	    04D6  66| 47				 inc	 edi  ;	next
   3560	    04D8  66| 81 FF 10000000			 cmp	 edi, 10000000h	; max limit
   3561	    04DF  72 EB					 jb	 Search1 ; go to next location at destination
   3562	    04E1  EB 64					 jmp	 retn2	 ; limit is done, quit
   3563
   3564	    04E3				 Search2:
   3565	    04E3  66| 56				 push	 esi
   3566	    04E5  66| 57				 push	 edi
   3567	    04E7				 Search3:
   3568	    04E7  49					 dec	 cx
   3569	    04E8  E3 2D					 jcxz	 FindIt
   3570	    04EA  66| 46				 inc	 esi
   3571	    04EC  66| 47				 inc	 edi
   3572	    04EE  66| 81 FF 10000000			 cmp	 edi, 10000000h	 ; search over
   3573	    04F5  73 4C					 jae	 retn1
   3574	    04F7  64: 67| 8A 1E				 mov	 bl, byte ptr fs:[esi]
   3575	    04FB  26: 67| 3A 1F				 cmp	 bl, byte ptr es:[edi]
   3576	    04FF  74 E6					 jz	 Search3
   3577
   3578	    0501  66| 5F				 pop	 edi
   3579	    0503  66| 5E				 pop	 esi
   3580
   3581	    0505  66| 47				 inc	 edi
   3582	    0507  66| 81 FF 10000000			 cmp	 edi, 10000000h
   3583	    050E  73 37					 jae	 retn2
   3584	    0510  64: 8B 0E 0110r			 mov	 cx, fs:[SearchLen]
   3585	    0515  EB B5					 jmp	 Search1
   3586
   3587	    0517				 FindIt:
   3588	    0517  66| 8B C7				 mov	 eax, edi
   3589	    051A  66| 5F				 pop	 edi
   3590	    051C  66| 5E				 pop	 esi
   3591	    051E  66| 8B F8				 mov	 edi, eax
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 64
prcycle.ASM



   3592	    0521  66| 33 C9				 xor	 ecx, ecx
   3593	    0524  64: 8B 0E 0110r			 mov	 cx, fs:[SearchLen]
   3594	    0529  49					 dec	 cx
   3595	    052A  66| 2B C1				 sub	 eax, ecx
   3596
   3597	    052D  66| 8B DA				 mov	 ebx, edx
   3598	    0530  CD FD					 int	 0fdh
   3599	    0532  66| 83 C2 12				 add	 edx, 18
   3600
   3601	    0536  66| 47				 inc	 edi
   3602	    0538  66| 81 FF 10000000			 cmp	 edi, 10000000h
   3603	    053F  73 06					 jae	 retn2
   3604	    0541  EB 89					 jmp	 Search1
   3605
   3606	    0543				 retn1:
   3607	    0543  66| 5F				 pop	 edi
   3608	    0545  66| 5E				 pop	 esi
   3609	    0547				 retn2:
   3610
   3611							 ;This loop displays the destination address at	the end	the search
   3612	    0547  66| 50				 push	 eax
   3613	    0549  66| 53				 push	 ebx
   3614	    054B  66| 8B C7				 mov	 eax,edi ; This	prints the destination address of search
   3615	    054E  66| BB 00000AF0			 mov	 ebx, 2800
   3616	    0554  CD FD					 int	 0fdh
   3617	    0556  66| 5B				 pop	 ebx
   3618	    0558  66| 58				 pop	 eax
   3619
   3620
   3621	    055A  66| CF				 iretd
   3622	    055C  E9 FF27				 jmp	 SearchBegin
   3623	    055F			 SearchBegin	 ENDP
   3624		  = PCODESEG:055F	 PCodeLen     =	      $
   3625	    055F			 PCodeSeg	 ends
   3626					 ;***************************************************************************
   3627					 ; DMADataSeg
   3628					 ; 16 bit, aligned on page
   3629					 ; Used	for DMA	transfer
   3630					 ;***************************************************************************
   3631	    0000			 DMADataSeg	 SEGMENT PARA PUBLIC USE16 'DMADATA'
   3632	    0000  0100*(00)		 DB	 256 DUP(0)
   3633	    0100  0100*(00)		 DB	 256 DUP(0)
   3634	    0200			 DMADataSeg	 ENDS
   3635					 ;***************************************************************************
   3636					 ; MEMStructureSeg
   3637					 ; 16 bit, aligned on page
   3638					 ; Used	for memory structure
   3639					 ; every variable is 18	bytes and has such structure:
   3640					 ; DQ, start address
   3641					 ; DQ, size
   3642					 ; DB, variable	type
   3643					 ; DB, valid
   3644					 ; program can allocate	2000 variables
   3645					 ;***************************************************************************
   3646					 ;MEMStructureSeg	 SEGMENT PARA PUBLIC USE16 'MEMSTRDATA'
   3647					 ;DB	 36000 DUP(0)
   3648					 ;MEMStructureSeg	 ENDS
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 65
prcycle.ASM



   3649					 ;***************************************************************************
   3650					 ;RDataSeg Segment
   3651					 ;  16 bit segment
   3652					 ;  all	real mode data should be included in this segment
   3653					 ;***************************************************************************
   3654					 ;
   3655	    0000			 RDataSeg	 SEGMENT PARA  public USE16  'REALDATA'
   3656					 ;
   3657					 ;----------------------------------------------------------------------------
   3658					 ;GDT
   3659					 ;This example has a base of 00100200h
   3660					 ;LimitL	 BaseL		 BaseM	 Attributes	 LimitH		 BaseH
   3661					 ;----------------------------------------------------------------------------
   3662					 ;FF FF		 00 02		 10	 92		 8F		 00
   3663					 ;----------------------------------------------------------------------------
   3664					 ;LSB1,2nd	 LSB1,2nd		 P DPL S Type	 G D 0 AVL Limit
   3665					 ;----------------------------------------------------------------------------
   3666					 ;P- Segment Present,S-system(callgate must have 0 for S)
   3667					 ;G-Granularity,D=0 ->16bit segment and	addressess and D=1->32 bit
   3668					 ;For CallGate	 Type=1100
   3669					 ;-----------------------------------------
   3670					 ; FF|FF|00|02|10|92|8F|00
   3671					 ;	|     |	 |  |  |
   3672					 ;LimitL|BaseL|BaseM|Attributes|GD0AVL,LimitH|BaseH
   3673					 ; 00 10 02 00
   3674					 ; BaseH BaseM BaseL2nd	BaseL1st
   3675					 ; BYTE	0  --- BYTE 7
   3676					 ;-----------------------------------------
   3677					 ;----------------------------------------------------------------------------
   3678
   3679	    0000			 GDT		 LABEL	 BYTE
   3680	    0000  0000 0000 00 00 00  +	 DUMMY		 Desc	 <00000h,00000h, 000h, 000h, 000h, 000h> ; dummy characters for	    +
   3681		  00			 reference
   3682					 ; It changed from RELOCATE1 to	0800h, seems to	have no	effect
   3683					 ; prcycle code	is starting at 0800h
   3684	    0008  FFFF 0800 00 92 00  +	 Normal		 Desc	 <0ffffh,0800h,,ATDW,,>
   3685		  00
   3686	    0010  7FFF 8000 0B F2 00  +	 VideoBuf	 Desc	 <07fffh,8000h,0bh,ATDW+DPL3,,>
   3687		  00
   3688	    0018			 EFFGDT		 LABEL	 BYTE	; starting point of GDT	entry
   3689					 ;----------------------------------------------------------------------
   3690					 ;RELOCATE1 should be a	segment	register value not the 32 bit address
   3691					 ;All base addressess should be	initialised like a segment register.
   3692					 ;----------------------------------------------------------------------
   3693	    0018  FFFF 0080s 00	92 00 +	 RData		 Desc	 <0ffffh,RDataSeg+RELOCATE1,,ATDW,,>	   ;for	loading	fs
   3694		  00
   3695	    0020  0069r	0080s 00 89 00+	 DemoTSS	 Desc	 <DemoTssLen-1,DemoTSSSeg+RELOCATE1,,AT386TSS,,>
   3696		  00
   3697	    0028  009F 0080s 00	82 00 +	 DemoLDTD	 Desc	 <DemoLDTLen-1,DemoLDTSeg+RELOCATE1,,ATLDT,,>
   3698		  00
   3699	    0030  FFFF 0080s 00	98 00 +	 TempCode	 Desc	 <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>	 ;RCodeSeg
   3700		  00
   3701	    0038  0DC4r	0080s 00 98 00+	 Other		 Desc	 <RCodeLen-1,RCodeSeg+RELOCATE1,,ATCE,,>
   3702		  00
   3703	    0040  0068r	0080s 00 89 00+	 GetCharTSS	 Desc	 <GetCharTSSLen-1,GetCharTSSSeg+RELOCATE1,,AT386TSS,,>	;AT386TSS = +
   3704		  00			 89h
   3705	    0048  0068r	0080s 00 89 00+	 GetDecTSS	 Desc	 <GetDecTSSLen-1,GetDecTSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS	= 89h
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 66
prcycle.ASM



   3706		  00
   3707	    0050  0068r	0080s 00 89 00+	 GetSecTSS	 Desc	 <GetSecTSSLen-1,GetSecTSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS	= 89h
   3708		  00
   3709	    0058  0068r	0080s 00 89 00+	 WriteSecTSS	 Desc	 <WriteSecTSSLen-1,WriteSecTSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS +
   3710		  00			 = 89h
   3711	    0060  0068r	0080s 00 89 00+	 GKeyTSS	 Desc	 <GKeyTSSLen-1,GKeyTSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS = 89h
   3712		  00
   3713	    0068  000Fr	0080s 00 82 00+	 GKeyLDT	 Desc	 <GKeyLDTLen-1,GKeyLDTSeg+RELOCATE1,,ATLDT,,>
   3714		  00
   3715	    0070  000Fr	0080s 00 82 00+	 GetCharLDT	 Desc	 <GetCharLDTLen-1,GetCharLDTSeg+RELOCATE1,,ATLDT,,>
   3716		  00
   3717	    0078  000Fr	0080s 00 82 00+	 GetDecLDT	 Desc	 <GetDecLDTLen-1,GetDecLDTSeg+RELOCATE1,,ATLDT,,>
   3718		  00
   3719	    0080  000Fr	0080s 00 82 00+	 GetSecLDT	 Desc	 <GetSecLDTLen-1,GetSecLDTSeg+RELOCATE1,,ATLDT,,>
   3720		  00
   3721	    0088  000Fr	0080s 00 82 00+	 WriteSecLDT	 Desc	 <WriteSecLDTLen-1,WriteSecLDTSeg+RELOCATE1,,ATLDT,,>
   3722		  00
   3723	    0090  0017r	0080s 00 92 40+	 Puthex32Data	 Desc	 <ProtModeProcDataLen-1,ProtModeProcDataSeg+RELOCATE1,,ATDW,D32,0h>
   3724		  00
   3725	    0098  0463r	0080s 00 98 40+	 Puthex32I	 Desc	 <DemoCodeLen-1,DemoCodeSeg+RELOCATE1,,ATCE,D32,>
   3726		  00
   3727	    00A0  001Fr	0080s 00 82 00+	 SearchLDT	 Desc	 <SearchLDTLen-1,SearchLDTSeg+RELOCATE1,,ATLDT,,>
   3728		  00
   3729	    00A8  0068r	0080s 00 89 00+	 SearchTSS	 Desc	 <SearchTSSLen-1,SearchTSSSeg+RELOCATE1,,AT386TSS,,>
   3730		  00
   3731	    00B0  FFFF 0000 00 92 CF  +	 G4Data		 Desc	 <0ffffh,0,0,92h,0cfh,0>
   3732		  00
   3733
   3734	    00B8  0111r	0080s 00 92 00+	 GlobalData	 Desc	 <GlobalDataLen-1,GlobalDataSeg+RELOCATE1,,ATDW,,0h>
   3735		  00
   3736					 ; this	descriptor is in GDT, it is not	a task,	any global program can use this
   3737	    00C0  FFFF 0000 00 92 CF  +	 MEMData	 Desc	 <0ffffh,0h,0h,ATDW,0cfh,0h>	 ;Memory interface data	segment
   3738		  00
   3739					 ; MEMData selector does not have any base address everything is zero
   3740
   3741					 ; App1TSS descriptor must be in GDT as	it is a	separate Task
   3742
   3743					 ; All the fields can be modified dynamically in the followong desc if App1TSS Address is   +
   3744					 given to Application
   3745					 ; Currently there can be 4 applications setup in GDT
   3746					 ; each	application 1,2,3,4 are	called parent applications
   3747					 ; all parent applications are fixed in	GDT
   3748					 ; each	parent application is given one	slot for a child task in GDT
   3749					 ; multiple children's tasks are managed in the	application by using this one slot
   3750					 ;  and	a given	API to modify child location in	GDT
   3751					 ;App1TSS	 Desc	 <App1TSSLen-1,0000h,00h,AT386TSS,,02h>	 ;AT386TSS = 89h
   3752	    00C8  006Fr	0080s 00 89 00+	 App1TSS	 Desc	 <App1TSSLen-1,App1TSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS = 89h   +
   3753		  00			 Application
   3754	    00D0  006Fr	0080s 00 92 00+	 App1TSSRW	 Desc	 <App1TSSLen-1,App1TSSSeg+RELOCATE1,,ATDW,,>  ;AT386TSS	= 89h
   3755		  00
   3756	    00D8  0037r	0080s 00 82 00+	 App1LDT	 Desc	 <App1LDTLen-1,App1LDTSeg+RELOCATE1,,ATLDT,,>
   3757		  00
   3758	    00E0  006Fr	0080s 00 89 00+	 App1TSSC	 Desc	 <App1TSSLen-1,App1TSSSeg+RELOCATE1,,AT386TSS,,> ;AT386TSS = 89h    +
   3759		  00			 Client
   3760	    00E8  006Fr	0080s 00 89 00+	 App1TSSS	 Desc	 <App1TSSLen-1,App1TSSSeg+RELOCATE1,,AT386TSS,,> ;AT386TSS = 89h    +
   3761		  00			 Scheduler
   3762	    00F0  0000 0000 00 00 00  +	 App1TSST	 Desc	 <,,,,,>					 ;AT386TSS = 89h    +
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 67
prcycle.ASM



   3763		  00			 Timer
   3764	    00F8  0000 0000 00 00 00  +	 App1TSSE	 Desc	 <,,,,,>					 ;AT386TSS = 89h    +
   3765		  00			 Error
   3766
   3767	    0100  03FFr	0080s 00 89 00+	 App2TSS	 Desc	 <App2TSSLen-1,App2TSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS = 89h
   3768		  00
   3769	    0108  03FFr	0080s 00 92 00+	 App2TSSRW	 Desc	 <App2TSSLen-1,App2TSSSeg+RELOCATE1,,ATDW,,>  ;AT386TSS	= 89h
   3770		  00
   3771	    0110  0037r	0080s 00 82 00+	 App2LDT	 Desc	 <App1LDTLen-1,App1LDTSeg+RELOCATE1,,ATLDT,,>
   3772		  00
   3773	    0118  03FFr	0000 00	89 00 +	 App2TSSC	 Desc	 <App2TSSLen-1,0000h,00h,AT386TSS,,02h>	 ;AT386TSS = 89h
   3774		  02
   3775	    0120  03FFr	0080s 00 92 00+	 App2TSSRWC	 Desc	 <App2TSSLen-1,App2TSSSeg+RELOCATE1,,ATDW,,>  ;AT386TSS	= 89h
   3776		  00
   3777	    0128  0037r	0080s 00 82 00+	 App2LDTC	 Desc	 <App1LDTLen-1,App1LDTSeg+RELOCATE1,,ATLDT,,>
   3778		  00
   3779
   3780	    0130  FFFF 0080s 00	92 00 +	 DMADATA	 Desc	 <0ffffh,DMADataSeg+RELOCATE1,,ATDW,,0H>	 ; for DMA read/write
   3781		  00
   3782	    0138  055Er	0080s 00 98 00+	 PCode		 Desc	 <PCodeLen-1,PCodeSeg+RELOCATE1,,ATCE,,>     ;PCodeSeg
   3783		  00
   3784	    0140  00E1r	0080s 00 98 40+	 EtherDesc	 Desc	 <EthernetReceiveCodeLen-1,EthernetReceive+RELOCATE1,,ATCE,D32,>
   3785		  00
   3786	    0148  0069r	0080s 00 92 00+	 DemoTSSRW	 Desc	 <DemoTSSLen-1,DemoTSSSeg+RELOCATE1,,ATDW,,>  ;AT386TSS	= 89h
   3787		  00
   3788	    0150  0000r	0080s 00 98 40+	 IntExceptionDesc	 Desc	 <IntExceptionCodeLen-1,IntExceptionSeg+RELOCATE1,,ATCE,D32,>
   3789		  00
   3790					 ;		 REPT	 100
   3791					 ;		 Desc	 <00200h,00200h, 020h, 020h, 020h, 020h>
   3792					 ;		 ENDM
   3793					 ;----------------------------------------------------------------------------
   3794		  = 0158		 GDTLen		 =	 $-GDT			  ;total no of entries including dummies
   3795		  = 0028		 GDNum		 =	 ($-EFFGDT)/(SIZE Desc)	  ; number of entries in GDT ex.. 28
   3796					 ;----------------------------------------------------------------------------
   3797		  = 0008		 Normal_Sel	 =	 Normal-GDT
   3798		  = 0010		 Video_Sel	 =	 VideoBuf-GDT
   3799					 ;----------------------------------------------------------------------------
   3800		  = 0020		 DemoTSS_Sel		 =	 DemoTSS-GDT
   3801		  = 0148		 DemoTSSRW_Sel		 =	 DemoTSSRW-GDT
   3802		  = 0028		 DemoLDT_Sel		 =	 DemoLDTD-GDT
   3803		  = 0030		 TempCode_Sel		 =	 TempCode-GDT
   3804		  = 0038		 Other_Sel		 =	 Other-GDT
   3805		  = 0018		 RData_Sel		 =	 RData-GDT
   3806		  = 0060		 GKeyTSS_Sel		 =	 GKeyTSS-GDT
   3807		  = 0040		 GetCharTSS_Sel		 =	 GetCharTSS-GDT
   3808		  = 0048		 GetDecTSS_Sel		 =	 GetDecTSS-GDT
   3809		  = 0050		 GetSecTSS_Sel		 =	 GetSecTSS-GDT
   3810		  = 0058		 WriteSecTSS_Sel	 =	 WriteSecTSS-GDT
   3811		  = 0068		 GKeyLDT_Sel		 =	 GKeyLDT-GDT
   3812		  = 0070		 GetCharLDT_Sel		 =	 GetCharLDT-GDT
   3813		  = 0078		 GetDecLDT_Sel		 =	 GetDecLDT-GDT
   3814		  = 0080		 GetSecLDT_Sel		 =	 GetSecLDT-GDT
   3815		  = 0088		 WriteSecLDT_Sel	 =	 WriteSecLDT-GDT
   3816		  = 0090		 Puthex32Data_Sel	 =	 Puthex32Data-GDT
   3817		  = 0098		 Puthex32I_Sel		 =	 Puthex32I-GDT
   3818		  = 0140		 EthernetReceive_Sel	 =	 EtherDesc-GDT
   3819
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 68
prcycle.ASM



   3820		  = 00B8		 GlobalData_Sel		 =	 GlobalData-GDT
   3821
   3822		  = 00C0		 MEMData_Sel		 =	 MEMData-GDT
   3823					 ;MEMStrData_Sel	 =	 MEMStrData-GDT
   3824
   3825		  = 00A0		 SearchLDT_Sel		 =	 SearchLDT-GDT
   3826		  = 00A8		 SearchTSS_Sel		 =	 SearchTSS-GDT
   3827		  = 00B0		 G4Data_Sel		 =	 G4Data-GDT
   3828
   3829		  = 00C8		 App1TSS_Sel		 =	 App1TSS-GDT
   3830		  = 00E0		 App1TSSC_Sel		 =	 App1TSSC-GDT
   3831		  = 00E8		 App1TSSS_Sel		 =	 App1TSSS-GDT
   3832		  = 00F8		 App1TSSE_Sel		 =	 App1TSSE-GDT
   3833		  = 00F0		 App1TSST_Sel		 =	 App1TSST-GDT
   3834		  = 0100		 App2TSS_Sel		 =	 App2TSS-GDT
   3835		  = 00D0		 App1TSSRW_Sel		 =	 App1TSSRW-GDT
   3836		  = 0108		 App2TSSRW_Sel		 =	 App2TSSRW-GDT
   3837		  = 00D8		 App1LDT_Sel		 =	 App1LDT-GDT
   3838		  = 0110		 App2LDT_Sel		 =	 App2LDT-GDT
   3839		  = 0130		 DMAData_Sel		 =	 DMADATA-GDT		 ; DMA data segment selector
   3840		  = 0138		 PCode_Sel		 =	 PCode-GDT		 ; 16 bit segment for protect mode
   3841		  = 0150		 IntException_Sel	 =	 IntExceptionDesc-GDT
   3842					 ;----------------------------------------------------------------------------
   3843	    0158  30 31	32 33 34 35 36+	 HexTable	 DB	 '0123456789ABCDEF'
   3844		  37 38	39 41 42 43 44+
   3845		  45 46
   3846	    0168  ????????		 IndexCnt	 DD	 ?
   3847	    016C  41424344		 PrintData	 DD	 'ABCD'
   3848	    0170  0070r			 SizeOf_TSS1	 DW	 App1TSSLen ; length of	the App1TSS seg	is stored here
   3849
   3850					 ;offset:segment
   3851	    0172  0000 0000		 RealJumpAddr	 dw	 0000h,0000h
   3852
   3853	    0176  10*(00)		 LoadArray	 db	 16 dup(0)
   3854					 ;----------------------------------------------------------------------------
   3855	    0186  0157 00000000		 VGDTR		 PDesc	 <GDTLen-1,>  ;	lenght of GDT is initialized, 2	bytes
   3856	    018C  07FF 00000000		 VIDTR		 PDesc	 <IDTLen-1,>
   3857	    0192  03FF 00000000		 NORVIDTR	 PDesc	 <3FFh,>
   3858	    0198  ??			 IMaskRegV	 DB	 ?
   3859	    0199  ????			 SPVar		 DW	 ?
   3860	    019B  ????			 SSVar		 DW	 ?
   3861	    019D  0000			 RERunFlag	 DW	 0000h	     ; This flag remembers that	the app1 ran once
   3862									     ; This flag is used to reinitialize the TSS for APP1 in+
   3863					 RunAppl Module
   3864					 ;----------------------------------------------------------------------------
   3865	    019F  0D 0A	20 20 20 20 20+	 prompt1    DB	13,10,'		 Press any key to continue... ',0
   3866		  20 20	20 20 20 50 72+
   3867		  65 73	73 20 61 6E 79+
   3868		  20 6B	65 79 20 74 6F+
   3869		  20 63	6F 6E 74 69 6E+
   3870		  75 65	2E 2E 2E 20 00
   3871					 ;----------------------------------------------------------------------------
   3872					 ; This	offset is used to print	memory w.r.t base in the desc
   3873					 ; This	should be initialised before calling PRINTMEMP call gate
   3874					 ;		 mov	 eax,ds:[MemPrintOffset]
   3875					 ;		 CALL16	 PrintmemPGate_Sel,0h
   3876					 ;----------------------------------------------------------------------------
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 69
prcycle.ASM



   3877
   3878	    01C9  ????????		 MemPrintOffset		 dd	 ?
   3879	    01CD  00000021		 AnyCounter		 dd	 00000021h ; sector 33 to print	sectors
   3880	    01D1  00			 LoadCounter		 db	 0
   3881	    01D2  00000000		 RunFlag		 dd	 0
   3882	    01D6  00			 MemFlag		 db	 0
   3883	    01D7  00001234		 MemoryOffset		 dd	 1234h	; actual memory	location where the offset is stored
   3884
   3885					 ;----------------------------------------------------------------------------
   3886	    01DB  00000000		 abdtemp		 dd	 0
   3887	    01DF  00000000		 AppGDTPtr		 dd	 0	 ; Temp	variable declared to test the no of GDT	    +
   3888					 entries changed
   3889
   3890					 ;----------------------------------------------------------------------------
   3891	    01E3  00			 FloppyReady		 db	 0
   3892					 ;----------------------------------------------------------------------------
   3893					 ; Keyboard key	map
   3894	    01E4  00 1B	31 32 33 34 35+	 keyTable1 DB 00,1bh,31h,32h,33h,34h,35h,36h,37h,38h,39h,30h,2dh,3dh,08h,09h
   3895		  36 37	38 39 30 2D 3D+
   3896		  08 09
   3897	    01F4  71 77	65 72 74 79 75+		   DB 'q','w','e','r','t','y','u','i','o','p','[',']',0dh,00
   3898		  69 6F	70 5B 5D 0D 00
   3899	    0202  61 73	64 66 67 68 6A+		   DB 'a','s','d','f','g','h','j','k','l',';',27h,'`',00,'\'
   3900		  6B 6C	3B 27 60 00 5C
   3901	    0210  7A 78	63 76 62 6E 6D+		   DB 'z','x','c','v','b','n','m',',','.','/',00,'*',00,' ',00
   3902		  2C 2E	2F 00 2A 00 20+
   3903		  00
   3904	    021F  00 00	00 00 00 00 00+		   DB  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2dh,0,0,0,2Bh,0,0,0,0,0
   3905		  00 00	00 00 00 00 00+
   3906		  00 2D	00 00 00 2B 00+
   3907		  00 00	00 00
   3908	    0238  C8*(00)			   DB  200 dup(0)
   3909					 ; The Following Variables are used by the Keyboard handler
   3910	    0300  00			 ShiftStat	 DB 00
   3911	    0301  00			 CtrlStat	 DB 00
   3912	    0302  00			 AltStat	 DB 00
   3913	    0303  00			 NumLock	 DB 00
   3914	    0304  00			 CapLock	 DB 00
   3915	    0305  00			 ScrLock	 DB 00
   3916	    0306  00			 scan		 DB 00
   3917	    0307  00			 ascii		 DB 00
   3918					 ; Kernel keyboard Que,	the first byte holds the pointer
   3919	    0308  FF*(00)		 KKQ		 DB 255	dup(0)
   3920	    0407  00			 KHead		 DB 0	 ; next	byte
   3921	    0408  00			 KTail		 DB 0	 ; next	available byte
   3922					 ; Memory parameters required in AOA
   3923	    0409  10000000		 MEMLimit	 dd	 10000000h  ; Max Limit	of memory allocation 64MB
   3924	    040D  02000000		 MEMBase	 dd	 02000000h  ; Base start of memory for allocation 32MB
   3925	    0411  0000			 MEMCX		 dw	 0
   3926	    0413  ????????		 APP1TSSAddr	 dd	 ?	    ; This is the address of the task segment
   3927
   3928	    0417  0000			 SLSecNum1mS	 dw	 0
   3929	    0419  0000			 LSize1mS	 dw	 0
   3930	    041B  00000000		 BxP1S		 dd	 0
   3931					 ; user	does Malloc() once and gets total size of memory available and mem ptr
   3932					 ;
   3933					 ;----------------------------------------------------------------------------
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 70
prcycle.ASM



   3934	    041F			 RDataSeg	 ENDS
   3935					 ;***************************************************************************
   3936					 ;RCodeSeg Segment
   3937					 ; 16 bit segment
   3938					 ;  all	real code procedures must be placed in this segment
   3939					 ;***************************************************************************
   3940					 ;
   3941	    0000			 RCodeSeg	 SEGMENT PARA public USE16 'CODE'
   3942							 ASSUME	 CS:RCodeSeg,DS:RDataSeg
   3943					 ;----------------------------------------------------------------------------
   3944					 ; START of prcycle here
   3945					 ; Watch out IDT and 256 interrupts, make sure they are	coded right in the
   3946					 ;   segment, otherwise, LIDT will fail
   3947					 ;----------------------------------------------------------------------------
   3948	    0000			 Start		 PROC
   3949
   3950	    0000  B8 0000s				 mov	 ax,RDataSeg
   3951	    0003  05 0080				 add	 ax,RELOCATE1
   3952	    0006  8E D8					 mov	 ds,ax
   3953	    0008  B0 59					 mov	 al,'Y'
   3954	    000A  B4 0E					 mov	 ah,14
   3955	    000C  CD 10					 int	 10h
   3956
   3957						     ;********************************************************
   3958							 ; get the NIC device address and store	it in shared memory
   3959							 ; this	has to be done only in real mode
   3960						     ;********************************************************
   3961	    000E  B4 B1					 mov ah, 0b1h	 ; function  PCI BIOS p23
   3962	    0010  B0 02					 mov al, 02h	 ; find	PCI device PCI BIOS p23
   3963							 ;3com
   3964							 ;mov cx, 9200h	 ; device id p71
   3965							 ;mov dx, 10b7h	  ; subsystem vendor id	p71
   3966							 ; intel
   3967	    0012  B9 100E				 mov cx, 100eh
   3968	    0015  BA 8086				 mov dx, 8086h
   3969	    0018  BE 0000				 mov si, 0
   3970	    001B  CD 1A					 int 1ah	 ; calls PCI BIOS interrupt
   3971	    001D  72 04					 jc carry1	 ; error
   3972	    001F  32 C9					 xor cl, cl	 ; good
   3973	    0021  EB 02					 jmp next100
   3974	    0023					 carry1:
   3975	    0023  B1 01					 mov cl, 1	 ; cl is 1 or 0
   3976	    0025					 next100:
   3977	    0025  66| 8B C3				 mov eax,ebx;
   3978	    0028  66| C1 E0 10				 sal eax, 16	 ; move	to left
   3979	    002C  8A D9					 mov bl, cl
   3980	    002E  8B C3					 mov ax, bx
   3981							 ; eax has the following data
   3982							 ;----------------------
   3983							 ; BH |	 BL | AH | CL
   3984							 ; bus no | device no in 5 bits	| return code |	0 - success 1 -fail
   3985							 ;----------------------
   3986	    0030  66| C1 F8 10				 sar eax, 16
   3987	    0034  66| BB 00000000			 mov ebx, 0
   3988	    003A  66| 8B D8				 mov ebx, eax	; bh, bl has bus no and	device no
   3989
   3990	    003D  66| B8 00000000			 mov eax, 0
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 71
prcycle.ASM



   3991	    0043  B4 B1					 mov ah, 0b1h  ; function  PCI BIOS p23
   3992	    0045  B0 0A					 mov al, 0ah   ; read config dword p19 PCI
   3993							 ;3com
   3994							 ;mov di, 10h	; offset 10h p/65
   3995							 ; intel
   3996	    0047  BF 0018				 mov di, 18h
   3997	    004A  CD 1A					 int 01ah      ; calls PCI BIOS	interrupt
   3998	    004C  66| 8B C1				 mov eax, ecx
   3999	    004F  66| 81 E1 0000FFFE			 and ecx, 0fffeh	; make the last	bit zero
   4000	    0056  66| 8B C1				 mov eax, ecx		; this is the device address
   4001
   4002	    0059  1E					 push ds
   4003	    005A  66| 50				 push eax
   4004	    005C  B8 0000				 mov ax, 0
   4005	    005F  8E D8					 mov ds, ax
   4006
   4007	    0061  66| BB 00008600			 mov ebx, S_Base
   4008	    0067  66| 81 C3 0000009C			 add ebx, S_IOBASE
   4009	    006E  66| 58				 pop eax
   4010	    0070  66| 67| 89 03				 mov DWORD PTR ds:[ebx], eax  ;	store it in shared memory
   4011	    0074  1F					 pop ds
   4012
   4013							 ;mov eax, 0
   4014							 ;mov eax, DWORD PTR es:[ebx]
   4015							 ;CALL PUTHEX32R ; prints the value in EAX
   4016							 ;mov al, ' ';	  ; print a blank
   4017							 ;mov ah, 14
   4018							 ;int 10h
   4019
   4020							 ;********************************************************
   4021							 ; Store Task Segment of Appliation in memory
   4022							 ; which can be	used by	AO for task switching
   4023	    0075  66| B8 00000000s			 mov	 eax,SEG App1TSSSeg	 ; get the segment addtess of APP1TSSSeg
   4024	    007B  66| 05 00000080			 add	 eax, RELOCATE1
   4025	    0081  66| C1 E0 04				 shl	 eax, 4			 ; then	convert	that into a pointer with the+
   4026					 lower 16 bit offset
   4027	    0085  66| A3 0413r				 mov	 ds:[APP1TSSAddr], eax
   4028							 ;********************************************************
   4029
   4030							 ;KAR_________________________________________________________
   4031							 ;mov	 eax,SEG RDataSeg
   4032							 ;add	 eax,RELOCATE1
   4033							 ;shl	 eax,4
   4034	    0089  66| B8 00000000r			 mov	 eax,OFFSET GDT	 ; Get the offset of GDT starting entry	to be used  +
   4035					 by setand getGDTEntry
   4036	    008F  66| A3 01DFr				 mov	 ds:[AppGDTPtr], eax
   4037							 ;____________________________________________________________
   4038							 EnableA20
1  4039	    0093  50					 push	 ax
1  4040	    0094  E4 92					 in	 al,92h
1  4041	    0096  0C 02					 or	 al,00000010b
1  4042	    0098  E6 92					 out	 92h,al
1  4043	    009A  58					 pop	 ax
   4044	    009B  FC					 cld
   4045
   4046	    009C  E8 00B7				 CALL	 InitGDT
   4047	    009F  E8 0113				 call	 InitIDT
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 72
prcycle.ASM



   4048
   4049	    00A2  8C 16	019Br				 mov	 SSVar,ss
   4050	    00A6  89 26	0199r				 mov	 SPVar,sp
   4051	    00AA  0F 01	0E 0192r			 sidt	 QWORD PTR NORVIDTR
   4052	    00AF  E4 21					 in	 al,IMREGP
   4053	    00B1  A2 0198r				 mov	 BYTE PTR IMaskRegV,al
   4054
   4055	    00B4  B8 0000s				 mov	 ax,App1LDTSeg ; APP1 LDT Seg Address
   4056	    00B7  05 0080				 add	 ax, RELOCATE1 ; add relocate
   4057	    00BA  8E E0					 mov	 fs,ax	       ; fs has	the LDT	Segment
   4058	    00BC  B9 0007				 mov	 cx,App1LDNum  ; no of entries to be loaded in LDT
   4059	    00BF  BE 0000r				 mov	 si,OFFSET ALDT; offset	of first entry
   4060
   4061	    00C2  E8 00D5				 CALL	 InitLDT       ; load APP1 LDT entries
   4062					 ;------------------------------------------------------
   4063					 ; add RELOCATE1 as the	booter located this code at
   4064					 ; a different location, for example at	0800h
   4065					 ; so the segment value	in that	case is	at 80h
   4066					 ;------------------------------------------------------
   4067	    00C5  B8 0000s				 mov	 ax,GKeyLDTSeg
   4068	    00C8  05 0080				 add	 ax, RELOCATE1
   4069	    00CB  8E E0					 mov	 fs,ax
   4070	    00CD  B9 0002				 mov	 cx,GKeyLDNum
   4071	    00D0  BE 0000r				 mov	 si,OFFSET GLDT
   4072
   4073	    00D3  E8 00C4				 CALL	 InitLDT
   4074					 ;------------------------------------------------------
   4075	    00D6  B8 0000s				 mov	 ax,GetCharLDTSeg
   4076	    00D9  05 0080				 add	 ax, RELOCATE1
   4077	    00DC  8E E0					 mov	 fs,ax
   4078	    00DE  B9 0002				 mov	 cx,GetCharLDNum
   4079	    00E1  BE 0000r				 mov	 si,OFFSET CLDT
   4080
   4081	    00E4  E8 00B3				 CALL	 InitLDT
   4082					 ;------------------------------------------------------
   4083	    00E7  B8 0000s				 mov	 ax,GetDecLDTSeg
   4084	    00EA  05 0080				 add	 ax, RELOCATE1
   4085	    00ED  8E E0					 mov	 fs,ax
   4086	    00EF  B9 0002				 mov	 cx,GetDecLDNum
   4087	    00F2  BE 0000r				 mov	 si,OFFSET DLDT
   4088
   4089	    00F5  E8 00A2				 CALL	 InitLDT
   4090					 ;------------------------------------------------------
   4091	    00F8  B8 0000s				 mov	 ax,GetSecLDTSeg
   4092	    00FB  05 0080				 add	 ax, RELOCATE1
   4093	    00FE  8E E0					 mov	 fs,ax
   4094	    0100  B9 0002				 mov	 cx,GetSecLDNum
   4095	    0103  BE 0000r				 mov	 si,OFFSET KLDT
   4096
   4097	    0106  E8 0091				 CALL	 InitLDT
   4098					 ;------------------------------------------------------
   4099	    0109  B8 0000s				 mov	 ax,DemoLDTSeg
   4100	    010C  05 0080				 add	 ax, RELOCATE1
   4101	    010F  8E E0					 mov	 fs,ax
   4102	    0111  BE 0000r				 mov	 si,OFFSET DemoLDT
   4103	    0114  B9 000C				 mov	 cx,DemoLDNum
   4104	    0117  E8 0080				 CALL	 InitLDT
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 73
prcycle.ASM



   4105					 ;------------------------------------------------------
   4106	    011A  B8 0000s				 mov	 ax,SearchLDTSeg
   4107	    011D  05 0080				 add	 ax, RELOCATE1
   4108	    0120  8E E0					 mov	 fs,ax
   4109	    0122  BE 0000r				 mov	 si,OFFSET SEARCHLDTS
   4110	    0125  B9 0004				 mov	 cx,SearchLDNum
   4111	    0128  E8 006F				 CALL	 InitLDT
   4112
   4113					 ;------------------------------------------------------
   4114					 ; GDT table must be located in	real memory
   4115					 ;  we tried to	place it at 0200 0000 and we were
   4116					 ;  not	able to	change the Base	value in GDTR
   4117					 ; setup all GDT related things	before switching to
   4118					 ;  protected mode 4-9-04
   4119					 ;------------------------------------------------------
   4120	    012B  0F 01	16 0186r			 lgdt	 QWORD PTR VGDTR ;load GDT reg
   4121
   4122
   4123					 ; 6 byte VGDTR	is loaded into visible part of the GDTR	registerr
   4124					 ; The contents	of VGDTR was set up by InitGDT call
   4125					 ;------------------------------------------------------
   4126	    0130  FA					 cli
   4127	    0131  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4128	    0136  0F 20	C0				 mov	 eax,cr0
   4129	    0139  0C 01					 or	 al,1
   4130	    013B  0F 22	C0				 mov	 cr0,eax   ; turn on prot mode bit
   4131					 ;----------------------------------------------------------
   4132							 JUMP16	 <TempCode_Sel>,<OFFSET	Virtual> ; I
1  4133	    013E  EA					 DB	 0eah
1  4134	    013F  01EBr					 DW	 OFFSET	Virtual
1  4135	    0141  0030					 DW	 TempCode_Sel
   4136					 ;----------------------------------------------------------
   4137					 ;This jump is required	to switch to protection	mode
   4138					 ; It will load	CS and EIP values during this long jump
   4139					 ; It uses TempCode_Sel	descriptor to jump
   4140					 ; You will not	go below this step until you return from
   4141					 ; protection mode to exit from	the program
   4142					 ;------------------------------------------------------
   4143
   4144	    0143  B8 0000s		 Real:		 mov	 ax,RDataSeg
   4145	    0146  05 0080				 add	 ax, RELOCATE1
   4146	    0149  8E D8					 mov	 ds,ax
   4147	    014B  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4148	    0150  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4149	    0155  FB					 sti
   4150
   4151	    0156			 Start		 ENDP
   4152					 ;***************************************************************************
   4153					 ;InitGDT Procedure
   4154					 ;  Initialize all GDT entries
   4155					 ;***************************************************************************
   4156
   4157	    0156			 InitGDT	 PROC
   4158	    0156  B9 0028				 mov	 cx,GDNum ; no of entries to be	loaded into GDT	ex 28
   4159	    0159  BE 0018r				 mov	 si,OFFSET EFFGDT ;starting location of	first entry
   4160
   4161
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 74
prcycle.ASM



   4162
   4163	    015C  B8 0000		 InitG:		 mov	 ax,0
   4164	    015F  8A 64	07				 mov	 ah, BYTE PTR[si].BaseH
   4165	    0162  8A 44	04				 mov	 al, BYTE PTR[si].BaseM
   4166	    0165  3D 0000				 cmp	 ax,0
   4167	    0168  75 19					 JNZ	 SKIPCHANGE
   4168	    016A  8B 44	02				 mov	 ax,[si].BaseL
   4169	    016D  66| 0F B7 C0				 movzx	 eax,ax
   4170	    0171  66| C1 E0 04				 shl	 eax,4
   4171	    0175  66| 0F A4 C2 10			 shld	 edx,eax,16   ;	0002 --> 0200 8	bytes alltogether
   4172	    017A  89 44	02				 mov	 WORD PTR [si].BaseL,ax	; 2 bytes
   4173	    017D  88 54	04				 mov	 BYTE PTR [si].BaseM,dl	; 1 byte
   4174	    0180  88 74	07				 mov	 BYTE PTR [si].BaseH,dh	; 1 byte
   4175
   4176
   4177	    0183  83 C6	08		 SKIPCHANGE:	 add	 si,SIZE Desc
   4178	    0186  E2 D4					 loop	 InitG
   4179
   4180	    0188  BA 0000				 mov	 dx,0h
   4181	    018B  BB 0010				 mov	 bx,16
   4182	    018E  8C D8					 mov	 ax,ds
   4183	    0190  F7 E3					 mul	 bx
   4184	    0192  A3 0188r				 mov	 WORD PTR VGDTR.Base,ax	; lower	2 byte GDT base	address	is stored in+
   4185					 VGDTR 4eb0
   4186	    0195  89 16	018Ar				 mov	 WORD PTR VGDTR.Base+2,dx ; higher 2 byte GDT base address is stored+
   4187					 in VGDTR 0000
   4188	    0199  C3					 ret
   4189	    019A			 InitGDT	 ENDP
   4190					 ;***************************************************************************
   4191					 ;InitLDT Procedure
   4192					 ;  Initialize all LDT entries
   4193					 ;  rearraning the BaseL bytes
   4194					 ; It does not modify BaseH and	BaseM
   4195					 ; It is also rearranging the bytes in the same	segment	in memory
   4196					 ; It does not modify BaseH and	BaseM
   4197					 ; It is also rearranging the bytes in the same	segment	in memory
   4198					 ;***************************************************************************
   4199	    019A			 InitLDT	 PROC
   4200	    019A  64: 8B 44 02		 ILDT:		 mov	 ax,WORD PTR FS:[si].BaseL
   4201	    019E  66| 0F B7 C0				 movzx	 eax,ax
   4202	    01A2  66| C1 E0 04				 shl	 eax,4
   4203	    01A6  66| 0F A4 C2 10			 shld	 edx,eax,16
   4204	    01AB  64: 89 44 02				 mov	 WORD PTR fs:[si].BaseL,ax
   4205							 ;the following	two lines insert 0s in BaseM and BaseH
   4206							 ;  base L is shifted because we only put one digit less in this field
   4207							 ; inorder to use above	1M we should comment the following two lines
   4208						 ;	 mov	 BYTE PTR fs:[si].BaseM,dl
   4209						 ;	 mov	 BYTE PTR fs:[si].BaseH,dh
   4210	    01AF  83 C6	08				 add	 si,SIZE Desc
   4211	    01B2  E2 E6					 loop	 ILDT
   4212	    01B4  C3					 ret
   4213	    01B5			 InitLDT	 ENDP
   4214					 ;***************************************************************************
   4215					 ;InitIDT Procedure
   4216					 ; Initialize all interrupt descriptor table entries
   4217					 ;***************************************************************************
   4218	    01B5			 InitIDT	 PROC
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 75
prcycle.ASM



   4219	    01B5  BB 0010				 mov	 bx,16
   4220	    01B8  B8 0000s				 mov	 ax, IDTSeg
   4221	    01BB  05 0080				 add	 ax, RELOCATE1
   4222	    01BE  F7 E3					 mul	 bx
   4223	    01C0  A3 018Er				 mov	 WORD PTR VIDTR.Base,ax
   4224
   4225					 ;-----------------------------------------------------------------------------
   4226					 ; This	part of	the code stores	the absolute address of	IDT in shared memory
   4227
   4228	    01C3  66| 53				 push	 ebx
   4229						 ;RKK COMMENT EXTRA PUSH
   4230							 ;push	 es
   4231	    01C5  66| 50				 push	 eax
   4232
   4233	    01C7  66| BB 00000000			 mov	 ebx,0
   4234	    01CD  B8 8600				 mov	 ax, S_Base
   4235	    01D0  05 000C				 add	 ax, S_IDTOffset
   4236	    01D3  8B D8					 mov	 bx ,ax
   4237	    01D5  B8 0000				 mov	 ax, 0
   4238	    01D8  8E C0					 mov	 es, ax
   4239	    01DA  66| 58				 pop	 eax
   4240	    01DC  26: 67| 89 03				 mov	 WORD PTR es:[ebx], ax
   4241	    01E0  26: 67| 8B 03				 mov	 ax, WORD PTR es:[ebx]
   4242	    01E4  66| 5B				 pop	 ebx
   4243					 ;-----------------------------------------------------------------------------
   4244	    01E6  89 16	0190r				 mov	 WORD PTR VIDTR.Base+2,dx
   4245	    01EA  C3					 ret
   4246	    01EB			 InitIDT	 ENDP
   4247					 ;***************************************************************************
   4248					 ;Virtual Procedure
   4249					 ;  entry point	to protected mode
   4250					 ;***************************************************************************
   4251					 ;  I.	It is invoked from real	mode after mode	bit is set as a	long jump
   4252					 ;  This is the	first stage after protected mode bit is	set
   4253					 ;
   4254	    01EB			 Virtual	 PROC	 FAR
   4255	    01EB  B8 0020				 mov	 ax,DemoTSS_Sel
   4256	    01EE  0F 00	D8				 ltr	 ax  ; load task register
   4257	    01F1  B8 0028				 mov	 ax,DemoLDT_Sel	; load LDTR register
   4258	    01F4  0F 00	D0				 lldt	 ax
   4259					 ;--------------------------------------------------------------------
   4260							 JUMP16	 ToT32A_Sel,0	 ;II. Jump to Prot Mode	Seg
1  4261	    01F7  EA					 DB	 0eah
1  4262	    01F8  0000					 DW	 0
1  4263	    01FA  0064					 DW	 ToT32A_Sel
   4264										 ; T32Code_Sel and T32Begin
   4265					 ;--------------------------------------------------------------------
   4266					 ; This	jump is	from 16	bit to 32 bit segments using a call gate
   4267					 ; once	this jump occurs, then you are in 32 bit protected mode
   4268					 ; The following step will not be reached from here
   4269					 ;--------------------------------------------------------------------
   4270					 ;  V. The following code will be executed when	the program returns
   4271					 ;    from protected mode on its way to	real mode
   4272					 ;    this is at 16 bit	protected mode
   4273					 ;    application calls	can be made
   4274					 ;--------------------------------------------------------------------
   4275	    01FC			 ToReal:
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 76
prcycle.ASM



   4276	    01FC			 loop1:				  ;interrupt takes us to AoA menu and
   4277	    01FC  FB					 sti
   4278
   4279	    01FD  CD FF					 int	 0ffh	  ; go to menu interrupt
   4280	    01FF  66| BB 00000F9E			 mov	 ebx,3998
   4281	    0205  B0 50					 mov	 al,'P'
   4282	    0207  CD F7					 int	 0f7h
   4283
   4284	    0209  B8 0054				 mov	 ax,RealData_Sel
   4285	    020C  8E E0					 mov	 fs,ax
   4286
   4287	    020E  64: 80 3E 01D6r 05			 cmp	 fs:[MemFlag], 5
   4288	    0214  74 44					 je	 GoSearch
   4289
   4290	    0216  64: 80 3E 01D6r 01			 cmp	 fs:[MemFlag],1
   4291	    021C  74 46					 je	 PrintMemory
   4292
   4293	    021E  64: 80 3E 0000e 01			 cmp	 fs:[LoadFlag],1
   4294	    0224  75 2F					 jne	 RunApplications
   4295
   4296	    0226			 LoadApplications:
   4297	    0226  E8 045A				 CALL	 InitLoad
   4298							 ;--------------------------------------------------------
   4299	    0229  06					 push	 es
   4300							 ; save	start sector, number of	sectors	and address offset
   4301	    022A  B8 0054				 mov	 ax,RealData_Sel
   4302	    022D  8E C0					 mov	 es,ax
   4303
   4304	    022F  66| B8 00000000			 mov	 eax, 0
   4305	    0235  26: A1 0000e				 mov	 ax, es:[StartLogicalSecNum1m] ; start sector
   4306	    0239  26: A3 0417r				 mov	 es:[SLSecNum1mS], ax
   4307
   4308	    023D  26: A1 0000e				 mov	 ax, es:[LoaderSize1m] ; number	of sectors
   4309	    0241  26: A3 0419r				 mov	 es:[LSize1mS],	ax
   4310
   4311	    0245  66| 26: A1 0000e			 mov	 eax, es:[BxPointer1] ;	address	offset
   4312	    024A  66| 26: A3 041Br			 mov	 es:[BxP1S], eax
   4313
   4314	    024F  07					 pop	 es
   4315							 ;--------------------------------------------------------
   4316
   4317	    0250  E8 0303				 CALL	 ReadSectorsAll	; read all sectors if flag is set
   4318										; loads	application disk into memory
   4319	    0253  EB A7					 jmp	 loop1
   4320	    0255			 RunApplications:
   4321							 ;---------------------------------------------
   4322							 ;KAR Sample to	test if	the GDT	can be moved to	Data Segment of	APP
   4323							 ; APP1TSSAddr location	has the	address	of App1TSS segment
   4324							 ;KAREND
   4325							 ;---------------------------------------------
   4326
   4327	    0255  E8 048D				 CALL	 RunAppl
   4328	    0258  EB 20					 jmp	 GoBackToLoop
   4329	    025A			 GoSearch:
   4330	    025A  CD F8					 int	 0f8h
   4331	    025C  64: C6 06 01D6r 00			 mov	 fs:[MemFlag], 0
   4332	    0262  EB 98					 jmp	 loop1
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 77
prcycle.ASM



   4333
   4334	    0264			 PrintMemory:
   4335	    0264  66| B8 00000000			 mov	 eax,0
   4336	    026A  66| 64: A1 01D7r			 mov	 eax,fs:[MemoryOffset] ; memory	dump option 9
   4337							 CALL16	 PrintmemPGate_Sel,0h
1  4338	    026F  9A					 DB	 9ah
1  4339	    0270  0000					 DW	 0h
1  4340	    0272  0084					 DW	 PrintmemPGate_Sel
   4341	    0274  64: 80 26 01D6r 00			 and	 fs:[MemFlag],0
   4342	    027A			 GoBackToLoop:
   4343					 ;--------------------------------------------------------------------
   4344						 JUMP16	 ToT32A_Sel,0	 ;  II.	Jump to	Protected Mode Seg
1  4345	    027A  EA					 DB	 0eah
1  4346	    027B  0000					 DW	 0
1  4347	    027D  0064					 DW	 ToT32A_Sel
   4348									 ; T32Code_Sel and T32Begin
   4349					 ;--------------------------------------------------------------------
   4350					 ; Steps II and	V are our P-R cycle loop
   4351					 ; Step	II takes it to protected mode and when it is done it
   4352					 ; comes back to step V.
   4353					 ;--------------------------------------------------------------------
   4354					 ;--------------------------------------------------------------------
   4355					 ;We would never go beyond this	point unless we	comment	P-R cycle loop
   4356					 ;By doing so you would	return to real mode and	print 'Z'
   4357					 ;--------------------------------------------------------------------
   4358	    027F  B8 0008				 mov	 ax,Normal_Sel
   4359	    0282  8E D8					 mov	 ds,ax
   4360	    0284  8E C0					 mov	 es,ax
   4361	    0286  8E E0					 mov	 fs,ax
   4362	    0288  8E E8					 mov	 gs,ax
   4363	    028A  8E D0					 mov	 ss,ax
   4364
   4365							 ;cli
   4366	    028C  0F 20	C0				 mov	 eax,cr0
   4367	    028F  24 FE					 and	 al,11111110b
   4368	    0291  0F 22	C0				 mov	 cr0,eax
   4369							 JUMP16	 <SEG Real+RELOCATE1>,<OFFSET Real>
1  4370	    0294  EA					 DB	 0eah
1  4371	    0295  0143r					 DW	 OFFSET	Real
1  4372	    0297  0080s					 DW	 SEG Real+RELOCATE1
   4373
   4374	    0299			 Virtual	 ENDP
   4375					 ;***************************************************************************
   4376					 ;GetCharBegin Procedure
   4377					 ;***************************************************************************
   4378	    0299			 GetCharBegin	 PROC	 FAR
   4379
   4380
   4381	    0299  1E					 push	 ds
   4382	    029A  06					 push	 es
   4383	    029B  0F A0					 push	 fs
   4384	    029D  0F A8					 push	 gs
   4385	    029F  B8 0008				 mov	 ax,Normal_Sel
   4386	    02A2  8E D0					 mov	 ss,ax
   4387	    02A4  0F 20	C0				 mov	 eax,cr0
   4388	    02A7  24 FE					 and	 al,11111110b
   4389	    02A9  0F 22	C0				 mov	 cr0,eax     ; set the control register
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 78
prcycle.ASM



   4390							 JUMP16	 <Seg GetChar+RELOCATE1>,<OFFSET GetChar>  ;SWITCH TO REAL MODE
1  4391	    02AC  EA					 DB	 0eah
1  4392	    02AD  02B1r					 DW	 OFFSET	GetChar
1  4393	    02AF  0080s					 DW	 Seg GetChar+RELOCATE1
   4394
   4395	    02B1			 GetChar:
   4396	    02B1  B8 0000s				 mov	 ax,RDataSeg
   4397	    02B4  05 0080				 add	 ax, RELOCATE1
   4398	    02B7  8E D8					 mov	 ds,ax
   4399	    02B9  66| 8B EC				 mov	 ebp,esp
   4400	    02BC  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4401	    02C1  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4402	    02C6  FB					 sti
   4403
   4404					 ;------------------------------------------------------------------------
   4405					 ;We are returned to RealMode from ProtMode include all	RMode code here...
   4406					 ;------------------------------------------------------------------------
   4407	    02C7  B8 0000s				 mov	 ax,GlobalDataSeg
   4408	    02CA  05 0080				 add	 ax,RELOCATE1
   4409	    02CD  8E E0					 mov	 fs,ax
   4410	    02CF			 GetChar1:
   4411
   4412	    02CF  B4 10					 mov	 ah,10h
   4413	    02D1  CD 16					 int	 16h	 ;bios interrupt to get	char from console
   4414
   4415					 ;------------------------------------------------------------------------
   4416					 ;To display character at the same position
   4417					 ;------------------------------------------------------------------------
   4418	    02D3  B4 0E					 mov	 ah,14
   4419	    02D5  CD 10					 int	 10h	 ; to display the char at the same position
   4420
   4421	    02D7  64: A2 000Br				 mov	 fs:[StoreChar],al
   4422							 ;cli					  ;SWITCH TO PM
   4423
   4424	    02DB  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4425	    02E0  0F 20	C0				 mov	 eax,cr0
   4426	    02E3  0C 01					 or	 al,1
   4427	    02E5  0F 22	C0				 mov	 cr0,eax
   4428
   4429							 JUMP16	 <GetCharCode_Sel>,<OFFSET GetCharV> ;TO PROTECTED MODE
1  4430	    02E8  EA					 DB	 0eah
1  4431	    02E9  02EDr					 DW	 OFFSET	GetCharV
1  4432	    02EB  0004					 DW	 GetCharCode_Sel
   4433
   4434	    02ED			 GetCharV:
   4435	    02ED  B8 000C				 mov	 ax,GetCharStack_Sel
   4436	    02F0  8E D0					 mov	 ss,ax
   4437	    02F2  66| 8B E5				 mov	 esp,ebp
   4438	    02F5  0F A9					 pop	 gs
   4439	    02F7  0F A1					 pop	 fs
   4440	    02F9  07					 pop	 es
   4441	    02FA  1F					 pop	 ds
   4442
   4443	    02FB  66| CF				 iretd
   4444	    02FD  EB 9A					 jmp	 GetCharBegin
   4445	    02FF			 GetCharBegin	    ENDP
   4446					 ;***************************************************************************
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 79
prcycle.ASM



   4447					 ;GetDecBegin Procedure
   4448					 ;***************************************************************************
   4449	    02FF			 GetDecBegin	PROC	FAR
   4450	    02FF  1E					 push	 ds
   4451	    0300  06					 push	 es
   4452	    0301  0F A0					 push	 fs
   4453	    0303  0F A8					 push	 gs
   4454	    0305  B8 0008				 mov	 ax,Normal_Sel
   4455	    0308  8E D0					 mov	 ss,ax
   4456	    030A  0F 20	C0				 mov	 eax,cr0
   4457	    030D  24 FE					 and	 al,11111110b
   4458	    030F  0F 22	C0				 mov	 cr0,eax
   4459
   4460							 JUMP16	 <Seg GetDec+RELOCATE1>,<OFFSET	GetDec>	 ;SWITCH TO REAL MODE
1  4461	    0312  EA					 DB	 0eah
1  4462	    0313  0317r					 DW	 OFFSET	GetDec
1  4463	    0315  0080s					 DW	 Seg GetDec+RELOCATE1
   4464	    0317			 GetDec:
   4465
   4466	    0317  B8 0000s				 mov	 ax,RDataSeg
   4467	    031A  05 0080				 add	 ax, RELOCATE1
   4468	    031D  8E D8					 mov	 ds,ax
   4469	    031F  66| 8B EC				 mov	 ebp,esp
   4470	    0322  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4471	    0327  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4472	    032C  FB					 sti
   4473					 ;------------------------------------------------------------------------
   4474					 ;We are returned to RealMode from ProtMode include all	RMode code here...
   4475					 ;------------------------------------------------------------------------
   4476	    032D  B8 0000s				 mov	 ax,GlobalDataSeg
   4477	    0330  05 0080				 add	 ax,RELOCATE1
   4478	    0333  8E E0					 mov	 fs,ax
   4479	    0335			 GetDec1:
   4480	    0335  66| 53				 PUSH	 EBX
   4481	    0337  66| 51				 PUSH	 ECX
   4482	    0339  66| 33 DB				 XOR	 EBX,EBX	 ; EBX=0
   4483	    033C  66| B9 0000000A			 MOV	 ECX,0ah	 ; ECX=10
   4484	    0342			 GetNextDigit_getint:
   4485	    0342  B4 10					 MOV	 AH, 10h	 ; function 10h: Waits for keyboard input
   4486	    0344  CD 16					 INT	 16h		 ; get input from keyboard
   4487
   4488	    0346  66| 50				 PUSH	 EAX		 ; displays "char-by-char"
   4489	    0348  B4 0E					 mov	 ah,14		 ; the integer being input by user
   4490	    034A  CD 10					 int	 10h
   4491	    034C  66| 58				 POP	 EAX
   4492
   4493	    034E  66| 53				 push	 ebx
   4494	    0350  2C 30					 SUB	 AL,'0'		 ; ASCII[0..9] -> DIGIT[0..9]
   4495	    0352  8A D8					 mov	 bl, al
   4496	    0354  66| 33 C0				 xor	 eax,eax
   4497	    0357  8A C3					 mov	 al, bl
   4498	    0359  3C 0D					 cmp	 al, 0dh
   4499	    035B  74 18					 je	 exit_getint32
   4500	    035D  66| 5B				 pop	 ebx
   4501
   4502						 ; CL holds integer "10", when encounter either	"return"
   4503						 ; or other characters all cause mov ax, bx
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 80
prcycle.ASM



   4504
   4505	    035F  3A C1					 CMP	 AL,CL
   4506	    0361  73 0A					 JAE	 NotDigit_getint ; if there is new integer from	keyboard, SWAP AX,BX
   4507
   4508	    0363  66| 93				 xchg	 ebx, eax
   4509	    0365  66| F7 E1				 MUL	 ECX		 ; EAX=EAX*10
   4510	    0368  66| 03 D8				 add	 ebx, eax
   4511	    036B  EB D5					 JMP	 GetNextDigit_getint
   4512	    036D			 NotDigit_getint:
   4513	    036D  66| 8B C3				 mov	 eax, ebx
   4514	    0370  66| 64: A3 000Cr			 mov	 fs:[StoreDec],eax
   4515							 ; store the read integer value	in real	memory segment
   4516							 ;   where data	is stored
   4517
   4518	    0375			 exit_getint32:
   4519	    0375  66| 59				 POP	 ECX
   4520	    0377  66| 5B				 POP	 EBX
   4521
   4522							 ;cli					  ;SWITCH TO PM
   4523	    0379  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4524	    037E  0F 20	C0				 mov	 eax,cr0
   4525	    0381  0C 01					 or	 al,1
   4526	    0383  0F 22	C0				 mov	 cr0,eax
   4527
   4528							 JUMP16	 <GetDecCode_Sel>,<OFFSET GetDecV> ;TO PROTECTED MODE
1  4529	    0386  EA					 DB	 0eah
1  4530	    0387  038Br					 DW	 OFFSET	GetDecV
1  4531	    0389  0004					 DW	 GetDecCode_Sel
   4532
   4533	    038B			 GetDecV:
   4534	    038B  B8 000C				 mov	 ax,GetDecStack_Sel
   4535	    038E  8E D0					 mov	 ss,ax
   4536	    0390  66| 8B E5				 mov	 esp,ebp
   4537	    0393  0F A9					 pop	 gs
   4538	    0395  0F A1					 pop	 fs
   4539	    0397  07					 pop	 es
   4540	    0398  1F					 pop	 ds
   4541	    0399  66| CF				 iretd
   4542	    039B  E9 FF61				 jmp	 GetDecBegin
   4543	    039E			 GetDecBegin	   ENDP
   4544					 ;***************************************************************************
   4545					 ;GKeyBegin Procedure
   4546					 ;***************************************************************************
   4547	    039E			 GKeyBegin	 PROC	 FAR
   4548
   4549	    039E  1E					 push	 ds
   4550	    039F  06					 push	 es
   4551	    03A0  0F A0					 push	 fs
   4552	    03A2  0F A8					 push	 gs
   4553					 ;********************************************
   4554					 ;printing in protected	mode and getting a charectar in	Pmode.
   4555					 ;		 mov	 eax,0h
   4556					 ;		 mov	 eax,12345678h
   4557					 ;		 mov	 ebx,800h	 ;display position on screen
   4558					 ;		 int	 0fdh		 ;PUTHEX32P interrupt gate
   4559					 ;		 int	 0fch		 ;get charectar	from keyboard interrupt	gate
   4560					 ;********************************************
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 81
prcycle.ASM



   4561
   4562	    03A4  B8 0008				 mov	 ax,Normal_Sel
   4563	    03A7  8E D0					 mov	 ss,ax
   4564	    03A9  0F 20	C0				 mov	 eax,cr0
   4565	    03AC  24 FE					 and	 al,11111110b
   4566	    03AE  0F 22	C0				 mov	 cr0,eax
   4567					 ;************************************************
   4568					 ; when	we jump	from protected mode to real mode,
   4569					 ;   we	should keep CS value 0000h and place the
   4570					 ;   offset in the jump, otherwise, in real mode
   4571					 ; if CS value is not zero, we could have problems
   4572					 ;   with calls	and other stuff
   4573					 ; this	assumes	that in	real mode, we will stay	within
   4574					 ;    one segment that is, 64k code
   4575					 ;************************************************
   4576	    03B1  B8 0000s				 mov	 ax,RDataSeg	  ; set	up dataseg
   4577	    03B4  05 0080				 add	 ax, RELOCATE1
   4578	    03B7  8E D8					 mov	 ds,ax
   4579					 ; we do not use this jump as we need to set CS	to 0h
   4580					 ;CS and IP will be loaded with	the below jump
   4581					 ;		 JUMP16	 <Seg GetKey+RELOCATE1>,<OFFSET	GetKey>	 ;SWITCH TO REAL MODE
   4582					 ; compute the address to be jumped in real mode as follows
   4583					 ;
   4584	    03B9  66| B8 00000000			 mov	 eax,0h
   4585	    03BF  B8 0000s				 mov	 ax,seg	Getkey ; segment value
   4586	    03C2  C1 E0	04				 shl	 ax,4	       ; shift left 4 bits
   4587	    03C5  05 0800				 add	 ax,800h       ; start of code for real	code 600+200 PSP
   4588	    03C8  05 03D2r				 add	 ax,offset GetKey ; offset for this label within real code
   4589	    03CB  A3 0172r				 mov	 [RealJumpAddr],ax ; store the value in	real data segment
   4590	    03CE  FF 2E	0172r				 JMP	 dword ptr [RealJumpAddr] ; long jump CS:IP
   4591	    03D2			 GetKey:
   4592
   4593	    03D2  66| 8B EC				 mov	 ebp,esp
   4594	    03D5  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4595	    03DA  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4596	    03DF  FB					 sti
   4597					 ;------------------------------------------------------------------------
   4598					 ;We are returned to RealMode from ProtMode include all	RMode code here...
   4599					 ;------------------------------------------------------------------------
   4600	    03E0			 GetKey1:
   4601
   4602	    03E0  66| BE 0000019Fr			 mov	 esi,offset prompt1
   4603	    03E6  E8 0000e				 call	 WriteString
   4604	    03E9  B4 10					 mov	 ah,10h
   4605	    03EB  CD 16					 int	 16h
   4606
   4607	    03ED  E8 0000e				 call	 AOADisp
   4608
   4609							 ;cli					  ;SWITCH TO PM
   4610	    03F0  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4611	    03F5  0F 20	C0				 mov	 eax,cr0
   4612	    03F8  0C 01					 or	 al,1
   4613	    03FA  0F 22	C0				 mov	 cr0,eax
   4614							 JUMP16	 <GKeyCode_Sel>,<OFFSET	GetKeyV> ;TO PROTECTED MODE
1  4615	    03FD  EA					 DB	 0eah
1  4616	    03FE  0402r					 DW	 OFFSET	GetKeyV
1  4617	    0400  0004					 DW	 GKeyCode_Sel
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 82
prcycle.ASM



   4618	    0402  B8 000C		 GetKeyV:	 mov	 ax,GKeyStack_Sel
   4619	    0405  8E D0					 mov	 ss,ax
   4620	    0407  66| 8B E5				 mov	 esp,ebp
   4621
   4622
   4623	    040A  0F A9					 pop	 gs
   4624	    040C  0F A1					 pop	 fs
   4625	    040E  07					 pop	 es
   4626	    040F  1F					 pop	 ds
   4627	    0410  66| CF				 iretd
   4628	    0412  EB 8A					 jmp	 GKeyBegin
   4629	    0414			 GKeyBegin	 ENDP
   4630					 ;***************************************************************************
   4631					 ;GetSecBegin Procedure
   4632					 ;  comes here from a protected	mode through interrupt 0fah
   4633					 ;  0fah is used to read one sector from disk and store	it
   4634					 ;    in a buffer at 8400h
   4635					 ; this	buffer data in memory can be copied to other locations
   4636					 ;   above 1M using RDWTMEM routine
   4637					 ;***************************************************************************
   4638	    0414			 GetSecBegin	 PROC	 FAR
   4639
   4640	    0414  1E					 push	 ds
   4641	    0415  06					 push	 es
   4642	    0416  0F A0					 push	 fs
   4643	    0418  0F A8					 push	 gs
   4644							 ;-----------------------------------------------------------
   4645							 ;Checks for the StartSecNo in the shared memory if it is -1 its loaded	from+
   4646					 StartSecNum1m
   4647							 ;Else it is loaded from the shared memory location
   4648							 ;-----------------------------------------------------------
   4649	    041A  B8 00C0				 mov	 ax,MEMData_Sel; zero selector
   4650	    041D  8E C0					 mov	 es,ax	       ; es has	zero selector
   4651	    041F  66| BB 00008600			 mov	 ebx,S_Base    ; 8600h for shared mem
   4652	    0425  66| 83 C3 04				 add	 ebx,S_SectorNo	; offset of the	sectorno in shared mem
   4653	    0429  26: 67| 8B 03				 mov	 ax, WORD PTR es:[ebx] ; read shared mem for sectorno
   4654	    042D  3D FFFF				 cmp	 ax,-1	       ; check if it is	-1, menu loading will set this to -1
   4655	    0430  74 16					 je	 LoadOneSecForMenu ; yes, it is	-1, then goto process
   4656							 ; no, this load is for	an application,	who stores sector no in	S_SectorNo
   4657	    0432  B8 0018				 mov	 ax,RData_Sel  ; RDataSeg
   4658	    0435  8E E0					 mov	 fs,ax	       ; fs has	RDAtaSeg to refer to Start...
   4659	    0437  64: A1 0000e				 mov	 ax, WORD PTR fs:[StartLogicalSecNum1m]
   4660	    043B  26: 67| 89 43	02			 mov	 WORD PTR es:[ebx+2], ax ; store this value in shared mem temporarily
   4661	    0440  26: 67| 8B 03				 mov	 ax, WORD PTR es:[ebx];	read the sectorno placed by the	application
   4662	    0444  64: A3 0000e				 mov	 WORD PTR fs:[StartLogicalSecNum1m],ax ; store this in		    +
   4663					 StartLogicalSecNum1m
   4664							 ;in both cases	the starting sector number is stored in	StartLogicalSecNum1m
   4665							 ; normal stack	pointer
   4666
   4667	    0448			 LoadOneSecForMenu:
   4668							 ;Actual interrupt code	starts here
   4669	    0448  B8 0008				 mov	 ax,Normal_Sel
   4670	    044B  8E D0					 mov	 ss,ax
   4671
   4672							 ;turn off the CR0 bit for protected mode
   4673	    044D  0F 20	C0				 mov	 eax,cr0
   4674	    0450  24 FE					 and	 al,11111110b
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 83
prcycle.ASM



   4675	    0452  0F 22	C0				 mov	 cr0,eax
   4676
   4677							 JUMP16	 <Seg GetSec+RELOCATE1>,<OFFSET	GetSec>	 ;SWITCH TO REAL MODE
1  4678	    0455  EA					 DB	 0eah
1  4679	    0456  045Ar					 DW	 OFFSET	GetSec
1  4680	    0458  0080s					 DW	 Seg GetSec+RELOCATE1
   4681	    045A  B8 0000s		 GetSec:	 mov	 ax,RDataSeg				 ; in real mode	now
   4682	    045D  05 0080				 add	 ax, RELOCATE1	       ;RdataSeg is located w.r.t 800h or RELOCATE1
   4683	    0460  8E D8					 mov	 ds,ax
   4684	    0462  66| 8B EC				 mov	 ebp,esp
   4685							 ; initialize the real mode interrupt vectors
   4686	    0465  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4687	    046A  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4688	    046F  FB					 sti
   4689					 ;------------------------------------------------------------------------
   4690					 ;We are returned to RealMode from ProtMode include all	RMode code here...
   4691					 ;------------------------------------------------------------------------
   4692	    0470			 GetSec1:
   4693							 ; call	mini loader to load one	sector
   4694	    0470  E8 0000e				 call	 aoaminil1
   4695
   4696							 ;cli					  ;SWITCH TO PM
   4697	    0473  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4698	    0478  0F 20	C0				 mov	 eax,cr0
   4699	    047B  0C 01					 or	 al,1
   4700	    047D  0F 22	C0				 mov	 cr0,eax
   4701							 JUMP16	 <GetSecCode_Sel>,<OFFSET GetSecV> ;TO PROTECTED MODE
1  4702	    0480  EA					 DB	 0eah
1  4703	    0481  0485r					 DW	 OFFSET	GetSecV
1  4704	    0483  0004					 DW	 GetSecCode_Sel
   4705	    0485			 GetSecV:
   4706	    0485  B8 000C				 mov	 ax,GetSecStack_Sel
   4707	    0488  8E D0					 mov	 ss,ax
   4708	    048A  66| 8B E5				 mov	 esp,ebp
   4709							 ;Actual code ends here
   4710							;----------------------------------
   4711							 ;restore the StartSectorNum1... value for the initial sectorno
   4712
   4713	    048D  B8 00C0				 mov	 ax,MEMData_Sel; zero selector
   4714	    0490  8E C0					 mov	 es,ax	       ; es has	zero selector
   4715	    0492  66| BB 00008600			 mov	 ebx,S_Base    ; 8600h for shared mem
   4716	    0498  66| 83 C3 04				 add	 ebx,S_SectorNo	; offset of the	sectorno in shared mem
   4717	    049C  26: 67| 8B 03				 mov	 ax, WORD PTR es:[ebx] ; read shared mem for sectorno
   4718	    04A0  3D FFFF				 cmp	 ax,-1	       ; if it is -1 it	is not an application read
   4719	    04A3  74 0E					 je	 LoadOneSecForAppRestore ; else	it is an application
   4720	    04A5  B8 0018				 mov	 ax,RData_Sel  ; RDataSeg
   4721	    04A8  8E E0					 mov	 fs,ax	       ; fs has	RDAtaSeg to refer to Start...
   4722
   4723	    04AA  26: 67| 8B 43	02			 mov	 ax, WORD PTR es:[ebx+2]; read the sectorno placed by the	    +
   4724					 application
   4725	    04AF  64: A3 0000e				 mov	 WORD PTR fs:[StartLogicalSecNum1m],ax ; store this in Start....
   4726
   4727	    04B3			 LoadOneSecForAppRestore:
   4728							;---------------------------------
   4729	    04B3  0F A9					 pop	 gs
   4730	    04B5  0F A1					 pop	 fs
   4731	    04B7  07					 pop	 es
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 84
prcycle.ASM



   4732	    04B8  1F					 pop	 ds
   4733
   4734	    04B9  66| CF				 iretd
   4735	    04BB  E9 FF56				 jmp	 GetSecBegin
   4736	    04BE			 GetSecBegin	   ENDP
   4737					 ;***************************************************************************
   4738					 ;WriteSecBegin	Procedure
   4739					 ;  comes here from a protected	mode through interrupt 0f4h
   4740					 ;  0f4h is used to write one sector from 8400 h to disk given a sector	no
   4741					 ; this	call is	always invoked by an application through 0f4h interrupt
   4742					 ; shared memory has the sector	number just like read a	sector
   4743					 ; only	read or	write at a time	can be done by the application
   4744					 ;***************************************************************************
   4745	    04BE			 WriteSecBegin	   PROC	   FAR
   4746
   4747
   4748	    04BE  1E					 push	 ds
   4749	    04BF  06					 push	 es
   4750	    04C0  0F A0					 push	 fs
   4751	    04C2  0F A8					 push	 gs
   4752
   4753							 ;-----------------------------------------------------------
   4754	    04C4  B8 00C0				 mov	 ax,MEMData_Sel; zero selector
   4755	    04C7  8E C0					 mov	 es,ax	       ; es has	zero selector
   4756	    04C9  66| BB 00008600			 mov	 ebx,S_Base    ; 8600h for shared mem
   4757	    04CF  66| 83 C3 04				 add	 ebx,S_SectorNo	; offset of the	sectorno in shared mem
   4758	    04D3  B8 0018				 mov	 ax,RData_Sel  ; RDataSeg
   4759	    04D6  8E E0					 mov	 fs,ax	       ; fs has	RDAtaSeg to refer to Start...
   4760
   4761	    04D8  64: A1 0000e				 mov	 ax, WORD PTR fs:[StartLogicalSecNum1m]
   4762	    04DC  26: 67| 89 43	02			 mov	 WORD PTR es:[ebx+2], ax ; store this value in shared mem temporarily
   4763
   4764	    04E1  26: 67| 8B 03				 mov	 ax, WORD PTR es:[ebx];	read the sectorno placed by the	application
   4765	    04E5  64: A3 0000e				 mov	 WORD PTR fs:[StartLogicalSecNum1m],ax ; store this in Start....
   4766							 ;-----------------------------------------------------------
   4767							 ;Actual interrupt code	starts here
   4768	    04E9  B8 0008				 mov	 ax,Normal_Sel
   4769	    04EC  8E D0					 mov	 ss,ax
   4770
   4771							 ;turn off the CR0 bit for protected mode
   4772	    04EE  0F 20	C0				 mov	 eax,cr0
   4773	    04F1  24 FE					 and	 al,11111110b
   4774	    04F3  0F 22	C0				 mov	 cr0,eax
   4775
   4776							 JUMP16	 <Seg WriteSec+RELOCATE1>,<OFFSET WriteSec>  ;SWITCH TO	REAL MODE
1  4777	    04F6  EA					 DB	 0eah
1  4778	    04F7  04FBr					 DW	 OFFSET	WriteSec
1  4779	    04F9  0080s					 DW	 Seg WriteSec+RELOCATE1
   4780	    04FB  B8 0000s		 WriteSec:	 mov	 ax,RDataSeg				 ; in real mode	now
   4781	    04FE  05 0080				 add	 ax, RELOCATE1	       ;RdataSeg is located w.r.t 800h or RELOCATE1
   4782	    0501  8E D8					 mov	 ds,ax
   4783	    0503  66| 8B EC				 mov	 ebp,esp
   4784							 ; initialize the real mode interrupt vectors
   4785	    0506  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4786	    050B  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4787	    0510  FB					 sti
   4788					 ;------------------------------------------------------------------------
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 85
prcycle.ASM



   4789					 ;We are returned to RealMode from ProtMode include all	RMode code here...
   4790					 ;------------------------------------------------------------------------
   4791	    0511			 WriteSec1:
   4792							 ; call	mini Writer to load one	sector
   4793	    0511  E8 0000e				 call	 aoaminiw1
   4794
   4795							 ;cli					  ;SWITCH TO PM
   4796	    0514  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4797	    0519  0F 20	C0				 mov	 eax,cr0
   4798	    051C  0C 01					 or	 al,1
   4799	    051E  0F 22	C0				 mov	 cr0,eax
   4800							 JUMP16	 <WriteSecCode_Sel>,<OFFSET WriteSecV> ;TO PROTECTED MODE
1  4801	    0521  EA					 DB	 0eah
1  4802	    0522  0526r					 DW	 OFFSET	WriteSecV
1  4803	    0524  0004					 DW	 WriteSecCode_Sel
   4804	    0526			 WriteSecV:
   4805	    0526  B8 000C				 mov	 ax,WriteSecStack_Sel
   4806	    0529  8E D0					 mov	 ss,ax
   4807	    052B  66| 8B E5				 mov	 esp,ebp
   4808							 ;Actual code ends here
   4809							;----------------------------------
   4810							 ;restore the StartSectorNum1... value for the initial sectorno
   4811
   4812	    052E  B8 00C0				 mov	 ax,MEMData_Sel; zero selector
   4813	    0531  8E C0					 mov	 es,ax	       ; es has	zero selector
   4814	    0533  66| BB 00008600			 mov	 ebx,S_Base    ; 8600h for shared mem
   4815	    0539  66| 83 C3 04				 add	 ebx,S_SectorNo	; offset of the	sectorno in shared mem
   4816	    053D  B8 0018				 mov	 ax,RData_Sel  ; RDataSeg
   4817	    0540  8E E0					 mov	 fs,ax	       ; fs has	RDAtaSeg to refer to Start...
   4818
   4819	    0542  26: 67| 8B 43	02			 mov	 ax, WORD PTR es:[ebx+2]; read the sectorno placed by the	    +
   4820					 application
   4821	    0547  64: A3 0000e				 mov	 WORD PTR fs:[StartLogicalSecNum1m],ax ; store this in Start....
   4822							;---------------------------------
   4823	    054B  0F A9					 pop	 gs
   4824	    054D  0F A1					 pop	 fs
   4825	    054F  07					 pop	 es
   4826	    0550  1F					 pop	 ds
   4827
   4828	    0551  66| CF				 iretd
   4829	    0553  E9 FF68				 jmp	 WriteSecBegin
   4830	    0556			 WriteSecBegin	     ENDP
   4831
   4832					 ;***************************************************************************
   4833					 ; Read	Sectors	From Disk
   4834					 ; this	procedure is invoked to	read all sectors from the disk starting	from
   4835					 ;  the
   4836					 ;***************************************************************************
   4837	    0556			 ReadSectorsAll	    PROC  C  NEAR USES ds eax ebx
   4838
   4839							 ;disable timer	while reading sectors
1  4840	    0556  1E				 PUSH	 DS
1  4841	    0557  66| 50			 PUSH	 EAX
1  4842	    0559  66| 53			 PUSH	 EBX
1  4843	    055B  66| 52				 push	 edx
   4844	    055D  66| 50				 push	 eax
   4845	    055F  BA 0021				 mov	 dx,21h	; disable timer	interrupt
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 86
prcycle.ASM



   4846	    0562  B0 01					 mov	 al,01h
   4847	    0564  EE					 out	 dx,al
   4848	    0565  66| 58				 pop	 eax
   4849	    0567  66| 5A				 pop	 edx
   4850
   4851							 ;--------------------------------------------
   4852							 ; save	start sector, number of	sectors	and address offset
   4853	    0569			 readagain:
   4854	    0569  06					 push	 es
   4855	    056A  B8 0018				 mov	 ax,RData_Sel
   4856	    056D  8E C0					 mov	 es,ax
   4857
   4858	    056F  66| B8 00000000			 mov	 eax, 0
   4859	    0575  26: A1 0417r				 mov	 ax, es:[SLSecNum1mS]
   4860	    0579  26: A3 0000e				 mov	 es:[StartLogicalSecNum1m], ax ; start sector
   4861
   4862	    057D  26: A1 0419r				 mov	 ax, es:[LSize1mS]
   4863	    0581  26: A3 0000e				 mov	 es:[LoaderSize1m], ax ; number	of sectors
   4864
   4865	    0585  66| 26: A1 041Br			 mov	 eax, es:[BxP1S]
   4866	    058A  66| 26: A3 0000e			 mov	 es:[BxPointer1], eax ;	address	offset
   4867
   4868							 ;-------------------------------
   4869	    058F  B8 00C0				 mov ax, MEMData_Sel
   4870							 ; This	is a zero base selector	to access shared memory	between	aoa and	    +
   4871					 application
   4872	    0592  0F A0					 push	 fs
   4873	    0594  8E E0					 mov	 fs, ax
   4874	    0596  66| BB 00008600			 mov	 ebx, S_Base
   4875	    059C  66| 81 C3 00000140			 add	 ebx, S_LSError
   4876	    05A3  66| B8 00000000			 mov	 eax, 0
   4877	    05A9  66| 64: 67| 89 03			 mov	 fs:[ebx], eax	   ;reset LSector Error	if any
   4878	    05AE  0F A1					 pop	 fs
   4879	    05B0  07					 pop	 es
   4880							 ;-------------------------------
   4881
   4882	    05B1  B8 0018				 mov	 ax,RData_Sel ;	real data seg
   4883	    05B4  8E D8					 mov	 ds,ax
   4884	    05B6			 readsectors:
   4885	    05B6  A1 0000e				 mov	 ax,ds:[LoaderSize1m] ;	get no of sectors to read
   4886	    05B9  3D 0000				 cmp	 ax,0		     ; is all sectors read?
   4887	    05BC  0F 86	00AB				 jbe	 nomoresectors	     ; yes, get	out of loop
   4888
   4889							 ;------------------------------
   4890							 ; we set a -1 flag in shared memory so	that
   4891							 ; when	menu loads application program,	starting
   4892							 ; sector is used as defined in	StartLogicalSecNum1
   4893							 ; otherwise, when an application program needs	to read	a
   4894							 ;  sector, then it will store its sector no in	this location
   4895							 ;------------------------------
   4896	    05C0  06					 push	 es
   4897	    05C1  66| 50				 push	 eax
   4898	    05C3  66| 53				 push	 ebx
   4899	    05C5  B8 00C0				 mov	 ax,MEMData_Sel
   4900	    05C8  8E C0					 mov	 es,ax
   4901	    05CA  66| BB 00008600			 mov	 ebx,S_Base
   4902	    05D0  66| 83 C3 04				 add	 ebx,S_SectorNo
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 87
prcycle.ASM



   4903	    05D4  26: 67| C7 03	FFFF			 mov	 WORD PTR es:[ebx],-1; To make sure the	controll in the	shared mem  +
   4904					 is set	to -1
   4905	    05DA  66| 5B				 pop	 ebx
   4906	    05DC  66| 58				 pop	 eax
   4907	    05DE  07					 pop	 es
   4908
   4909	    05DF  CD FA					 int	 0fah		     ; read one	sector
   4910							;-------------------------------
   4911	    05E1  B8 00C0				 mov ax, MEMData_Sel	     ; this is in protected mode
   4912							 ; This	is a zero base selector	to access shared memory	between	aoa and	    +
   4913					 application
   4914	    05E4  0F A0					 push	 fs
   4915	    05E6  8E E0					 mov	 fs, ax
   4916	    05E8  66| BB 00008600			 mov	 ebx, S_Base
   4917	    05EE  66| 81 C3 00000140			 add	 ebx, S_LSError
   4918	    05F5  66| 64: 67| 8B 03			 mov	 eax, fs:[ebx]	  ;check if there is LSector Error
   4919	    05FA  0F A1					 pop	 fs
   4920							 ;-------------------------------
   4921	    05FC  66| 83 F8 00				 cmp	 eax, 0
   4922	    0600  74 36					 jz	 continueread
   4923							 ;;reset LSError
   4924							 ;;-------------
   4925	    0602  B8 00C0				 mov ax, MEMData_Sel	     ; this is in protected mode
   4926							 ; This	is a zero base selector	to access shared memory	between	aoa and	    +
   4927					 application
   4928	    0605  0F A0					 push	 fs
   4929	    0607  8E E0					 mov	 fs, ax
   4930	    0609  66| BB 00008600			 mov	 ebx, S_Base
   4931	    060F  66| 81 C3 00000140			 add	 ebx, S_LSError
   4932	    0616  66| B8 00000000			 mov	 eax, 0
   4933	    061C  66| 64: 67| 89 03			 mov	 fs:[ebx], eax
   4934	    0621  0F A1					 pop	 fs
   4935							 ;;-------------
   4936	    0623  66| C7 06 01CDr     +			 mov	 ds:[AnyCounter], 021h
   4937		  00000021
   4938	    062C  66| C7 06 01C9r     +			 mov	 ds:[MemPrintOffset], 0
   4939		  00000000
   4940	    0635  E9 FF31				 jmp	 readagain
   4941							 ;------------------------------------
   4942	    0638			 continueread:
   4943							 CALL16	 RDWTMemPGate_Sel,0h ; copy sector to higher memory
1  4944	    0638  9A					 DB	 9ah
1  4945	    0639  0000					 DW	 0h
1  4946	    063B  0094					 DW	 RDWTMemPGate_Sel
   4947	    063D  66| A1 0000e				 mov	 eax,ds:[BxPointer1]
   4948	    0641  66| A3 01C9r				 mov	 ds:[MemPrintOffset],eax
   4949	    0645  66| FF 06 01CDr			 inc	 ds:[AnyCounter]	 ; increment sector counter
   4950
   4951	    064A  66| A1 01CDr				 mov	 eax,ds:[AnyCounter]	 ; get the sector counter
   4952	    064E  66| BB 00000F62			 mov	 ebx,3938		 ; print the counter at	the bottom
   4953	    0654  CD FD					 int	 0fdh			 ; puthex32 interrupt
   4954
   4955	    0656  66| 81 06 0000e     +			 add	 ds:[BxPointer1],200h	 ; update the BxPointer	for next sector
   4956		  00000200
   4957	    065F  66| 81 06 01C9r     +			 add	 ds:[MemPrintOffset],200h; update the memory print pointer for next +
   4958		  00000200		 sector
   4959	    0668  E9 FF4B				 jmp	 readsectors		 ; loop	until all sectors are read
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 88
prcycle.ASM



   4960
   4961	    066B			 nomoresectors:
   4962	    066B  66| C7 06 01C9r     +			 mov	 ds:[MemPrintOffset],0h	 ; reset memory	print offset
   4963		  00000000
   4964	    0674  66| C7 06 01CDr     +			 mov	 ds:[AnyCounter],21h	  ; reset sector counter
   4965		  00000021
   4966
1  4967	    067D  66| 5B			 POP	 EBX
1  4968	    067F  66| 58			 POP	 EAX
1  4969	    0681  1F				 POP	 DS
1  4970	    0682  C3				 RET	 0000h
   4971
   4972	    0683			 ReadSectorsAll	 ENDP
   4973					 ;***************************************************************************
   4974	    0683			 InitLoad	 PROC  C  NEAR ;SES ds eax ebx
   4975	    0683  0F A0					 push	 fs
   4976	    0685  B8 0054				 mov	 ax,RealData_Sel
   4977	    0688  8E E0					 mov	 fs,ax
   4978
   4979	    068A  64: 80 3E 0000e 31			 cmp	 fs:[ApplNum],31h
   4980	    0690  75 23					 jne	 LoadApp2
   4981
   4982	    0692  64: A1 0000e				 mov	 ax,fs:[LoaderSize1]
   4983	    0696  64: A3 0000e				 mov	 fs:[LoaderSize1m],ax
   4984	    069A  64: A1 0000e				 mov	 ax,fs:[StartLogicalSecNum1]
   4985	    069E  64: A3 0000e				 mov	 fs:[StartLogicalSecNum1m],ax
   4986	    06A2  66| 64: A1 0000e			 mov	 eax,fs:[LoadOffset1]
   4987
   4988	    06A7  66| 64: A3 0000e			 mov	 fs:[BxPointer1],eax
   4989	    06AC  66| 64: 83 0E	01D2r +			 or	 fs:[RunFlag],1
   4990		  01
   4991	    06B3  EB 27					 jmp	 LoadApp
   4992	    06B5			 LoadApp2:
   4993	    06B5  64: A1 0000e				 mov	 ax,fs:[LoaderSize2]
   4994	    06B9  64: A3 0000e				 mov	 fs:[LoaderSize1m],ax
   4995	    06BD  64: A1 0000e				 mov	 ax,fs:[StartLogicalSecNum2]
   4996	    06C1  64: A3 0000e				 mov	 fs:[StartLogicalSecNum1m],ax
   4997	    06C5  66| B8 00000000			 mov	 eax,0
   4998	    06CB  66| 64: A1 0000e			 mov	 eax,fs:[LoadOffset2]
   4999	    06D0  66| 64: A3 0000e			 mov	 fs:[BxPointer1],eax
   5000	    06D5  66| 64: 83 0E	01D2r +			 or	 fs:[RunFlag],2
   5001		  02
   5002	    06DC			 LoadApp:
   5003	    06DC  64: C6 06 0000e 00			 mov	 fs:[LoadFlag],0
   5004	    06E2  0F A1					 pop	 fs
   5005
1  5006	    06E4  C3				 RET	 0000h
   5007
   5008	    06E5			 InitLoad  ENDP
   5009					 ;***************************************************************************
   5010					 ; Running Application
   5011					 ;***************************************************************************
   5012	    06E5			 RunAppl  PROC	C  NEAR	;SES ds	eax ebx
   5013	    06E5  0F A0					 push	 fs
   5014	    06E7  0F A8					 push	 gs
   5015	    06E9  06					 push	 es
   5016
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 89
prcycle.ASM



   5017	    06EA  B8 00D0				 mov	 ax,App1TSSRW_Sel   ; selector for application task segment	    +
   5018					 App1TSSeg
   5019	    06ED  8E E8					 mov	 gs,ax		    ; gs pointing to task segment
   5020	    06EF  B8 0054				 mov	 ax,RealData_Sel
   5021	    06F2  8E E0					 mov	 fs,ax		    ; fs pointing to real data segment RDATASEG
   5022	    06F4  66| 64: A1 01D2r			 mov	 eax,fs:[RunFlag]
   5023	    06F9  66| 83 E0 01				 and	 eax,01h	    ; if the run flag is set then run
   5024	    06FD  66| 83 F8 01				 cmp	 eax,1
   5025	    0701  0F 85	01C0				 jne	 RunNext
   5026	    0705  66| BB 00000000r			 mov	 ebx, OFFSET App1TaskTSS  ; offset of the TaskTSS for app1
   5027	    070B  66| B8 00000000			 mov	 eax,0h
   5028							 ;mov	 eax, fs:[LoadOffset1]	  ; offset entered by the user during load
   5029							 ; we changed all base vlaues to 11 in the prcycle for cs, ds, ss
   5030							 ; LoadOffset1 is used to load program in memory
   5031	    0711  64: 03 06 0000e			 add	 ax,fs:[JumpOffset1]	  ; add	16 bit code segment offset entered  +
   5032					 by user
   5033	    0716  66| 65: 67| 89 43 20			 mov	 DWORD PTR gs:[ebx].TREIP,eax ;load EIP	value in the task segment
   5034
   5035							 ;mov	 eax, 0ffffh		; 64k cache
   5036							 ;mov	 eax, 0ffefffh		  ;LARGESTACK works for	teststack example
   5037	    071C  66| B8 01E84800			 mov	 eax, 01e84800h		  ; for	32 M stack size
   5038							 ;mov	 eax, 02200000h		  ; for	32 M stack size
   5039	    0722  66| 65: 67| 89 43 38			 mov	 dword ptr gs:[ebx].TRESP, eax ; load ESP value	in the task segment
   5040	    0728  66| B8 00000000			 mov	 eax, 0
   5041	    072E  66| 65: 67| 89 43 3C			 mov	 dword ptr gs:[ebx].TREBP, eax ; load EBP
   5042							 ;mov	 eax, 3202h
   5043							 ;mov	 dword ptr gs:[ebx].TREFlag, eax ; load	eflags
   5044	    0734  66| B8 00000202			 mov	 eax,0202h
   5045	    073A  66| 65: 67| 89 43 24			 mov	 dword ptr gs:[ebx].TREFlag, eax ; load	eflags
   5046																    +
   5047					 ;--------------------------------------------------------------------------------------
   5048							 ;Temp setup for App2
   5049
   5050	    0740  B8 0108				 mov	 ax,App2TSSRW_Sel   ; selector for application task segment	    +
   5051					 App1TSSeg
   5052	    0743  8E E8					 mov	 gs,ax		    ; gs pointing to task segment
   5053	    0745  B8 0054				 mov	 ax,RealData_Sel
   5054	    0748  8E E0					 mov	 fs,ax		    ; fs pointing to real data segment RDATASEG
   5055	    074A  66| BB 00000000r			 mov	 ebx, OFFSET App2TaskTSS  ; offset of the TaskTSS for app1
   5056	    0750  66| B8 00000000			 mov	 eax,0h
   5057	    0756  66| 64: A1 0000e			 mov	 eax, fs:[LoadOffset1]	  ; offset entered by the user during load
   5058	    075B  64: 03 06 0000e			 add	 ax,fs:[JumpOffset1]	  ; add	16 bit code segment offset entered  +
   5059					 by user
   5060	    0760  05 15DD				 add	 ax,015ddh
   5061	    0763  66| 65: 67| 89 43 20			 mov	 DWORD PTR gs:[ebx].TREIP,eax ;load EIP	value in the task segment
   5062
   5063							 ;mov	 eax, 0ffffh		; 64k cache
   5064							 ;mov	 eax, 0ffefffh		  ;LARGESTACK works for	teststack example
   5065	    0769  66| B8 01E84800			 mov	 eax, 01e84800h		  ; for	32 M stack size
   5066	    076F  66| 65: 67| 89 43 38			 mov	 dword ptr gs:[ebx].TRESP, eax ; load ESP value	in the task segment
   5067	    0775  66| B8 00000000			 mov	 eax, 0
   5068	    077B  66| 65: 67| 89 43 3C			 mov	 dword ptr gs:[ebx].TREBP, eax ; load EBP
   5069	    0781  66| B8 00004202			 mov	 eax,4202h
   5070	    0787  66| 65: 67| 89 43 24			 mov	 dword ptr gs:[ebx].TREFlag, eax ; load	eflags
   5071
   5072							 ;------------------------------------------------
   5073	    078D  1E					 push	 ds
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 90
prcycle.ASM



   5074							 ; Check for ReRun flag	if the flag is not zero	reload the App1	TSS from    +
   5075					 0200 location
   5076							 ; else	copy App1TSS to	0200 location
   5077	    078E  B8 0018				 mov	 ax, Rdata_Sel
   5078	    0791  8E D8					 mov	 ds, ax
   5079	    0793  A1 019Dr				 mov	 ax, WORD PTR ds:[RERunFlag]
   5080	    0796  3D 0000				 cmp	 ax, 0
   5081	    0799  75 7B					 jnz	 CPY0200
   5082
   5083	    079B  B8 0001				 mov	 ax, 1
   5084	    079E  A3 019Dr				 mov	 WORD PTR ds:[RERunFlag], ax
   5085	    07A1  1F					 pop	 ds
   5086							 ;------------------------------------------------------
   5087							 ;RKK Transfer a sample	TSS to user memory which can be	used
   5088							 ;  for	creating other TSS
   5089
   5090	    07A2  0F A0					 push	 fs
   5091	    07A4  0F A8					 push	 gs
   5092	    07A6  B8 00D0				 mov	 ax, App1TSSRW_Sel ; read/write	selector for TSS Segment App1
   5093	    07A9  8E E8					 mov	 gs, ax		   ; gs	with TSS segment
   5094	    07AB  66| BE 00000000r			 mov	 esi, OFFSET App1TaskTSS ; offset of TSS segment
   5095
   5096	    07B1  66| BB 02000000			 mov	 ebx, 02000000h	   ; user application memory address
   5097	    07B7  B8 00C0				 mov	 ax,MEMData_Sel	   ; 0 base selector for protected mode
   5098	    07BA  8E E0					 mov	 fs,ax		   ; use 0 base	selector
   5099
   5100	    07BC  66| B9 00000000			 mov	 ecx,0
   5101	    07C2  B8 0018				 mov	 ax, RData_Sel
   5102	    07C5  1E					 push	 ds		   ; get SizeOf_TSS1
   5103	    07C6  8E D8					 mov	 ds, ax
   5104	    07C8  8B 0E	0170r				 mov	 cx, WORD PTR ds:[SizeOf_TSS1]
   5105	    07CC  1F					 pop	 ds
   5106
   5107	    07CD			 movtssuserapp1:
   5108	    07CD  65: 67| 8A 06				 mov	 al, BYTE PTR gs:[esi] ; move TSS to user memory
   5109	    07D1  64: 67| 88 03				 mov	 BYTE PTR fs:[ebx], al ;    byte at a time
   5110	    07D5  66| 46				 inc	 esi
   5111	    07D7  66| 43				 inc	 ebx
   5112	    07D9  E2 F2					 loop	 movtssuserapp1		; loop
   5113	    07DB  0F A9					 pop	 gs
   5114	    07DD  0F A1					 pop	 fs
   5115					 ;----------------------------------------------------------------
   5116					 ; copy	the Demo Code TSS to 02001000
   5117	    07DF  0F A0					 push	 fs
   5118	    07E1  0F A8					 push	 gs
   5119	    07E3  B8 0148				 mov	 ax, DemoTSSRW_Sel ; read/write	selector for TSS Segment App1
   5120	    07E6  8E E8					 mov	 gs, ax		   ; gs	with TSS segment
   5121	    07E8  66| BE 00000000r			 mov	 esi, OFFSET DemoTSSSeg	; offset of TSS	segment
   5122
   5123	    07EE  66| BB 02001000			 mov	 ebx, 02001000h	   ; user application memory address
   5124	    07F4  B8 00C0				 mov	 ax,MEMData_Sel	   ; 0 base selector for protected mode
   5125	    07F7  8E E0					 mov	 fs,ax		   ; use 0 base	selector
   5126
   5127	    07F9  66| B9 00000000			 mov	 ecx,0
   5128	    07FF  B9 006A				 mov	 cx, 6Ah	 ; This	is the length of DemoTSS got form the List  +
   5129					 File
   5130										 ; it is a hardcoded value
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 91
prcycle.ASM



   5131	    0802			 movtssuserapp3:
   5132	    0802  65: 67| 8A 06				 mov	 al, BYTE PTR gs:[esi] ; move TSS to user memory
   5133	    0806  64: 67| 88 03				 mov	 BYTE PTR fs:[ebx], al ;    byte at a time
   5134	    080A  66| 46				 inc	 esi
   5135	    080C  66| 43				 inc	 ebx
   5136	    080E  E2 F2					 loop	 movtssuserapp3		; loop
   5137	    0810  0F A9					 pop	 gs
   5138	    0812  0F A1					 pop	 fs
   5139					 ;----------------------------------------------------------------
   5140	    0814  EB 72					 JMP	 CPY0200SKP		 ; Skip	CPY 0200 to App1 TSS
   5141					 ;---------------------------------------------------------------------------------
   5142					 ; Copy	the TSS	in 0200	location to App1 TSS to	reinitialize the APP1 TSS to re	run the	    +
   5143					 application
   5144					 ; without rebooting the computer
   5145	    0816			 CPY0200:
   5146
   5147	    0816  0F A0					 push	 fs
   5148	    0818  0F A8					 push	 gs
   5149	    081A  B8 00D0				 mov	 ax, App1TSSRW_Sel ; read/write	selector for TSS Segment App1
   5150	    081D  8E E8					 mov	 gs, ax		   ; gs	with TSS segment
   5151	    081F  66| BE 00000000r			 mov	 esi, OFFSET App1TaskTSS ; offset of TSS segment
   5152
   5153	    0825  66| BB 02000000			 mov	 ebx, 02000000h	   ; user application memory address
   5154	    082B  B8 00C0				 mov	 ax,MEMData_Sel	   ; 0 base selector for protected mode
   5155	    082E  8E E0					 mov	 fs,ax		   ; use 0 base	selector
   5156
   5157	    0830  66| B9 00000000			 mov	 ecx,0
   5158	    0836  B8 0018				 mov	 ax, RData_Sel
   5159	    0839  1E					 push	 ds		   ; get SizeOf_TSS1
   5160	    083A  8E D8					 mov	 ds, ax
   5161	    083C  8B 0E	0170r				 mov	 cx, WORD PTR ds:[SizeOf_TSS1]
   5162	    0840  1F					 pop	 ds
   5163	    0841			 movtssuserapp2:
   5164
   5165	    0841  64: 67| 8A 03				 mov	 al, BYTE PTR fs:[ebx];	   byte	at a time
   5166	    0845  65: 67| 88 06				 mov	 BYTE PTR gs:[esi], al;	   move	TSS to App1 TSS
   5167	    0849  66| 46				 inc	 esi
   5168	    084B  66| 43				 inc	 ebx
   5169	    084D  E2 F2					 loop	 movtssuserapp2		; loop
   5170	    084F  0F A9					 pop	 gs
   5171	    0851  0F A1					 pop	 fs
   5172					 ;----------------------------------------------------------------------------
   5173	    0853  0F A0					 push	 fs
   5174	    0855  0F A8					 push	 gs
   5175	    0857  B8 0148				 mov	 ax, DemoTSSRW_Sel ; read/write	selector for TSS Segment App1
   5176	    085A  8E E8					 mov	 gs, ax		   ; gs	with TSS segment
   5177	    085C  66| BE 00000000r			 mov	 esi, OFFSET DemoTSSSeg	; offset of TSS	segment
   5178
   5179	    0862  66| BB 02001000			 mov	 ebx, 02001000h	   ; user application memory address
   5180	    0868  B8 00C0				 mov	 ax,MEMData_Sel	   ; 0 base selector for protected mode
   5181	    086B  8E E0					 mov	 fs,ax		   ; use 0 base	selector
   5182
   5183	    086D  66| B9 00000000			 mov	 ecx,0
   5184	    0873  B9 006A				 mov	 cx, 6Ah	 ; This	is the length of DemoTSS got form the List  +
   5185					 File
   5186										 ; it is a hardcoded value
   5187	    0876			 movtssuserapp4:
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 92
prcycle.ASM



   5188	    0876  64: 67| 8A 03				 mov	 al, BYTE PTR fs:[ebx];	   byte	at a time
   5189	    087A  65: 67| 88 06				 mov	 BYTE PTR gs:[esi], al;	   move	TSS to App1 TSS
   5190	    087E  66| 46				 inc	 esi
   5191	    0880  66| 43				 inc	 ebx
   5192	    0882  E2 F2					 loop	 movtssuserapp4		; loop
   5193	    0884  0F A9					 pop	 gs
   5194	    0886  0F A1					 pop	 fs
   5195					 ;----------------------------------------------------------------------------
   5196	    0888			 CPY0200SKP:
   5197
   5198	    0888  66| 52			 push	 edx
   5199	    088A  66| 50			 push	 eax
   5200	    088C  BA 0021			 mov	 dx,21h	; disable timer	interrupt
   5201	    088F  B0 01				 mov	 al,01h
   5202	    0891  EE				 out	 dx,al
   5203	    0892  66| 58			 pop	 eax
   5204	    0894  66| 5A			 pop	 edx
   5205
   5206	    0896  CD FE					 int	 0feh		   ; run AO as a single	interrupt gate APPL1
   5207	    0898  66| 64: 81 26	01D2r +			 and	 fs:[RunFlag],0feh
   5208		  000000FE
   5209																    +
   5210					 ;----------------------------------------------------------------------------
   5211							 ;TEMP Print EFlags
   5212	    08A2  B8 0108				 mov	 ax,App2TSSRW_Sel   ; selector for application task segment	    +
   5213					 App1TSSeg
   5214	    08A5  8E E8					 mov	 gs,ax		    ; gs pointing to task segment
   5215	    08A7  66| BB 00000000r			 mov	 ebx, OFFSET App1TaskTSS  ; offset of the TaskTSS for app1
   5216	    08AD  66| 65: 67| 8B 43 24			 mov	 eax, dword ptr	gs:[ebx].TREFlag ; load	eflags
   5217	    08B3  66| BB 00000460			 mov	 ebx, 1120
   5218							 ;int	 0fdh	 ; Prints the EFlags
   5219	    08B9  0F 00	C8				 str	 ax
   5220	    08BC  66| BB 00000474			 mov	 ebx, 1140
   5221							 ;int	 0fdh
   5222																    +
   5223					 ;-----------------------------------------------------------------------------
   5224
   5225	    08C2  E9 0091				 jmp	 GoBackToMenu
   5226	    08C5			 RunNext:
   5227	    08C5  B8 0108				 mov	 ax,App2TSSRW_Sel
   5228	    08C8  8E E8					 mov	 gs,ax
   5229	    08CA  66| 64: A1 01D2r			 mov	 eax,fs:[RunFlag]
   5230	    08CF  24 02					 and	 al,02h
   5231	    08D1  3C 02					 cmp	 al,2
   5232	    08D3  0F 85	007F				 jne	 GoBackToMenu
   5233	    08D7  66| BB 00000000r			 mov	 ebx, OFFSET App2TaskTSS
   5234	    08DD  66| B8 00000000			 mov	 eax,0h
   5235	    08E3  66| 64: A1 0000e			 mov	 eax, fs:[LoadOffset2]
   5236	    08E8  64: 03 06 0000e			 add	 ax,fs:[JumpOffset2]
   5237
   5238	    08ED  66| 65: 67| 89 43 20			 mov	 DWORD PTR gs:[ebx].TREIP,eax
   5239	    08F3  66| B8 00000D00			 mov	 eax, 0d00h
   5240	    08F9  66| 65: 67| 89 43 38			 mov	 dword ptr gs:[ebx].TRESP, eax
   5241	    08FF  66| B8 00000000			 mov	 eax, 0
   5242	    0905  66| 65: 67| 89 43 3C			 mov	 dword ptr gs:[ebx].TREBP, eax
   5243	    090B  66| B8 00004202			 mov	 eax, 4202h
   5244	    0911  66| 65: 67| 89 43 24			 mov	 dword ptr gs:[ebx].TREFlag, eax
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 93
prcycle.ASM



   5245
   5246	    0917  66| 50				 push	 eax
   5247	    0919  66| 53				 push	 ebx
   5248	    091B  B0 5A					 mov	 al,'Z'
   5249	    091D  66| BB 000007BC			 mov	 ebx,1980
   5250	    0923  CD F7					 int	 0f7h
   5251	    0925  66| 5B				 pop	 ebx
   5252	    0927  66| 58				 pop	 eax
   5253							 ;---------------------------new
   5254	    0929  66| 50				 push	 eax
   5255	    092B  66| 53				 push	 ebx
   5256	    092D  0F A0					 push	 fs
   5257	    092F  66| BB 02000000			 mov	 ebx, 02000000h	   ; user application memory address
   5258	    0935  B8 00C0				 mov	 ax,MEMData_Sel	   ; 0 base selector for protected mode
   5259	    0938  8E E0					 mov	 fs,ax		   ; use 0 base	selector
   5260	    093A  66| B8 000025AB			 mov	 eax,0000025ABh	   ; Change the	EIP for	application 2
   5261	    0940  66| 83 C3 20				 add	 ebx,32
   5262							 ;mov	 DWORD PTR fs:[ebx],eax
   5263	    0944  0F A1					 pop	 fs
   5264	    0946  66| 5B				 pop	 ebx
   5265	    0948  66| 58				 pop	 eax
   5266							 ;---------------------------new
   5267
   5268
   5269	    094A  CD F9					 int	 0f9h
   5270	    094C  66| 64: 81 26	01D2r +			 and	 fs:[RunFlag],0fdh
   5271		  000000FD
   5272	    0956			 GoBackToMenu:
   5273	    0956  07					 pop	 es
   5274	    0957  0F A9					 pop	 gs
   5275	    0959  0F A1					 pop	 fs
1  5276	    095B  C3				 RET	 0000h
   5277	    095C			 RunAppl  ENDP
   5278					 ;***************************************************************************
   5279					 ; Once	the exception occurs, this call	will print the stack values so that
   5280					 ; the user can	see the	address	and EIP, CS values that	caused the exception
   5281					 ;  Other_Sel, RCodeSeg, it is in 16 bit segment while in error
   5282					 ;  It is still	using the TSS for the task which caused	error
   5283					 ;  The	contents of the	stack printed represent
   5284					 ;  - error code
   5285					 ;  - address where it failed
   5286					 ;  - selector for that	address
   5287					 ;  - flag register
   5288					 ;***************************************************************************
   5289	    095C			 PrintStackException	 PROC	 FAR
   5290	    095C  66| 55			 push	 ebp		 ;save the base	pointer
   5291	    095E  66| 8B EC			 mov	 ebp, esp	 ; load	current	SP into	BP
   5292	    0961  66| B9 00000020		 mov	 ecx, 32	 ; print ten entries in	the stack
   5293	    0967  66| BB 00000460		 mov	 ebx, 1120	 ; start location of print
   5294	    096D			 label210:
   5295	    096D  66| 67| 8B 45	00		 mov	 eax, ss:[ebp +	0]   ; do not print the	top 2 entries (push ebp, and the    +
   5296					 return	address	of this	call)
   5297	    0972  66| 83 C5 04			 add	 ebp, 4		 ; print next entry
   5298	    0976  66| 83 C3 02			 add	 ebx, 2		 ; space between printing hex values
   5299	    097A  CD FD				 int	 0fdh		 ; print 4 bytes
   5300	    097C  E2 EF				 LOOP	 label210	 ; loop	to print ten entries
   5301	    097E  FB				 sti
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 94
prcycle.ASM



   5302	    097F  CD F5				 int	 0f5h		 ; wait	for a character
   5303	    0981  66| 5D			 pop	 ebp		 ; restore the base pointer
   5304
   5305	    0983  CB				 ret			 ; return back to error	rtn
   5306	    0984			 PrintStackException	 ENDP
   5307					 ;***************************************************************************
   5308					 ; Set error flag and error code in the	global memory
   5309					 ;***************************************************************************
   5310	    0984			 SetErrorFlag	 PROC	 FAR
   5311	    0984  66| 50			 push eax ; save registers
   5312	    0986  66| 53			 push ebx
   5313	    0988  66| 51			 push ecx
   5314	    098A  06				 push es
   5315
   5316	    098B  66| BB 00000190		 mov	 ebx,400
   5317	    0991  CD F7				 int	 0f7h
   5318						 ;------------------------------------
   5319	    0993  B8 00B0			 mov	 ax, G4Data_Sel
   5320						 ;This is a zero base selector to access shared	memory between aoa and application
   5321	    0996  8E C0				 mov	 es, ax
   5322	    0998  66| BB 00008600		 mov	 ebx, S_Base
   5323	    099E  66| 83 C3 18			 add	 ebx, S_Error_Flag
   5324	    09A2  66| B8 00000001		 mov	 eax, 1	       ; set the error flag in global memory
   5325	    09A8  66| 26: 67| 89 03		 mov	 DWORD PTR es:[ebx], eax
   5326	    09AD  66| BB 00008600		 mov	 ebx, S_Base
   5327	    09B3  66| 83 C3 1C			 add	 ebx, S_Error_Code
   5328	    09B7  66| 8B C1			 mov	 eax, ecx	 ; set the error code in global	memory
   5329	    09BA  66| 26: 67| 89 03		 mov	 DWORD PTR es:[ebx], eax
   5330						 ;---------------------------------------------------------------------------------
   5331						 ;changed this code on 7-7-2004
   5332	    09BF  FA					 cli
   5333	    09C0  66| 52				 push	 edx
   5334	    09C2  66| 9C				 pushfd	; turn off NT flag in the CPU not in the TSS
   5335							 ; so that CPU will return to its application during IRETD not to
   5336							 ;  exit from the task using link field	in the TSS
   5337	    09C4  66| 5A				 pop	 edx;
   5338	    09C6  66| 81 E2 FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   5339	    09CD  66| 52				 push	 edx
   5340	    09CF  66| 9D				 popfd
   5341	    09D1  66| 5A				 pop	 edx
   5342	    09D3  FB					 sti
   5343						 ;--------------------------------------------------------------------------------
   5344
   5345	    09D4  07				 pop es	; restore registers
   5346	    09D5  66| 59			 pop ecx
   5347	    09D7  66| 5B			 pop ebx
   5348	    09D9  66| 58			 pop eax
   5349	    09DB  CB				 ret
   5350	    09DC			 SetErrorFlag	 ENDP
   5351					 ;***************************************************************************
   5352					 ;OtherBegin0 Procedure, 0 interrupt
   5353					 ;***************************************************************************
   5354	    09DC			 OtherBegin0	  PROC	  FAR
   5355	    09DC  0E E8	FF7C			 call	 PrintStackException ; print stack entries
   5356	    09E0  FA				 cli
   5357	    09E1  66| B9 00000000		 mov	 ecx, 00h
   5358	    09E7  B0 41				 mov	 al, 'A'
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 95
prcycle.ASM



   5359	    09E9  0E E8	FF97			 CALL	 SetErrorFlag	 ; call	the routine
   5360	    09ED  CD 08				 int 08h
   5361	    09EF  66| CF			 iretd
   5362	    09F1			 OtherBegin0	  ENDP
   5363					 ;***************************************************************************
   5364					 ;OtherBegin1 Procedure, 1 interrupt
   5365					 ;***************************************************************************
   5366	    09F1			 OtherBegin1	  PROC	  FAR
   5367	    09F1  0E E8	FF67			 call	 PrintStackException ; print stack entries
   5368	    09F5  FA				 cli
   5369	    09F6  66| B9 00000001		 mov	 ecx, 01h
   5370	    09FC  B0 42				 mov	 al, 'B'
   5371	    09FE  0E E8	FF82			 CALL	 SetErrorFlag	 ; call	the routine
   5372	    0A02  CD 08				 int 08h
   5373	    0A04  66| CF			 iretd
   5374	    0A06			 OtherBegin1	  ENDP
   5375					 ;***************************************************************************
   5376					 ;OtherBegin2 Procedure, 2 interrupt
   5377					 ;***************************************************************************
   5378	    0A06			 OtherBegin2	  PROC	  FAR
   5379	    0A06  0E E8	FF52			 call	 PrintStackException ; print stack entries
   5380	    0A0A  FA				 cli
   5381	    0A0B  66| B9 00000002		 mov	 ecx, 02h
   5382	    0A11  B0 43				 mov	 al, 'C'
   5383	    0A13  0E E8	FF6D			 CALL	 SetErrorFlag	 ; call	the routine
   5384	    0A17  CD 08				 int 08h
   5385	    0A19  66| CF			 iretd
   5386	    0A1B			 OtherBegin2	  ENDP
   5387					 ;***************************************************************************
   5388					 ;OtherBegin3 Procedure, 3 interrupt
   5389					 ;***************************************************************************
   5390	    0A1B			 OtherBegin3	  PROC	  FAR
   5391	    0A1B  0E E8	FF3D			 call	 PrintStackException ; print stack entries
   5392	    0A1F  FA				 cli
   5393	    0A20  66| B9 00000003		 mov	 ecx, 03h
   5394	    0A26  B0 44				 mov	 al, 'D'
   5395	    0A28  0E E8	FF58			 CALL	 SetErrorFlag	 ; call	the routine
   5396	    0A2C  CD 08				 int 08h
   5397	    0A2E  66| CF			 iretd
   5398
   5399	    0A30			 OtherBegin3	  ENDP
   5400					 ;***************************************************************************
   5401					 ;OtherBegin4 Procedure, 4 interrupt
   5402					 ;***************************************************************************
   5403	    0A30			 OtherBegin4	  PROC	  FAR
   5404	    0A30  0E E8	FF28			 call	 PrintStackException ; print stack entries
   5405	    0A34  FA				 cli
   5406	    0A35  66| B9 00000004		 mov	 ecx, 04h
   5407	    0A3B  B0 45				 mov	 al, 'E'
   5408	    0A3D  0E E8	FF43			 CALL	 SetErrorFlag	 ; call	the routine
   5409	    0A41  CD 08				 int 08h
   5410	    0A43  66| CF			 iretd
   5411	    0A45			 OtherBegin4	  ENDP
   5412					 ;***************************************************************************
   5413					 ;OtherBegin5 Procedure, 5 interrupt
   5414					 ;***************************************************************************
   5415	    0A45			 OtherBegin5	  PROC	  FAR
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 96
prcycle.ASM



   5416	    0A45  0E E8	FF13			 call	 PrintStackException ; print stack entries
   5417	    0A49  FA				 cli
   5418	    0A4A  66| B9 00000005		 mov	 ecx, 05h
   5419	    0A50  B0 46				 mov	 al, 'F'
   5420	    0A52  0E E8	FF2E			 CALL	 SetErrorFlag	 ; call	the routine
   5421	    0A56  CD 08				 int 08h
   5422	    0A58  66| CF			 iretd
   5423	    0A5A			 OtherBegin5	  ENDP
   5424					 ;***************************************************************************
   5425					 ;OtherBegin6 Procedure, 6 interrupt
   5426					 ;***************************************************************************
   5427	    0A5A			 OtherBegin6	  PROC	  FAR
   5428	    0A5A  0E E8	FEFE			 call	 PrintStackException ; print stack entries
   5429	    0A5E  FA				 cli
   5430	    0A5F  66| B9 00000006		 mov	 ecx, 06h
   5431	    0A65  B0 47				 mov	 al, 'G'
   5432	    0A67  0E E8	FF19			 CALL	 SetErrorFlag	 ; call	the routine
   5433	    0A6B  CD 08				 int 08h
   5434	    0A6D  66| CF			 iretd
   5435	    0A6F			 OtherBegin6	  ENDP
   5436					 ;***************************************************************************
   5437					 ;OtherBegin7 Procedure, 7 interrupt
   5438					 ;***************************************************************************
   5439	    0A6F			 OtherBegin7	  PROC	  FAR
   5440	    0A6F  0E E8	FEE9			 call	 PrintStackException ; print stack entries
   5441	    0A73  FA				 cli
   5442	    0A74  66| B9 00000007		 mov	 ecx, 07h
   5443	    0A7A  B0 48				 mov	 al, 'H'
   5444	    0A7C  0E E8	FF04			 CALL	 SetErrorFlag	 ; call	the routine
   5445	    0A80  CD 08				 int 08h
   5446	    0A82  66| CF			 iretd
   5447	    0A84			 OtherBegin7	  ENDP
   5448					 ;***************************************************************************
   5449					 ;OtherBegin10 Procedure, 10 interrupt
   5450					 ;This exception will be generated when	the TSS	is invalid
   5451					 ;***************************************************************************
   5452	    0A84			 OtherBegin10	   PROC	   FAR
   5453	    0A84  0E E8	FED4			 call	 PrintStackException ; print stack entries
   5454	    0A88  FA				 cli
   5455	    0A89  66| B9 0000000A		 mov	 ecx, 10
   5456	    0A8F  B0 49				 mov	 al, 'I'
   5457	    0A91  0E E8	FEEF			 CALL	 SetErrorFlag	 ; call	the routine
   5458	    0A95  CD 08				 int 08h
   5459	    0A97  66| CF			 iretd
   5460	    0A99			 OtherBegin10	   ENDP
   5461					 ;***************************************************************************
   5462					 ;OtherBegina11	Procedure, 11 interrupt
   5463					 ;***************************************************************************
   5464	    0A99			 OtherBegin11	   PROC	   FAR
   5465	    0A99  0E E8	FEBF			 call	 PrintStackException ; print stack entries
   5466	    0A9D  FA				 cli
   5467	    0A9E  66| B9 0000000B		 mov	 ecx, 11
   5468	    0AA4  B0 4A				 mov	 al, 'J'
   5469	    0AA6  0E E8	FEDA			 CALL	 SetErrorFlag	 ; call	the routine
   5470	    0AAA  CD 08				 int 08h
   5471	    0AAC  66| CF			 iretd
   5472
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 97
prcycle.ASM



   5473	    0AAE			 OtherBegin11	   ENDP
   5474					 ;***************************************************************************
   5475					 ;OtherBegina12	Procedure, 12 interrupt
   5476					 ;***************************************************************************
   5477	    0AAE			 OtherBegin12	   PROC	   FAR
   5478	    0AAE  0E E8	FEAA			 call	 PrintStackException ; print stack entries
   5479	    0AB2  FA				 cli
   5480	    0AB3  66| B9 0000000C		 mov	 ecx, 12
   5481	    0AB9  B0 4B				 mov	 al, 'K'
   5482	    0ABB  0E E8	FEC5			 CALL	 SetErrorFlag	 ; call	the routine
   5483	    0ABF  CD 08				 int 08h
   5484	    0AC1  66| CF			 iretd
   5485	    0AC3			 OtherBegin12	   ENDP
   5486					 ;***************************************************************************
   5487					 ;OtherBegina13	Procedure, 13 interrupt
   5488					 ;***************************************************************************
   5489	    0AC3			 OtherBegin13	   PROC	   FAR
   5490					 ; cli and sti is needed to prevent timer interrupts
   5491
   5492	    0AC3  FA				 cli
   5493	    0AC4  66| 50			 push	 eax
   5494	    0AC6  66| 53			 push	 ebx
   5495	    0AC8  0F A0				 push	 fs
   5496	    0ACA  0E E8	FE8E			 call	 PrintStackException ; print stack entries
   5497						 ;cli
   5498						 ;mov	 ecx, 13	 ; pass	Interrupt code
   5499						 ;mov	 al, 'L'	 ; pass	print character
   5500						 ;CALL	 SetErrorFlag	 ; set the error flag and controls
   5501						 ;int 08h		  ; call interrrupt to give control to error handler
   5502	    0ACE  B0 4C				 mov al, 'L'
   5503	    0AD0  66| BB 00000F8C		 mov ebx, 3980
   5504	    0AD6  CD F7				 int 0f7h
   5505	    0AD8  66| B8 00000000		 mov eax, 0
   5506	    0ADE  8C C8				 mov ax, cs
   5507	    0AE0  66| BB 00000334		 mov ebx, 820
   5508	    0AE6  CD FD				 int 0fdh
   5509	    0AE8  8C D0				 mov ax, ss
   5510	    0AEA  66| BB 00000348		 mov ebx, 840
   5511	    0AF0  CD FD				 int 0fdh
   5512	    0AF2  66| 8B C4			 mov eax, esp
   5513	    0AF5  66| BB 0000035C		 mov ebx, 860
   5514	    0AFB  CD FD				 int 0fdh
   5515	    0AFD  66| 8B C5			 mov eax, ebp
   5516	    0B00  66| BB 00000370		 mov ebx, 880
   5517	    0B06  CD FD				 int 0fdh
   5518	    0B08  66| B8 00000000		 mov eax, 0
   5519	    0B0E  0F 00	C0			 sldt ax
   5520	    0B11  66| BB 00000384		 mov ebx, 900
   5521	    0B17  CD FD				 int 0fdh
   5522	    0B19  66| B8 00000000		 mov eax, 0
   5523	    0B1F  0F 00	C8			 str ax
   5524	    0B22  66| BB 00000398		 mov ebx, 920
   5525	    0B28  CD FD				 int 0fdh
   5526	    0B2A  B8 0018			 mov ax, RData_Sel
   5527	    0B2D  8E E0				 mov fs, ax
   5528	    0B2F  66| B8 00000000		 mov eax, 0
   5529	    0B35  64: 0F 01 06 0168		 sgdt fs:[168h]
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 98
prcycle.ASM



   5530	    0B3B  66| 64: A1 016A		 mov  eax,  fs:[16ah]
   5531	    0B40  66| BB 000003AC		 mov  ebx, 940
   5532	    0B46  CD FD				 int 0fdh
   5533	    0B48  66| B8 00000000		 mov eax, 0
   5534	    0B4E  66| 64: A1 0168		 mov  eax,  fs:[168h]
   5535	    0B53  66| BB 000003C0		 mov  ebx, 960
   5536	    0B59  CD FD				 int 0fdh
   5537
   5538	    0B5B  CD F5				 int 0f5h
   5539	    0B5D  CD F5				 int 0f5h
   5540	    0B5F  CD F5				 int 0f5h
   5541	    0B61  CD F5				 int 0f5h
   5542
   5543
   5544
   5545
   5546							 ;-----------------------------------------------------------------
   5547							 ;changed this code on 7-7-2004
   5548	    0B63  66| 52				 push	 edx
   5549	    0B65  66| 9C				 pushfd	; turn off NT flag in the CPU not in the TSS
   5550							 ; so that CPU will return to its application during IRETD not to
   5551							 ;  exit from the task using link field	in the TSS
   5552	    0B67  66| 5A				 pop	 edx
   5553	    0B69  66| 81 E2 FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   5554	    0B70  66| 52				 push	 edx
   5555	    0B72  66| 9D				 popfd
   5556	    0B74  66| 5A				 pop	 edx
   5557							 ;-----------------------------------------------------------------
   5558	    0B76  1F				 pop	 ds
   5559	    0B77  66| 5B			 pop	 ebx
   5560	    0B79  66| 58			 pop	 eax
   5561
   5562	    0B7B  FB				 sti
   5563	    0B7C  66| CF			 iretd		 ; after sti, no more instructions before iretd
   5564	    0B7E			 OtherBegin13	   ENDP
   5565
   5566					 ;***************************************************************************
   5567					 ;OtherBegina219 Procedure  , 219 interrupt
   5568					 ;***************************************************************************
   5569	    0B7E			 OtherBegin219	    PROC    FAR
   5570						 ;call	 PrintStackException ; print stack entries
   5571	    0B7E  FA				 cli
   5572					 ;	 mov	 ecx, 219
   5573					 ;	 mov	 al, 'M'
   5574					 ;	 CALL	 SetErrorFlag	 ; call	the routine
   5575					 ;	 int 08h
   5576	    0B7F  FB				 sti
   5577	    0B80  66| CF			 iretd
   5578	    0B82			 OtherBegin219	    ENDP
   5579
   5580					 ;***************************************************************************
   5581					 ; OtherBegin73	interrupt routine for NIC
   5582					 ;***************************************************************************
   5583	    0B82			 OtherBegin73	   PROC	   FAR
   5584	    0B82  FA				 cli	     ; no more interrupts
   5585	    0B83  66| 50		  push eax
   5586	    0B85  66| 52		  push edx
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 99
prcycle.ASM



   5587	    0B87  66| 51		  push ecx
   5588	    0B89  66| 53		  push ebx
   5589	    0B8B  66| 57		  push edi
   5590	    0B8D  66| 56		  push esi
   5591	    0B8F  0F A0			  push fs
   5592					 ;------------------------------------------------------------------------
   5593					 ; this	code only for NIC interrupt and	TxComplete interrupt
   5594					 ;  every transmit results in an interrupt
   5595					 ; we save txstatus in DPD location 24
   5596					 ;  we write some thing	into the txstatus to advance to	next level
   5597					 ;------------------------------------------------------------------------
   5598	    0B91  66| 33 C0			 xor  eax, eax
   5599	    0B94  66| 33 D2			 xor  edx, edx
   5600
   5601						 ; first check if TxComplete bit is set
   5602						 ;  because IRQ11 is shared by many interrupts
   5603	    0B97  B8 00C0			 mov	 ax, MEMData_Sel; This is a zero base selector to access shared	memory	    +
   5604					 between aoa and application
   5605	    0B9A  8E E0				 mov	 fs, ax
   5606	    0B9C  66| BB 00008600		 mov ebx, S_Base
   5607	    0BA2  66| 81 C3 0000009C		 add ebx, S_IOBASE
   5608	    0BA9  66| 64: 67| 8B 33		 mov esi, DWORD	PTR fs:[ebx]  ;	get IOBASE
   5609
   5610					 ;-------------------------------------------------------------------
   5611						 ;mov	 eax, esi   ; stall the	transmitter
   5612						 ;mov	 dx, ax
   5613						 ;add	 dx, 0eh
   5614						 ;mov	 ax, 3002h
   5615						 ;out	 dx, ax
   5616					 ;W_End1:
   5617						 ;in	  ax, dx
   5618						 ;and	  ax, 1000h			  ;Check status
   5619						 ;jnz	  W_End1
   5620					 ;-------------------------------------------------------------------
   5621	    0BAE  66| 8B D6			 mov  edx, esi		 ;check	TxStatus if TxComplete
   5622	    0BB1  66| 83 C2 1B			 add  edx, 1bh
   5623	    0BB5  EC				 in   al, dx
   5624
   5625	    0BB6  66| 8B F8			 mov	 edi, eax ; save the status
   5626
   5627
   5628	    0BB9  24 80				 and  al, 80h  ; check for bit 7
   5629	    0BBB  0F 84	01D2			 jz   not_NIC  ; if not	set then this is not our interrupt
   5630
   5631
   5632	    0BBF  EC				 in   al, dx   ; dx is still same
   5633	    0BC0  EE				 out  dx, al   ;write to status	register to advance xmitter
   5634
   5635	    0BC1  66| 8B D6			 mov  edx, esi
   5636	    0BC4  66| 83 C2 0E			 add  edx, 0eh		 ;Command window
   5637	    0BC8  B8 68FF			 mov  ax, 68ffh		 ; acknowledge all interrupts
   5638	    0BCB  EF				 out  dx, ax
   5639
   5640	    0BCC  66| BB 00008600		 mov	 ebx, S_Base
   5641	    0BD2  66| 81 C3 000000A8		 add	 ebx, S_DPD_Count  ; counter
   5642	    0BD9  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5643	    0BDE  66| B9 00000020		 mov	 ecx, 32	 ; results are in edx:eax
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 100
prcycle.ASM



   5644	    0BE4  66| F7 E1			 mul	 ecx		 ; 32 byte for each DPD	entry
   5645	    0BE7  66| BA 0230BF40		 mov	 edx, 0230bf40h	 ; DPD start address hard coded
   5646	    0BED  66| 03 D0			 add	 edx, eax
   5647	    0BF0  66| 83 C2 18			 add	 edx, 18h	 ; TxStatus location in	the DPD
   5648
   5649	    0BF4  66| 8B C7			 mov	 eax, edi	 ; get the txstatus stored in the regiser
   5650
   5651						 ;-----------------------------------------------------------------------
   5652						 ; this	change allows to add other control bits	in the DPD slot	location 24
   5653	    0BF7  66| 25 000000FF		 and	 eax, 0ffh	; mask all other 12 bits, status is in last 4 bits
   5654	    0BFD  66| 64: 67| 8B 0A		 mov	 ecx, DWORD PTR	fs:[edx] ; get current contents
   5655	    0C02  66| 0B C1			 or	 eax, ecx	 ; only	store the status in 4 bits
   5656						 ;-----------------------------------------------------------------------
   5657	    0C05  66| 64: 67| 89 02		 mov	 DWORD PTR fs:[edx], eax   ; store it in the DPD
   5658						 ; TxStatus is stored in DPD at	24 for future reference
   5659	    0C0A  66| 50			 push	 eax		  ; save the DPD status	word
   5660
   5661						 ;-----------------------------------------------------------------------
   5662	    0C0C  66| 25 FFFF00FF		 and	 eax, 0ffff00ffh   ; reset the send type byte to 0
   5663	    0C12  66| 64: 67| 89 02		 mov	 DWORD PTR fs:[edx], eax   ; store it in the DPD, next time no recount of   +
   5664					 this field
   5665						 ;-----------------------------------------------------------------------
   5666
   5667	    0C17  66| BB 00008600		 mov	 ebx, S_Base
   5668	    0C1D  66| 81 C3 000000A8		 add	 ebx, S_DPD_Count  ; counter
   5669	    0C24  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5670	    0C29  66| 40			 inc	 eax   ; increment the count
   5671	    0C2B  66| 3D 00002710		 cmp	 eax, 10000	 ; hardcoded DPD size value
   5672	    0C31  75 06				 jnz	 skipreset	 ; no need to reset the	counter
   5673	    0C33  66| B8 00000000		 mov	 eax, 0		 ; loop	back again circular list
   5674	    0C39				 skipreset:
   5675	    0C39  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store value
   5676
   5677	    0C3E  66| BB 00008600		 mov	 ebx, S_Base
   5678	    0C44  66| 81 C3 000000A4		 add	 ebx, S_Total_Tx_Count	; counts no of interrupts received for Txt
   5679	    0C4B  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5680	    0C50  66| 40			 inc	 eax   ; increment the count
   5681	    0C52  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5682						 ;-----------------------------------------------------------------
   5683						 ; we also update specific counters for	header,	data, and ack packets
   5684						 ;  to keep track of how many of these were served by NIC card which
   5685						 ;  is indicated by received interrupts
   5686						 ; so that packets transmitted in the application can be checked
   5687						 ;  against the	packets	transmitted by NIC using interrupt count
   5688
   5689	    0C57  66| 58			 pop	 eax	 ; this	is the DPD status
   5690	    0C59  66| 8B C8			 mov	 ecx, eax    ; save eax	in ecx
   5691
   5692						 ; count synack	 code 01
   5693	    0C5C  66| 25 0000FF00		 and	 eax, 0000ff00h
   5694	    0C62  66| 3D 00000100		 cmp	 eax, 00000100h
   5695	    0C68  75 19				 jnz	 skipsynack
   5696	    0C6A  66| BB 00008600		 mov	 ebx, S_Base
   5697	    0C70  66| 81 C3 00000100		 add	 ebx, S_ITCP_SACK_Count
   5698	    0C77  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5699	    0C7C  66| 40			 inc	 eax   ; increment the count
   5700	    0C7E  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 101
prcycle.ASM



   5701	    0C83				 skipsynack:
   5702
   5703						 ; count getack	code 02
   5704	    0C83  66| 8B C1			 mov	 eax, ecx
   5705	    0C86  66| 25 0000FF00		 and	 eax, 0000ff00h
   5706	    0C8C  66| 3D 00000200		 cmp	 eax, 00000200h
   5707	    0C92  75 19				 jnz	 skipgetack
   5708	    0C94  66| BB 00008600		 mov	 ebx, S_Base
   5709	    0C9A  66| 81 C3 00000104		 add	 ebx, S_ITCP_GACK_Count
   5710	    0CA1  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5711	    0CA6  66| 40			 inc	 eax   ; increment the count
   5712	    0CA8  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5713	    0CAD				 skipgetack:
   5714
   5715						 ; count header	code 03
   5716	    0CAD  66| 8B C1			 mov	 eax, ecx
   5717	    0CB0  66| 25 0000FF00		 and	 eax, 0000ff00h
   5718	    0CB6  66| 3D 00000300		 cmp	 eax, 00000300h
   5719	    0CBC  75 19				 jnz	 skipheader
   5720	    0CBE  66| BB 00008600		 mov	 ebx, S_Base
   5721	    0CC4  66| 81 C3 00000108		 add	 ebx, S_ITCP_HDR_Count
   5722	    0CCB  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5723	    0CD0  66| 40			 inc	 eax   ; increment the count
   5724	    0CD2  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5725	    0CD7				 skipheader:
   5726
   5727						 ; count data packets code 04
   5728	    0CD7  66| 8B C1			 mov	 eax, ecx    ; restore TxStatus
   5729	    0CDA  66| 25 0000FF00		 and	 eax, 0000ff00h
   5730	    0CE0  66| 3D 00000400		 cmp	 eax, 00000400h
   5731	    0CE6  75 19				 jnz	 skipdata
   5732	    0CE8  66| BB 00008600		 mov	 ebx, S_Base
   5733	    0CEE  66| 81 C3 0000010C		 add	 ebx, S_ITCP_DAT_Count
   5734	    0CF5  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5735	    0CFA  66| 40			 inc	 eax   ; increment the count
   5736	    0CFC  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5737	    0D01				 skipdata:
   5738
   5739						 ; count finack	code 05
   5740	    0D01  66| 8B C1			 mov	 eax, ecx
   5741	    0D04  66| 25 0000FF00		 and	 eax, 0000ff00h
   5742	    0D0A  66| 3D 00000500		 cmp	 eax, 00000500h
   5743	    0D10  75 19				 jnz	 skipfinack
   5744	    0D12  66| BB 00008600		 mov	 ebx, S_Base
   5745	    0D18  66| 81 C3 00000110		 add	 ebx, S_ITCP_FACK_Count
   5746	    0D1F  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5747	    0D24  66| 40			 inc	 eax   ; increment the count
   5748	    0D26  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5749	    0D2B				 skipfinack:
   5750
   5751						 ; count resets	code 06
   5752	    0D2B  66| 8B C1			 mov	 eax, ecx
   5753	    0D2E  66| 25 0000FF00		 and	 eax, 0000ff00h
   5754	    0D34  66| 3D 00000600		 cmp	 eax, 00000600h
   5755	    0D3A  75 19				 jnz	 skipresets
   5756	    0D3C  66| BB 00008600		 mov	 ebx, S_Base
   5757	    0D42  66| 81 C3 00000114		 add	 ebx, S_ITCP_RESET_Count
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 102
prcycle.ASM



   5758	    0D49  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5759	    0D4E  66| 40			 inc	 eax   ; increment the count
   5760	    0D50  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5761	    0D55				 skipresets:
   5762
   5763						 ; count ARP code 07
   5764	    0D55  66| 8B C1			 mov	 eax, ecx
   5765	    0D58  66| 25 0000FF00		 and	 eax, 0000ff00h
   5766	    0D5E  66| 3D 00000700		 cmp	 eax, 00000700h
   5767	    0D64  75 19				 jnz	 skiparps
   5768	    0D66  66| BB 00008600		 mov	 ebx, S_Base
   5769	    0D6C  66| 81 C3 00000118		 add	 ebx, S_ITCP_ARP_Count
   5770	    0D73  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5771	    0D78  66| 40			 inc	 eax   ; increment the count
   5772	    0D7A  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5773	    0D7F				 skiparps:
   5774						 ;-----------------------------------------------------------------
   5775
   5776						 ;mov	 ebx, 3200
   5777						 ;int	 0fdh
   5778
   5779	    0D7F  66| BB 00008600		 mov	 ebx, S_Base
   5780	    0D85  66| 81 C3 000000A8		 add	 ebx, S_DPD_Count  ; counter
   5781	    0D8C  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5782						 ;mov	 ebx, 3220
   5783						 ;int	 0fdh
   5784
   5785	    0D91			 not_NIC:
   5786					 ;-------------------------------------------------------------------
   5787						 ;mov	 eax, esi   ; unstall the transmitter
   5788						 ;mov	 dx, ax
   5789						 ;add	 dx, 0eh
   5790						 ;mov	 ax, 3003h
   5791						 ;out	 dx, ax
   5792					 ;W_End2:
   5793						 ;in	  ax, dx
   5794						 ;and	  ax, 1000h			  ;Check status
   5795						 ;jnz	  W_End2
   5796					 ;-------------------------------------------------------------------
   5797	    0D91  B8 00A0			 mov	 ax, 0a0h  ;ack	PIC 2
   5798	    0D94  8B D0				 mov	 dx, ax
   5799	    0D96  B0 20				 mov	 al, 020h
   5800	    0D98  EE				 out	 dx, al
   5801	    0D99  B8 0020			 mov	 ax, 020h  ;ack	PIC 1
   5802	    0D9C  8B D0				 mov	 dx, ax
   5803	    0D9E  B0 20				 mov	 al, 020h
   5804	    0DA0  EE				 out	 dx, al
   5805
   5806	    0DA1  0F A1			 pop fs
   5807	    0DA3  66| 5E		 pop esi
   5808	    0DA5  66| 5F		 pop edi
   5809	    0DA7  66| 5B		 pop ebx
   5810	    0DA9  66| 59		 pop ecx
   5811	    0DAB  66| 5A		 pop edx
   5812	    0DAD  66| 58		 pop eax
   5813							 ;-----------------------------------------------------------------
   5814							 ;changed this code on 7-7-2004
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 103
prcycle.ASM



   5815	    0DAF  66| 52				 push	 edx
   5816	    0DB1  66| 9C				 pushfd	; turn off NT flag in the CPU not in the TSS
   5817							 ; so that CPU will return to its application during IRETD not to
   5818							 ;  exit from the task using link field	in the TSS
   5819	    0DB3  66| 5A				 pop	 edx
   5820	    0DB5  66| 81 E2 FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   5821	    0DBC  66| 52				 push	 edx
   5822	    0DBE  66| 9D				 popfd
   5823	    0DC0  66| 5A				 pop	 edx
   5824							 ;-----------------------------------------------------------------
   5825
   5826	    0DC2  FB					 sti	 ; enable interrupts
   5827	    0DC3  66| CF				 iretd
   5828
   5829	    0DC5			 OtherBegin73	   ENDP
   5830
   5831		  = RCODESEG:0DC5	 RCodeLen     =	      $
   5832					 ;-----------------------------------------------------------------
   5833	    0DC5			 RCodeSeg	 ENDS
   5834							 END	 Start
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 104
Symbol Table




Symbol Name		Type   Value			   Cref	(defined at #)

??0000			Near   PCODESEG:00AF		   3149	 #3151
??0001			Near   PCODESEG:00B9		   3154	 #3156
??0002			Near   PCODESEG:00BC		   #3158  3161
??0003			Near   PCODESEG:00CA		   #3168  3171
??0004			Near   PCODESEG:00D8		   #3178  3181
??0005			Near   PCODESEG:0102		   3195	 #3197
??0006			Near   PCODESEG:010C		   3200	 #3202
??0007			Near   PCODESEG:010F		   #3204  3207
??0008			Near   PCODESEG:011D		   #3214  3217
??0009			Near   PCODESEG:012B		   #3224  3227
??DATE			Text   "05/19/10"
??FILENAME		Text   "prcycle	"
??TIME			Text   "12:24:50"
??VERSION		Number 0205
@CPU			Text   0D8FH			   #19
@CURSEG			Text   RCODESEG			   #579	 #1132	#1152  #1171  #1194  #1212  #1230  #1246  #1329	 #1356	  +
							   #1393  #1431	 #1470	#1509  #1548  #1593  #1649  #1688  #1777  #1816	  +
							   #1825  #1845	 #1855	#1865  #1876  #1885  #1894  #1904  #1914  #1933	  +
							   #1951  #1966	 #2101	#3074  #3631  #3655  #3941
@FILENAME		Text   PRCYCLE
@WORDSIZE		Text   2			   #19	#579  #1132  #1152  #1171  #1194  #1212	 #1230	#1246  #1329	  +
							   #1356  #1393	 #1431	#1470  #1509  #1548  #1593  #1649  #1688  #1777	  +
							   #1816  #1825	 #1845	#1855  #1865  #1876  #1885  #1894  #1904  #1914	  +
							   #1933  #1951	 #1966	#2101  #3074  #3631  #3655  #3941
A2LDT			Byte   APP2LDTSEG:0000		   #1331  1335	1340  1344  1346
ABDTEMP			Dword  RDATASEG:01DB		   #3886
ALDT			Byte   APP1LDTSEG:0000		   #1248  1276	1294  1299  1302  1313	1317  1321  1323  4059
ALTSTAT			Byte   RDATASEG:0302		   3106	 3122  #3912
ANYCOUNTER		Dword  RDATASEG:01CD		   #3879  4936	4949  4951  4964
AOADISP			Near   ----:---- Extern		   #551	 4607
AOAMINIL1		Near   ----:---- Extern		   #553	 4694
AOAMINIW1		Near   ----:---- Extern		   #554	 4793
APP1CODE		Struct APP1LDTSEG:0010 DESC	   #1295  1299
APP1CODE_SEL		Number 0014			   #1299  1300	1632
APP1DATA		Struct APP1LDTSEG:0008 DESC	   #1292  1294
APP1DATA_SEL		Number 000C			   #1294  1631	1634
APP1LDNUM		Number 0007			   #1323  4058
APP1LDT			Struct RDATASEG:00D8 DESC	   #3756  3837
APP1LDTLEN		Number APP1LDTSEG:0038		   #1324  3756	3771  3777
APP1LDT_SEL		Number 00D8			   1637	 #3837
APP1STACK		Struct APP1LDTSEG:0000 DESC	   #1274  1276
APP1STACK0		Struct APP1LDTSEG:0020 DESC	   #1311  1313
APP1STACK0_SEL		Number 0024			   #1313  1598
APP1STACK1		Struct APP1LDTSEG:0028 DESC	   #1315  1317
APP1STACK1_SEL		Number 002C			   #1317  1600
APP1STACK2		Struct APP1LDTSEG:0030 DESC	   #1319  1321
APP1STACK2_SEL		Number 0034			   #1321  1602
APP1STACKLEN		Number 0200			   #1905  1906
APP1STACK_SEL		Number 0004			   #1276  1633
APP1TASKTSS		Byte   APP1TSSSEG:0000		   #1595  5026	5094  5151  5215
APP1TSS			Struct RDATASEG:00C8 DESC	   #3752  3829
APP1TSSADDR		Dword  RDATASEG:0413		   #3926  4027
APP1TSSC		Struct RDATASEG:00E0 DESC	   #3758  3830
APP1TSSC_SEL		Number 00E0			   1091	 #3830
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 105
Symbol Table



APP1TSSE		Struct RDATASEG:00F8 DESC	   #3764  3832
APP1TSSE_SEL		Number 00F8			   #3832
APP1TSSLEN		Number APP1TSSSEG:0070		   #1643  3752	3754  3758  3760  3848
APP1TSSRW		Struct RDATASEG:00D0 DESC	   #3754  3835
APP1TSSRW_SEL		Number 00D0			   #3835  5017	5092  5149
APP1TSSS		Struct RDATASEG:00E8 DESC	   #3760  3831
APP1TSSS_SEL		Number 00E8			   1077	 #3831
APP1TSST		Struct RDATASEG:00F0 DESC	   #3762  3833
APP1TSST_SEL		Number 00F0			   #3833
APP1TSS_SEL		Number 00C8			   1121	 #3829
APP1_SCH_GATE		Struct APP1LDTSEG:0018 GATE	   #1300  1302
APP1_SCH_SEL		Number 001C			   #1302
APP2CODE		Struct APP2LDTSEG:0010 DESC	   #1341  1344
APP2CODE_SEL		Number 0014			   #1344  1670
APP2DATA		Struct APP2LDTSEG:0008 DESC	   #1336  1340
APP2DATA_SEL		Number 000C			   #1340  1669	1672
APP2LDNUM		Number 0003			   #1346
APP2LDT			Struct RDATASEG:0110 DESC	   #3771  3838
APP2LDTC		Struct RDATASEG:0128 DESC	   #3777
APP2LDTLEN		Number APP2LDTSEG:0018		   #1347
APP2LDT_SEL		Number 0110			   1675	 #3838
APP2STACK		Struct APP2LDTSEG:0000 DESC	   #1333  1335
APP2STACK_SEL		Number 0004			   #1335  1671
APP2TASKTSS		Byte   APP2TSSSEG:0000		   #1650  5055	5233
APP2TSS			Struct RDATASEG:0100 DESC	   #3767  3834
APP2TSSC		Struct RDATASEG:0118 DESC	   #3773
APP2TSSLEN		Number APP2TSSSEG:0400		   #1680  3767	3769  3773  3775
APP2TSSRW		Struct RDATASEG:0108 DESC	   #3769  3836
APP2TSSRWC		Struct RDATASEG:0120 DESC	   #3775
APP2TSSRW_SEL		Number 0108			   #3836  5050	5212  5227
APP2TSS_SEL		Number 0100			   1111	 #3834
APPGDTPTR		Dword  RDATASEG:01DF		   #3887  4036
APPL1RELOCATE		Number 0000			   #565	 1274  1292  1295  1311	 1315  1319  1333  1336	 1341  1722
APPLNUM			Byte   ----:---- Extern		   #548	 4979
APPSCHEDULE		Far    DEMOCODESEG:008C		   1747	 #2237
APP_SCHEDULER_GATE	Struct DEMOLDTSEG:0078 GATE	   #1747  1763
APP_SCHEDULER_SEL	Number 007C			   #1763
ASCII			Byte   RDATASEG:0307		   3248	 3249  3254  3277  3280	 3286  3290  3294  3298	 3302  3306  3310 +
							   3314	 3318  3322  3326  3330	 3334  3338  3342  3346	 3350  3354  3358 +
							   3362	 3366  3370  3374  3441	 #3917
AT386CGATE		Number 008C			   #380	 1300  1741  1743  1745	 1747  1749  1751  1753	 1756
AT386IGATE		Number 008E			   #381	 837
AT386TGATE		Number 008F			   #382	 585  587  589	591  593  595  597  599	 601  603  605	607  609  +
							   611	613  616  623  625  627	 629  631  633	635  637  639  641  643	  +
							   645	647  649  651  653  655	 657  659  661	663  665  667  669  671	  +
							   673	675  677  679  681  683	 685  687  689	691  693  695  697  699	  +
							   701	703  705  707  709  711	 713  715  717	719  721  723  725  727	  +
							   729	731  733  735  737  739	 741  743  745	747  749  751  753  755	  +
							   757	759  761  763  765  767	 769  771  773	775  777  779  781  783	  +
							   785	787  789  791  793  795	 797  799  801	803  805  807  809  811	  +
							   813	815  817  819  821  828	 830  832  846	848  850  852  854  856	  +
							   858	860  862  864  866  868	 870  872  874	876  878  880  882  884	  +
							   886	888  890  892  894  896	 898  900  902	904  906  908  910  912	  +
							   914	916  918  920  922  924	 926  928  930	932  934  936  938  940	  +
							   942	944  946  948  950  952	 954  956  958	960  962  964  966  968	  +
							   970	972  974  976  978  980	 982  984  986	988  990  992  994  996	  +
							   998	1000  1002  1004  1006	1008  1010
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 106
Symbol Table



AT386TSS		Number 0089			   #379	 3695  3703  3705  3707	 3709  3711  3729  3752	 3758  3760  3767 +
							   3773
ATCCO			Number 009C			   #372
ATCCOR			Number 009E			   #373
ATCE			Number 0098			   #370	 1136  1156  1175  1198	 1216  1234  1295  1341	 1697  1699  1701 +
							   1722	 3699  3701  3725  3782	 3784  3788
ATCER			Number 009A			   #371
ATDR			Number 0090			   #366
ATDW			Number 0092			   #367	 1178  1292  1336  1691	 1693  1695  1703  1708	 1710  1712  1720 +
							   3684	 3686  3693  3723  3734	 3737  3754  3769  3775	 3780  3786
ATDWA			Number 0093			   #368	 1139  1159  1184  1201	 1219  1237
ATLDT			Number 0082			   #377	 3697  3713  3715  3717	 3719  3721  3727  3756	 3771  3777
ATSWA			Number 0096			   #369	 1333
ATTASKGATE		Number 0085			   #378	 1077  1091  1101  1109	 1111  1113  1115  1117	 1121  1123
BASEOFCODE		Number 0000			   #566	 1295  1341
BUFFER			Struct DEMOLDTSEG:0048 DESC	   #1712  1737
BUFFER_SEL		Number 004C			   #1737  2412
BXP1S			Dword  RDATASEG:041B		   #3930  4312	4865
BXPOINTER1		Dword  ----:---- Extern		   #550	 2402  2416  4311  4866	 4947  4955  4988  4999
CAPLOCK			Byte   RDATASEG:0304		   3139	 3140  3143  3147  3193	 3262  3268  #3914
CARRY1			Near   RCODESEG:0023		   3971	 #3974
CHAROUT			Near   DEMOCODESEG:0344		   2771	 #2775
CHAROUT1		Near   DEMOCODESEG:03CF		   2836	 2863  #2867
CLDT			Byte   GETCHARLDTSEG:0000	   #1154  1158	1161  1163  4079
CLEARNEXT		Near   DEMOCODESEG:0279		   #2648  2651
CLEARSCREEN		Near   ----:---- Extern		   #433
CLOCK_TICK_RATE		Number 001234DC			   #426	 427
CLSCREEN		Far    DEMOCODESEG:029E		   1095	 #2679
CMPEQUAL		Near   PCODESEG:03C4		   3431	 #3434
CMPEQUAL2		Near   PCODESEG:03E7		   3448	 #3451
CONTINUEREAD		Near   RCODESEG:0638		   4922	 #4942
CPY0200			Near   RCODESEG:0816		   5081	 #5145
CPY0200SKP		Near   RCODESEG:0888		   5140	 #5196
CTRLSTAT		Byte   RDATASEG:0301		   3102	 3118  #3911
CURSOROK		Near   DEMOCODESEG:033F		   2769	 #2772
CURSOROK1		Near   DEMOCODESEG:03CA		   2861	 #2864
D32			Number 0040			   #407	 1336  1691  1693  1697	 1699  1701  1703  1722	 3723  3725  3784 +
							   3788
DEMOBEGIN		Far    DEMOCODESEG:0000		   #2110  2141
DEMOCODE		Struct DEMOLDTSEG:0018 DESC	   #1697  1730
DEMOCODELEN		Number DEMOCODESEG:0464		   1697	 1699  1701  #3066  3725
DEMOCODE_SEL		Number 001F			   #1730  2140
DEMOLDNUM		Number 000C			   #1725  4103
DEMOLDT			Byte   DEMOLDTSEG:0000		   #1690  1725	1727  1728  1729  1730	1731  1732  1733  1734	1735  1736+
							   1737	 1739  1758  1760  1761	 1762  1763  1764  1765	 1766  1768  4102
DEMOLDTD		Struct RDATASEG:0028 DESC	   #3697  3802
DEMOLDTLEN		Number 00A0			   #1758  3697
DEMOLDT_SEL		Number 0028			   1802	 #3802	4257
DEMOSTACK0		Struct DEMOLDTSEG:0000 DESC	   #1691  1727
DEMOSTACK0LEN		Number 0200			   1691	 1779  #1817  1818  2137
DEMOSTACK0_SEL		Number 0004			   #1727  1780	2135
DEMOSTACK1		Struct DEMOLDTSEG:0008 DESC	   #1693  1728
DEMOSTACK1LEN		Number 01F6			   1693	 1781  #1826  1837
DEMOSTACK1_SEL		Number 000D			   #1728  1782
DEMOSTACK3		Struct DEMOLDTSEG:0010 DESC	   #1695  1729
DEMOSTACK3LEN		Number 0200			   1139	 1371  1695  #1846  1847  2139
DEMOSTACK3_SEL		Number 0017			   #1729  2138
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 107
Symbol Table



DEMOTSS			Struct RDATASEG:0020 DESC	   #3695  3800
DEMOTSSLEN		Number DEMOTSSSEG:006A		   #1807  3695	3786
DEMOTSSRW		Struct RDATASEG:0148 DESC	   #3786  3801
DEMOTSSRW_SEL		Number 0148			   #3801  5119	5175
DEMOTSS_SEL		Number 0020			   #3800  4255
DISPLAYBEGIN		Far    DEMOCODESEG:0443		   616	1107  #3032
DLDT			Byte   GETDECLDTSEG:0000	   #1196  1200	1203  1205  4087
DMADATA			Struct RDATASEG:0130 DESC	   #3780  3839
DMADATA_SEL		Number 0130			   #3839
DPL0			Number 0000			   #386	 1691
DPL1			Number 0020			   #387	 1693
DPL2			Number 0040			   #388
DPL3			Number 0060			   #389	 1300  1695  1697  1741	 1743  1745  1747  1749	 1751  1753  1756 +
							   3686
DUMMY			Struct RDATASEG:0000 DESC	   #3680
DUMMYDATA		Byte   GLOBALDATASEG:0000	   #1935
D_ADDROFFSET		Number 0011			   #538
EFFGDT			Byte   RDATASEG:0018		   #3688  3795	4159
EOICOM			Number 0020			   #561
ETHERDESC		Struct RDATASEG:0140 DESC	   #3784  3818
ETHERNETRECEIVECODELEN	Number ETHERNETRECEIVE:00E2	   #2091  3784
ETHERNETRECEIVE_SEL	Number 0140			   837	#3818
EXIT_GETINT32		Near   RCODESEG:0375		   4499	 #4518
FDC_INT			Far    DEMOCODESEG:03E3		   613	#2897
FINDIT			Near   PCODESEG:0517		   3569	 #3587
FLOPPYREADY		Byte   RDATASEG:01E3		   2907	 #3891
G4DATA			Struct RDATASEG:00B0 DESC	   #3731  3827
G4DATA_SEL		Number 00B0			   #3827  5319
GDNUM			Number 0028			   #3795  4158
GDT			Byte   RDATASEG:0000		   #3679  3794	3797  3798  3800  3801	3802  3803  3804  3805	3806  3807+
							   3808	 3809  3810  3811  3812	 3813  3814  3815  3816	 3817  3818  3820 +
							   3822	 3825  3826  3827  3829	 3830  3831  3832  3833	 3834  3835  3836 +
							   3837	 3838  3839  3840  3841	 4034
GDTLEN			Number 0158			   #3794  3855
GETC			Near   DEMOCODESEG:0396		   2833	 #2838
GETCHAR			Near   RCODESEG:02B1		   4392	 4393  #4395
GETCHAR1		Near   RCODESEG:02CF		   #4410
GETCHAR32		Far    DEMOCODESEG:02D4		   1103	 #2719
GETCHAR32BUFF		Far    DEMOCODESEG:0358		   1105	 #2806
GETCHARBEGIN		Far    RCODESEG:0299		   1440	 #4378	4444
GETCHARCODE		Struct GETCHARLDTSEG:0000 DESC	   #1156  1158
GETCHARCODE_SEL		Number 0004			   #1158  1451	4432
GETCHARLDNUM		Number 0002			   #1163  4078
GETCHARLDT		Struct RDATASEG:0070 DESC	   #3715  3812
GETCHARLDTLEN		Number GETCHARLDTSEG:0010	   #1164  3715
GETCHARLDT_SEL		Number 0070			   1456	 #3812
GETCHARSTACK		Struct GETCHARLDTSEG:0008 DESC	   #1159  1161
GETCHARSTACKLEN		Number 0200			   1159	 1446  #1856  1857
GETCHARSTACK_SEL	Number 000C			   #1161  1452	4435
GETCHARTSS		Struct RDATASEG:0040 DESC	   #3703  3807
GETCHARTSSLEN		Number GETCHARTSSSEG:0069	   #1460  3703
GETCHARTSS_SEL		Number 0040			   1117	 #3807
GETCHARV		Near   RCODESEG:02ED		   4431	 #4434
GETCURSOR		Far    DEMOCODESEG:01E6		   1097	 #2538
GETDEC			Near   RCODESEG:0317		   4462	 4463  #4464
GETDEC1			Near   RCODESEG:0335		   #4479
GETDECBEGIN		Far    RCODESEG:02FF		   1479	 #4449	4542
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 108
Symbol Table



GETDECCODE		Struct GETDECLDTSEG:0000 DESC	   #1198  1200
GETDECCODE_SEL		Number 0004			   #1200  1490	4531
GETDECLDNUM		Number 0002			   #1205  4086
GETDECLDT		Struct RDATASEG:0078 DESC	   #3717  3813
GETDECLDTLEN		Number GETDECLDTSEG:0010	   #1206  3717
GETDECLDT_SEL		Number 0078			   1495	 #3813
GETDECSTACK		Struct GETDECLDTSEG:0008 DESC	   #1201  1203
GETDECSTACKLEN		Number 0200			   1201	 1219  1485  #1877  1878
GETDECSTACK_SEL		Number 000C			   #1203  1491	4534
GETDECTSS		Struct RDATASEG:0048 DESC	   #3705  3808
GETDECTSSLEN		Number GETDECTSSSEG:0069	   #1499  3705
GETDECTSS_SEL		Number 0048			   1115	 #3808
GETDECV			Near   RCODESEG:038B		   4530	 #4533
GETKEY			Near   RCODESEG:03D2		   4585	 4588  #4591
GETKEY1			Near   RCODESEG:03E0		   #4600
GETKEYFORMENU		Near   ----:---- Extern		   #434
GETKEYV			Near   RCODESEG:0402		   4616	 #4618
GETNEXTDIGIT_GETINT	Near   RCODESEG:0342		   #4484  4511
GETSEC			Near   RCODESEG:045A		   4679	 4680  #4681
GETSEC1			Near   RCODESEG:0470		   #4692
GETSECBEGIN		Far    RCODESEG:0414		   1518	 #4638	4735
GETSECCODE		Struct GETSECLDTSEG:0000 DESC	   #1216  1218
GETSECCODE_SEL		Number 0004			   #1218  1529	1568  4704
GETSECLDNUM		Number 0002			   #1223  4094
GETSECLDT		Struct RDATASEG:0080 DESC	   #3719  3814
GETSECLDTLEN		Number GETSECLDTSEG:0010	   #1224  3719
GETSECLDT_SEL		Number 0080			   1534	 1573  #3814
GETSECSTACK		Struct GETSECLDTSEG:0008 DESC	   #1219  1221
GETSECSTACKLEN		Number 0200			   1524	 1563  #1886  1887
GETSECSTACK_SEL		Number 000C			   #1221  1530	1569  4706
GETSECTSS		Struct RDATASEG:0050 DESC	   #3707  3809
GETSECTSSLEN		Number GETSECTSSSEG:0069	   #1538  3707
GETSECTSS_SEL		Number 0050			   1113	 #3809
GETSECV			Near   RCODESEG:0485		   4703	 #4705
GETTASKPTR		Far    DEMOCODESEG:0411		   #2951
GET_PARAMETER		Near   ----:---- Extern		   #436
GKEYBEGIN		Far    RCODESEG:039E		   1365	 #4547	4628
GKEYCODE		Struct GKEYLDTSEG:0000 DESC	   #1136  1138
GKEYCODE_SEL		Number 0004			   #1138  1376	4617
GKEYLDNUM		Number 0002			   #1143  4070
GKEYLDT			Struct RDATASEG:0068 DESC	   #3713  3811
GKEYLDTLEN		Number GKEYLDTSEG:0010		   #1144  3713
GKEYLDT_SEL		Number 0068			   1381	 #3811
GKEYSTACK		Struct GKEYLDTSEG:0008 DESC	   #1139  1141
GKEYSTACK_SEL		Number 000C			   #1141  1377	4618
GKEYTSS			Struct RDATASEG:0060 DESC	   #3711  3806
GKEYTSSLEN		Number GKEYTSSSEG:0069		   #1385  3711
GKEYTSS_SEL		Number 0060			   1123	 #3806
GL			Number 0080			   #408
GLDT			Byte   GKEYLDTSEG:0000		   #1134  1138	1141  1143  4071
GLOBALDATA		Struct RDATASEG:00B8 DESC	   #3734  3820
GLOBALDATALEN		Number GLOBALDATASEG:0112	   1178	 #1943	3734
GLOBALDATA_SEL		Number 00B8			   #3820
GOBACKTOLOOP		Near   RCODESEG:027A		   4328	 #4342
GOBACKTOMENU		Near   RCODESEG:0956		   5225	 5232  #5272
GOSEARCH		Near   RCODESEG:025A		   4288	 #4329
GOTOPCODE		Struct DEMOLDTSEG:0058 DESC	   #1722  1739
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 109
Symbol Table



GOTOPCODE_SEL		Number 005C			   #1739  1756
GOTOPGATE		Struct DEMOLDTSEG:0098 GATE	   #1756  1768
GOTOPGATE_SEL		Number 009C			   #1768
GTCHAR			Near   PCODESEG:0495		   #3528  3538
HEXTABLE		Byte   RDATASEG:0158		   541	#3843
HEXTABLEP		Byte   PROTMODEPROCDATASEG:0000	   #1916  2202
HTIMERBEGIN		Far    DEMOCODESEG:0167		   601	#2440
HZ			Number 0064			   #425	 427  427
ICREGP			Number 0020			   #562
IDT			Byte   IDTSEG:0000		   #580	 1126
IDTLEN			Number 0800			   #1126  3856
IFL			Number 0200			   #412
ILDT			Near   RCODESEG:019A		   #4200  4211
IMASKREGV		Byte   RDATASEG:0198		   #3858  4053
IMREGP			Number 0021			   #563	 4052
INDEXCNT		Dword  RDATASEG:0168		   541	#3846
INDEXCNTP		Dword  PROTMODEPROCDATASEG:0010	   #1919  2200	2201
INITG			Near   RCODESEG:015C		   #4163  4178
INITGDT			Near   RCODESEG:0156		   4046	 #4157
INITIDT			Near   RCODESEG:01B5		   4047	 #4218
INITLDT			Near   RCODESEG:019A		   4061	 4073  4081  4089  4097	 4104  4111  #4199
INITLOAD		Near   RCODESEG:0683		   4297	 #4974
INTEXCEPTION		Far    INTEXCEPTIONSEG:0000	   585	587  589  591  593  595	 597  599  605	607  609  623  625  627	  +
							   629	631  633  635  637  639	 641  643  645	647  649  651  653  655	  +
							   657	659  661  663  665  667	 669  671  673	675  677  679  681  683	  +
							   685	687  689  691  693  695	 697  699  701	703  705  707  709  711	  +
							   713	715  717  719  721  723	 725  727  729	731  733  735  737  739	  +
							   741	743  745  747  749  751	 753  755  757	759  761  763  765  767	  +
							   769	771  773  775  777  779	 781  783  785	787  789  791  793  795	  +
							   797	799  801  803  805  807	 809  811  813	815  817  819  828  830	  +
							   832	846  848  850  852  854	 856  858  860	862  864  866  868  870	  +
							   872	874  876  878  880  882	 884  886  888	890  892  894  896  898	  +
							   900	902  904  906  908  910	 912  914  916	918  920  922  924  926	  +
							   928	930  932  934  936  938	 940  942  944	946  948  950  952  954	  +
							   956	958  960  962  964  966	 968  970  972	974  976  978  980  982	  +
							   984	986  988  990  992  994	 996  998  1000	 1002  1004  1006  1008	  +
							   1010	 1012  1014  1016  1018	 1020  1022
INTEXCEPTIONCODELEN	Number INTEXCEPTIONSEG:0001	   #1956  3788
INTEXCEPTIONDESC	Struct RDATASEG:0150 DESC	   #3788  3841
INTEXCEPTION_SEL	Number 0150			   585	587  589  591  593  595	 597  599  605	607  609  623  625  627	  +
							   629	631  633  635  637  639	 641  643  645	647  649  651  653  655	  +
							   657	659  661  663  665  667	 669  671  673	675  677  679  681  683	  +
							   685	687  689  691  693  695	 697  699  701	703  705  707  709  711	  +
							   713	715  717  719  721  723	 725  727  729	731  733  735  737  739	  +
							   741	743  745  747  749  751	 753  755  757	759  761  763  765  767	  +
							   769	771  773  775  777  779	 781  783  785	787  789  791  793  795	  +
							   797	799  801  803  805  807	 809  811  813	815  817  819  828  830	  +
							   832	846  848  850  852  854	 856  858  860	862  864  866  868  870	  +
							   872	874  876  878  880  882	 884  886  888	890  892  894  896  898	  +
							   900	902  904  906  908  910	 912  914  916	918  920  922  924  926	  +
							   928	930  932  934  936  938	 940  942  944	946  948  950  952  954	  +
							   956	958  960  962  964  966	 968  970  972	974  976  978  980  982	  +
							   984	986  988  990  992  994	 996  998  1000	 1002  1004  1006  1008	  +
							   1010	 1012  1014  1016  1018	 1020  1022
IOPL0			Number 0000			   #400
IOPL1			Number 1000			   #401
IOPL2			Number 2000			   #402
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 110
Symbol Table



IOPL3			Number 3000			   #403
JUMPOFFSET1		Word   ----:---- Extern		   #548	 5031  5058
JUMPOFFSET2		Word   ----:---- Extern		   #548	 5236
KEYBOARD_INT		Far    PCODESEG:0000		   603	#3080
KEYTABLE1		Byte   RDATASEG:01E4		   3243	 #3894
KHEAD			Byte   RDATASEG:0407		   2742	 2830  3425  3439  3452	 #3920
KKQ			Byte   RDATASEG:0308		   2729	 2817  3423  #3919
KLDT			Byte   GETSECLDTSEG:0000	   #1214  1218	1221  1223  4095
KTAIL			Byte   RDATASEG:0408		   2743	 2748  2759  2831  2839	 2850  3426  #3921
LABEL210		Near   RCODESEG:096D		   #5294  5300
LATCH			Number 2E9C			   #427
LOADAPP			Near   RCODESEG:06DC		   4991	 #5002
LOADAPP2		Near   RCODESEG:06B5		   4980	 #4992
LOADAPPLICATIONS	Near   RCODESEG:0226		   #4296
LOADARRAY		Byte   RDATASEG:0176		   #3853
LOADCOUNTER		Byte   RDATASEG:01D1		   #3880
LOADERSIZE1		Word   ----:---- Extern		   #546	 4982
LOADERSIZE1M		Word   ----:---- Extern		   #550	 4308  4863  4885  4983	 4994
LOADERSIZE2		Word   ----:---- Extern		   #546	 4993
LOADFLAG		Byte   ----:---- Extern		   #550	 4293  5003
LOADOFFSET1		Dword  ----:---- Extern		   #548	 4986  5057
LOADOFFSET2		Dword  ----:---- Extern		   #548	 4998  5235
LOADONESECFORAPPRESTOR	Near   RCODESEG:04B3		   4719	 #4727
E
LOADONESECFORMENU	Near   RCODESEG:0448		   4655	 #4667
LOOP1			Near   RCODESEG:01FC		   #4276  4319	4332
LOOPSTACK1		Near   DEMOCODESEG:00EB		   #2343  2371
LSIZE1MS		Word   RDATASEG:0419		   #3929  4309	4862
L_KEYBD1		Near   PCODESEG:0451		   3103	 3107  3111  3115  3119	 3123  3130  3137  3183	 3229  3237  3436 +
							   3454	 #3479
L_KEYBD10		Near   PCODESEG:0076		   #3131  3463
L_KEYBD11		Near   PCODESEG:008D		   #3138  3461
L_KEYBD12		Near   PCODESEG:00E0		   #3184  3459
L_KEYBD13		Near   PCODESEG:0133		   #3231  3457
L_KEYBD14		Near   PCODESEG:014C		   #3238  3478
L_KEYBD15		Near   PCODESEG:03EC		   3242	 #3453
L_KEYBD18		Near   PCODESEG:01B4		   3261	 #3266
L_KEYBD2		Near   PCODESEG:03EE		   3099	 #3455
L_KEYBD20		Near   PCODESEG:01CF		   3253	 3258  3267  3270  #3275
L_KEYBD21		Near   PCODESEG:01E6		   3276	 #3282
L_KEYBD23		Near   PCODESEG:03A6		   3285	 #3421
L_KEYBD24		Near   PCODESEG:03A6		   3281	 3291  3295  3299  3303	 3307  3311  3315  3319	 3323  3327  3331 +
							   3335	 3339  3343  3347  3351	 3355  3359  3363  3367	 3371  3375  #3422
L_KEYBD25		Near   PCODESEG:0304		   3287	 #3376
L_KEYBD26		Near   PCODESEG:01FC		   #3288  3420
L_KEYBD27		Near   PCODESEG:0208		   #3292  3418
L_KEYBD28		Near   PCODESEG:0214		   #3296  3416
L_KEYBD29		Near   PCODESEG:0220		   #3300  3414
L_KEYBD3		Near   PCODESEG:0025		   #3100  3477
L_KEYBD30		Near   PCODESEG:022C		   #3304  3412
L_KEYBD31		Near   PCODESEG:0238		   #3308  3410
L_KEYBD32		Near   PCODESEG:0244		   #3312  3408
L_KEYBD33		Near   PCODESEG:0250		   #3316  3406
L_KEYBD34		Near   PCODESEG:025C		   #3320  3404
L_KEYBD35		Near   PCODESEG:0268		   #3324  3402
L_KEYBD36		Near   PCODESEG:0274		   #3328  3400
L_KEYBD37		Near   PCODESEG:0280		   #3332  3398
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 111
Symbol Table



L_KEYBD38		Near   PCODESEG:028C		   #3336  3396
L_KEYBD39		Near   PCODESEG:0298		   #3340  3394
L_KEYBD4		Near   PCODESEG:002E		   #3104  3475
L_KEYBD40		Near   PCODESEG:02A4		   #3344  3392
L_KEYBD41		Near   PCODESEG:02B0		   #3348  3390
L_KEYBD42		Near   PCODESEG:02BC		   #3352  3388
L_KEYBD43		Near   PCODESEG:02C8		   #3356  3386
L_KEYBD44		Near   PCODESEG:02D4		   #3360  3384
L_KEYBD45		Near   PCODESEG:02E0		   #3364  3382
L_KEYBD46		Near   PCODESEG:02EC		   #3368  3380
L_KEYBD47		Near   PCODESEG:02F8		   #3372  3378
L_KEYBD5		Near   PCODESEG:0037		   #3108  3473
L_KEYBD6		Near   PCODESEG:003F		   #3112  3471
L_KEYBD7		Near   PCODESEG:0047		   #3116  3469
L_KEYBD8		Near   PCODESEG:0053		   #3120  3467
L_KEYBD9		Near   PCODESEG:005F		   #3124  3465
MEMBASE			Dword  RDATASEG:040D		   2993	 #3924
MEMCX			Word   RDATASEG:0411		   #3925
MEMDATA			Struct RDATASEG:00C0 DESC	   #3737  3822
MEMDATA_SEL		Number 00C0			   1975	 2451  2502  #3822  4649  4713	4754  4812  4869  4899	4911  4925+
							   5097	 5124  5154  5180  5258	 5603
MEMFETCH		Far    DEMOCODESEG:0411		   #2970
MEMFLAG			Byte   RDATASEG:01D6		   542	#3882  4287  4290  4331	 4341
MEMFREE			Far    DEMOCODESEG:0442		   1087	 #3025
MEMINTERFACE		Far    DEMOCODESEG:0410		   #2941
MEMLIMIT		Dword  RDATASEG:0409		   2994	 #3923
MEMLOOP			Near   DEMOCODESEG:00BB		   #2274  2280
MEMMALLOC		Far    DEMOCODESEG:0412		   1089	 #2982
MEMORYOFFSET		Dword  RDATASEG:01D7		   542	#3883  4336
MEMPRINTOFFSET		Dword  RDATASEG:01C9		   #3878  4938	4948  4957  4962
MOVENEXT		Near   DEMOCODESEG:025B		   #2638  2643
MOVTSSUSERAPP1		Near   RCODESEG:07CD		   #5107  5112
MOVTSSUSERAPP2		Near   RCODESEG:0841		   #5163  5169
MOVTSSUSERAPP3		Near   RCODESEG:0802		   #5131  5136
MOVTSSUSERAPP4		Near   RCODESEG:0876		   #5187  5192
NDISP			Near   DEMOCODESEG:0332		   2763	 #2766
NDISP1			Near   DEMOCODESEG:03BD		   2854	 #2858
NEWLINE			Near   ----:---- Extern		   #435
NEXT			Near   DEMOCODESEG:02B5		   #2690  2692
NEXT100			Near   RCODESEG:0025		   3973	 #3976
NOMORESECTORS		Near   RCODESEG:066B		   4887	 #4961
NONEWLINEP		Near   DEMOCODESEG:011C		   2365	 #2368
NORMAL			Struct RDATASEG:0008 DESC	   #3684  3797
NORMAL_SEL		Number 0008			   1375	 1378  1379  1380  1417	 1450  1453  1454  1455	 1489  1492  1493 +
							   1494	 1528  1531  1532  1533	 1567  1570  1571  1572	 #3797	4358  4385+
							   4454	 4562  4669  4768
NORVIDTR		Struct RDATASEG:0192 PDESC	   #3857  4051	4148  4401  4471  4595	4687  4786
NOTDIGIT_GETINT		Near   RCODESEG:036D		   4506	 #4512
NOTTAIL			Near   PCODESEG:03C2		   3429	 #3432
NOTTAIL2		Near   PCODESEG:03E5		   3445	 #3449
NOT_NIC			Near   RCODESEG:0D91		   5629	 #5785
NTL			Number 4000			   #415
NUMLOCK			Byte   RDATASEG:0303		   3152	 3185  3186  3189  3198	 #3913
OTHER			Struct RDATASEG:0038 DESC	   #3701  3804
OTHERBEGIN0		Far    RCODESEG:09DC		   #5354
OTHERBEGIN1		Far    RCODESEG:09F1		   #5366
OTHERBEGIN10		Far    RCODESEG:0A84		   #5452
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 112
Symbol Table



OTHERBEGIN11		Far    RCODESEG:0A99		   #5464
OTHERBEGIN12		Far    RCODESEG:0AAE		   #5477
OTHERBEGIN13		Far    RCODESEG:0AC3		   611	#5489
OTHERBEGIN2		Far    RCODESEG:0A06		   #5378
OTHERBEGIN219		Far    RCODESEG:0B7E		   #5569
OTHERBEGIN3		Far    RCODESEG:0A1B		   #5390
OTHERBEGIN4		Far    RCODESEG:0A30		   #5403
OTHERBEGIN5		Far    RCODESEG:0A45		   #5415
OTHERBEGIN6		Far    RCODESEG:0A5A		   #5427
OTHERBEGIN7		Far    RCODESEG:0A6F		   #5439
OTHERBEGIN73		Far    RCODESEG:0B82		   821	#5583
OTHER_BEGIN0		Near   ----:---- Extern		   #555
OTHER_BEGIN1		Near   ----:---- Extern		   #555
OTHER_BEGIN10		Near   ----:---- Extern		   #557
OTHER_BEGIN11		Dword  ----:---- Extern		   #557
OTHER_BEGIN12		Dword  ----:---- Extern		   #557
OTHER_BEGIN13		Dword  ----:---- Extern		   #557
OTHER_BEGIN2		Near   ----:---- Extern		   #555
OTHER_BEGIN219		Near   ----:---- Extern		   #559
OTHER_BEGIN246		Near   ----:---- Extern		   #559
OTHER_BEGIN3		Dword  ----:---- Extern		   #555
OTHER_BEGIN4		Dword  ----:---- Extern		   #555
OTHER_BEGIN5		Dword  ----:---- Extern		   #555
OTHER_BEGIN6		Near   ----:---- Extern		   #557
OTHER_BEGIN7		Near   ----:---- Extern		   #557
OTHER_SEL		Number 0038			   611	821  #3804
PCODE			Struct RDATASEG:0138 DESC	   #3782  3840
PCODELEN		Number PCODESEG:055F		   #3624  3782
PCODE_SEL		Number 0138			   603	#3840
PL			Number 0001			   #419
PRINTDATA		Dword  RDATASEG:016C		   541	#3847
PRINTDATAP		Dword  PROTMODEPROCDATASEG:0014	   #1920  2194	2197  2207  2209
PRINTMEMORY		Near   RCODESEG:0264		   4291	 #4334
PRINTMEMP		Far    DEMOCODESEG:0099		   1749	 #2252
PRINTMEMPGATE_SEL	Number 0084			   #1764  4340
PRINTMEMPROCDATA	Struct DEMOLDTSEG:0038 DESC	   #1708  1734
PRINTMEMPROCDATA_SEL	Number 003C			   #1734  2266
PRINTMEMR		Near   ----:---- Extern		   #438
PRINTSTACKEXCEPTION	Far    RCODESEG:095C		   #5289  5355	5367  5379  5391  5404	5416  5428  5440  5453	5465  5478+
							   5496
PRINTSTACKPGATE_SEL	Number 008C			   #1765
PRINTSTP		Far    DEMOCODESEG:00CF		   1751	 #2320
PROMPT1			Byte   RDATASEG:019F		   #3865  4602
PROTCODE		Struct DEMOLDTSEG:0028 DESC	   #1701  1732
PROTCODE_SEL		Number 002C			   #1732  1745	1747  1749  1751  1753
PROTMODEPROCDATA	Struct DEMOLDTSEG:0030 DESC	   #1703  1733
PROTMODEPROCDATALEN	Number PROTMODEPROCDATASEG:0018	   1703	 #1922	3723
PROTMODEPROCDATA_SEL	Number 0034			   #1733  2261	2335
PROTMODEPROCGATE1	Struct DEMOLDTSEG:0070 GATE	   #1745  1762
PROTMODEPROCGATE2	Struct DEMOLDTSEG:0080 GATE	   #1749  1764
PROTMODEPROCGATE3	Struct DEMOLDTSEG:0088 GATE	   #1751  1765
PUTHEX32DATA		Struct RDATASEG:0090 DESC	   #3723  3816
PUTHEX32DATA_SEL	Number 0090			   2188	 #3816
PUTHEX32I		Struct RDATASEG:0098 DESC	   #3725  3817
PUTHEX32I_SEL		Number 0098			   601	613  616  1082	1087  1089  1093  1095	1097  1099  1103  1105	  +
							   1107	 1119  #3817
PUTHEX32P		Far    DEMOCODESEG:0031		   1119	 1745  #2179
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 113
Symbol Table



PUTHEX32PGATE_SEL	Number 0074			   #1762  2359
PUTHEX32R		Near   ----:---- Extern		   #431
PUTHEXLOOPP		Near   DEMOCODESEG:0049		   #2196  2210
RCODELEN		Number RCODESEG:0DC5		   3701	 #5831
RDATA			Struct RDATASEG:0018 DESC	   #3693  3805
RDATA_SEL		Number 0018			   2726	 2814  2903  2990  3089	 #3805	4657  4720  4758  4816	4855  4882+
							   5077	 5101  5158  5526
RDWTMEM			Far    DEMOCODESEG:012A		   1753	 #2396
RDWTMEMGATE		Struct DEMOLDTSEG:0090 GATE	   #1753  1766
RDWTMEMPGATE_SEL	Number 0094			   #1766  4946
READAGAIN		Near   RCODESEG:0569		   #4853  4940
READSECTORS		Near   RCODESEG:05B6		   #4884  4959
READSECTORSALL		Near   RCODESEG:0556		   4317	 #4837
READWRITE1		Near   DEMOCODESEG:0158		   #2419  2426
REAL			Near   RCODESEG:0143		   #4144  4371	4372
REALDATA		Struct DEMOLDTSEG:0050 DESC	   #1720  1735
REALDATA_SEL		Number 0054			   #1735  2398	4284  4301  4976  5020	5053
REALJUMPADDR		Word   RDATASEG:0172		   #3851  4589	4590
RELOCATE1		Number 0080			   #564	 1136  1139  1156  1159	 1175  1178  1184  1198	 1201  1216  1219 +
							   1234	 1237  1691  1693  1695	 1697  1699  1701  1703	 1720  3693  3695 +
							   3697	 3699  3701  3703  3705	 3707  3709  3711  3713	 3715  3717  3719 +
							   3721	 3723  3725  3727  3729	 3734  3752  3754  3756	 3758  3760  3767 +
							   3769	 3771  3775  3777  3780	 3782  3784  3786  3788	 3951  4024  4056 +
							   4068	 4076  4084  4092  4100	 4107  4145  4221  4372	 4393  4397  4408 +
							   4463	 4467  4477  4577  4680	 4682  4779  4781
RERUNFLAG		Word   RDATASEG:019D		   #3861  5079	5084
RESETPOINTER		Near   ----:---- Extern		   #437
RETN1			Near   PCODESEG:0543		   3573	 #3606
RETN2			Near   PCODESEG:0547		   3562	 3583  3603  #3609
RFL			Number 00010000			   #413
RFLW			Number 0001			   #414
ROUNDCHAR		Near   DEMOCODESEG:0321		   2753	 #2756
ROUNDCHAR1		Near   DEMOCODESEG:03AC		   2844	 #2847
RPL0			Number 0000			   #393	 1727
RPL1			Number 0001			   #394	 1728
RPL2			Number 0002			   #395
RPL3			Number 0003			   #396	 1729  1730
RUNAPPL			Near   RCODESEG:06E5		   4327	 #5012
RUNAPPLICATIONS		Near   RCODESEG:0255		   4294	 #4320
RUNFLAG			Dword  RDATASEG:01D2		   541	#3881  4989  5000  5022	 5207  5229  5270
RUNNEXT			Near   RCODESEG:08C5		   5025	 #5226
RWR			Number 0000			   #420
RWW			Number 0002			   #421
SCAN			Byte   RDATASEG:0306		   3097	 3098  3239  3245  #3916
SCRLOCK			Byte   RDATASEG:0305		   3232	 3233  3236  #3915
SCROLL			Far    DEMOCODESEG:0248		   1093	 #2626
SEARCH			Near   PCODESEG:04A7		   3533	 #3540
SEARCH1			Near   PCODESEG:04CC		   #3553  3561	3585  3604
SEARCH2			Near   PCODESEG:04E3		   3557	 #3564
SEARCH3			Near   PCODESEG:04E7		   #3567  3576
SEARCHBEGIN		Far    PCODESEG:0486		   1402	 #3522	3622
SEARCHCODE		Struct SEARCHLDTSEG:0000 DESC	   #1175  1177
SEARCHCODE_SEL		Number 0004			   #1177  1413
SEARCHDATA		Struct SEARCHLDTSEG:0008 DESC	   #1178  1180
SEARCHDATA_SEL		Number 000C			   #1180  1415	1416
SEARCHFORDATA		Struct SEARCHLDTSEG:0010 DESC	   #1181  1183
SEARCHFORDATA_SEL	Number 0014			   #1183  1412
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 114
Symbol Table



SEARCHKEY		Byte   GLOBALDATASEG:0010	   #1940  3524	3549
SEARCHLDNUM		Number 0004			   #1188  4110
SEARCHLDT		Struct RDATASEG:00A0 DESC	   #3727  3825
SEARCHLDTLEN		Number SEARCHLDTSEG:0020	   #1189  3727
SEARCHLDTS		Byte   SEARCHLDTSEG:0000	   #1173  1177	1180  1183  1186  1188	4109
SEARCHLDT_SEL		Number 00A0			   1418	 #3825
SEARCHLEN		Word   GLOBALDATASEG:0110	   #1941  3541	3551  3584  3593
SEARCHSTACK		Struct SEARCHLDTSEG:0018 DESC	   #1184  1186
SEARCHSTACKLEN		Number 0200			   1184	 1408  #1866  1867
SEARCHSTACK_SEL		Number 001C			   #1186  1414
SEARCHTSS		Struct RDATASEG:00A8 DESC	   #3729  3826
SEARCHTSSLEN		Number SEARCHTSSSEG:0069	   #1422  3729
SEARCHTSS_SEL		Number 00A8			   1109	 #3826
SETCURSOR		Far    DEMOCODESEG:0217		   1099	 #2583
SETERRORFLAG		Far    RCODESEG:0984		   #5310  5359	5371  5383  5395  5408	5420  5432  5444  5457	5469  5482
SHIFTSTAT		Byte   RDATASEG:0300		   3110	 3114  3125  3129  3132	 3136  3259  3271  3283	 #3910
SIZEOF_TSS1		Word   RDATASEG:0170		   #3848  5104	5161
SKIP			Near   DEMOCODESEG:0010		   #2133
SKIPARPS		Near   RCODESEG:0D7F		   5767	 #5773
SKIPCHANGE		Near   RCODESEG:0183		   4167	 #4177
SKIPDATA		Near   RCODESEG:0D01		   5731	 #5737
SKIPFINACK		Near   RCODESEG:0D2B		   5743	 #5749
SKIPGETACK		Near   RCODESEG:0CAD		   5707	 #5713
SKIPHEADER		Near   RCODESEG:0CD7		   5719	 #5725
SKIPRESET		Near   RCODESEG:0C39		   5672	 #5674
SKIPRESETS		Near   RCODESEG:0D55		   5755	 #5761
SKIPSYNACK		Near   RCODESEG:0C83		   5695	 #5701
SLSECNUM1MS		Word   RDATASEG:0417		   #3928  4306	4859
SPVAR			Word   RDATASEG:0199		   #3859  4050	4147  4400  4470  4594	4686  4785
SSVAR			Word   RDATASEG:019B		   #3860  4049
START			Near   RCODESEG:0000		   #3948  5834
STARTADDRESS		Struct DEMOLDTSEG:0040 DESC	   #1710  1736
STARTADDRESS_SEL	Number 0044			   #1736  2409
STARTLOGICALSECNUM1	Word   ----:---- Extern		   #546	 4984
STARTLOGICALSECNUM1M	Word   ----:---- Extern		   #550	 4305  4659  4662  4725	 4761  4765  4821  4860	 4985  4996
STARTLOGICALSECNUM2	Word   ----:---- Extern		   #546	 4995
STORECHAR		Byte   GLOBALDATASEG:000B	   #1938  3531	4421
STOREDEC		Dword  GLOBALDATASEG:000C	   #1939  4514
S_APP_STRING		Number 0024			   #461
S_BASE			Number 8600			   #532	 1977  2453  2504  4007	 4234  4651  4715  4756	 4814  4874  4901 +
							   4916	 4930  5322  5326  5606	 5640  5667  5677  5696	 5708  5720  5732 +
							   5744	 5756  5768  5779
S_CIRLISTSTATE		Number 0080			   #478
S_CLOCK_HZ		Number 0014			   #453
S_CYCLE_COUNT		Number 0010			   #450
S_DATE			Number 0124			   #520
S_DPD_COUNT		Number 00A8			   #490	 5641  5668  5780
S_DUMMY			Number 0094			   #485
S_EINIT_RET		Number 00A0			   #487
S_ERR			Number 0128			   #521
S_ERROR_CODE		Number 001C			   #457	 5327
S_ERROR_FLAG		Number 0018			   #455	 5323
S_IDTOFFSET		Number 000C			   #449	 4235
S_INCOUNT		Number 0070			   #473
S_INRECORD		Number 0084			   #479
S_IOBASE		Number 009C			   #486	 4008  5607
S_IO_FUNCTION_CODE	Number 0020			   #458
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 115
Symbol Table



S_ISRCOUNT		Number 008C			   #481
S_ISRSTIFLAG		Number 0090			   #483
S_ITCP_ARP_COUNT	Number 0118			   #515	 5769
S_ITCP_DAT_COUNT	Number 010C			   #512	 5733
S_ITCP_FACK_COUNT	Number 0110			   #513	 5745
S_ITCP_GACK_COUNT	Number 0104			   #510	 5709
S_ITCP_HDR_COUNT	Number 0108			   #511	 5721
S_ITCP_PRIOR_COUNT	Number 011C			   #516
S_ITCP_RESET_COUNT	Number 0114			   #514	 5757
S_ITCP_SACK_COUNT	Number 0100			   #509	 5697
S_LOCK1			Number 004C			   #465
S_LOCK2			Number 0050			   #466
S_LOCK3			Number 0054			   #467
S_LOCK4			Number 0058			   #468
S_LSERROR		Number 0140			   #524	 4875  4917  4931
S_NTFLAG		Number 007C			   #477
S_OUTCOUNT		Number 0074			   #475
S_OUTRECORD		Number 0088			   #480
S_PID			Number 0078			   #476
S_RTC			Number 0120			   #519
S_RTCFLAG		Number 0130			   #522
S_SECTORNO		Number 0004			   #445	 4652  4716  4757  4815	 4902
S_SUSPEND_COMMAND	Number 00AC			   #491
S_SUSPEND_DELAY		Number 00B0			   #492
S_TCP_ARP_COUNT		Number 00D0			   #506
S_TCP_DAT_COUNT		Number 00C4			   #501
S_TCP_FACK_COUNT	Number 00C8			   #502
S_TCP_GACK_COUNT	Number 00BC			   #497
S_TCP_HDR_COUNT		Number 00C0			   #499
S_TCP_RESET_COUNT	Number 00CC			   #504
S_TCP_SACK_COUNT	Number 00B8			   #495
S_TCP_TX_COUNT		Number 00B4			   #493
S_TID1			Number 005C			   #469
S_TID2			Number 0060			   #470
S_TID3			Number 0064			   #471
S_TID4			Number 0068			   #472
S_TIMER			Number 0000			   #443	 1978  2454  2505
S_TOTAL_TX_COUNT	Number 00A4			   #488	 5678
S_TRACE			Number 0160			   #526
T32BEGIN		Far    DEMOCODESEG:0007		   1741	 #2125
T32CODE			Struct DEMOLDTSEG:0020 DESC	   #1699  1731
T32CODE_SEL		Number 0024			   #1731  1741	1743
T32END			Far    DEMOCODESEG:002A		   1743	 #2157
TEMPCODE		Struct RDATASEG:0030 DESC	   #3699  3803
TEMPCODE_SEL		Number 0030			   2163	 #3803	4135
TEST1			Far    DEMOCODESEG:01AA		   1082	 #2491
TEST2			Far    ETHERNETRECEIVE:0000	   837	#1968
TIL			Number 0004			   #409	 1138  1141  1158  1161	 1177  1180  1183  1186	 1200  1203  1218 +
							   1221	 1236  1239  1276  1294	 1299  1302  1313  1317	 1321  1335  1340 +
							   1344	 1727  1728  1729  1730	 1731  1732  1733  1734	 1735  1736  1737 +
							   1739	 1760  1761  1762  1763	 1764  1765  1766  1768
TOREAL			Near   RCODESEG:01FC		   2161	 #4275
TOT32A_SEL		Number 0064			   #1760  4263	4347
TOT32B_SEL		Number 006C			   #1761  2116
TOT32GATEA		Struct DEMOLDTSEG:0060 GATE	   #1741  1760
TOT32GATEB		Struct DEMOLDTSEG:0068 GATE	   #1743  1761
UPDATECHAR		Near   DEMOCODESEG:0323		   2755	 #2758
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 116
Symbol Table



UPDATECHAR1		Near   DEMOCODESEG:03AE		   2846	 #2849
USS			Number 0000			   #422
USU			Number 0004			   #423
VGDTR			Struct RDATASEG:0186 PDESC	   #3855  4120	4184  4186
VIDEOBUF		Struct RDATASEG:0010 DESC	   #3686  3798
VIDEO_SEL		Number 0010			   2633	 2686  3038  #3798
VIDEO_SEL_LOC		Number 0010			   #539
VIDTR			Struct RDATASEG:018C PDESC	   #3856  4127	4223  4244  4424  4523	4610  4697  4796
VIRTUAL			Far    RCODESEG:01EB		   4134	 #4254
VMFL			Number 00020000			   #410
VMFLW			Number 0002			   #411
WAITCHAR		Near   DEMOCODESEG:02FB		   #2741  2745
WAITCHAR1		Near   DEMOCODESEG:037F		   #2829
WAIT_COMMAND_END	Near   ETHERNETRECEIVE:00A8	   #2043
WAIT_COMMAND_END1	Near   ETHERNETRECEIVE:0075	   #2022
WAIT_COMMAND_END2	Near   ETHERNETRECEIVE:0055	   #2006
WLDT			Byte   WRITESECLDTSEG:0000	   #1232  1236	1239  1241
WRITESEC		Near   RCODESEG:04FB		   4778	 4779  #4780
WRITESEC1		Near   RCODESEG:0511		   #4791
WRITESECBEGIN		Far    RCODESEG:04BE		   1557	 #4745	4829
WRITESECCODE		Struct WRITESECLDTSEG:0000 DESC	   #1234  1236
WRITESECCODE_SEL	Number 0004			   #1236  4803
WRITESECLDNUM		Number 0002			   #1241
WRITESECLDT		Struct RDATASEG:0088 DESC	   #3721  3815
WRITESECLDTLEN		Number WRITESECLDTSEG:0010	   #1242  3721
WRITESECLDT_SEL		Number 0088			   #3815
WRITESECSTACK		Struct WRITESECLDTSEG:0008 DESC	   #1237  1239
WRITESECSTACKLEN	Number 0200			   1237	 #1895	1896
WRITESECSTACK_SEL	Number 000C			   #1239  4805
WRITESECTSS		Struct RDATASEG:0058 DESC	   #3709  3810
WRITESECTSSLEN		Number WRITESECTSSSEG:0069	   #1577  3709
WRITESECTSS_SEL		Number 0058			   1101	 #3810
WRITESECV		Near   RCODESEG:0526		   4802	 #4804
WRITESTRING		Near   ----:---- Extern		   #432	 4603

Macro Name						   Cref	(defined at #)

CALL16							   #281	 4337  4943
CALL32							   #288	 2112  2355
DISABLEA20						   #255
ENABLEA20						   #245	 4038
FDCCYL							   #220
FDCHEAD							   #201
FDCSECTOR						   #181
FDC_AL							   #134
FDC_IN							   #116
FDC_OUT							   #95
FDC_WAIT						   #143
JUMP16							   #265	 4132  4260  4344  4369	 4390  4429  4460  4528	 4614  4677  4701 +
							   4776	 4800
JUMP32							   #272	 2159
KEYBOARDLED						   #51	3144  3190
MDELAY							   #164
NEWLINEM						   #232
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 117
Symbol Table




Structure Name		Type  Offset			   Cref	(defined at #)

DESC							   #295	 1136  1139  1143  1156	 1159  1163  1175  1178	 1181  1184  1188 +
							   1198	 1201  1205  1216  1219	 1223  1234  1237  1241	 1274  1292  1295 +
							   1311	 1315  1319  1323  1333	 1336  1341  1346  1691	 1693  1695  1697 +
							   1699	 1701  1703  1708  1710	 1712  1720  1722  1725	 3680  3684  3686 +
							   3693	 3695  3697  3699  3701	 3703  3705  3707  3709	 3711  3713  3715 +
							   3717	 3719  3721  3723  3725	 3727  3729  3731  3734	 3737  3752  3754 +
							   3756	 3758  3760  3762  3764	 3767  3769  3771  3773	 3775  3777  3780 +
							   3782	 3784  3786  3788  3795	 4177  4210
 LIMITL			Word   0000
 BASEL			Word   0002
 BASEM			Byte   0004
 ATTRIBUTES		Byte   0005
 LIMITH			Byte   0006
 BASEH			Byte   0007
GATE							   #306	 585  587  589	591  593  595  597  599	 601  603  605	607  609  +
							   611	613  616  623  625  627	 629  631  633	635  637  639  641  643	  +
							   645	647  649  651  653  655	 657  659  661	663  665  667  669  671	  +
							   673	675  677  679  681  683	 685  687  689	691  693  695  697  699	  +
							   701	703  705  707  709  711	 713  715  717	719  721  723  725  727	  +
							   729	731  733  735  737  739	 741  743  745	747  749  751  753  755	  +
							   757	759  761  763  765  767	 769  771  773	775  777  779  781  783	  +
							   785	787  789  791  793  795	 797  799  801	803  805  807  809  811	  +
							   813	815  817  819  821  828	 830  832  837	846  848  850  852  854	  +
							   856	858  860  862  864  866	 868  870  872	874  876  878  880  882	  +
							   884	886  888  890  892  894	 896  898  900	902  904  906  908  910	  +
							   912	914  916  918  920  922	 924  926  928	930  932  934  936  938	  +
							   940	942  944  946  948  950	 952  954  956	958  960  962  964  966	  +
							   968	970  972  974  976  978	 980  982  984	986  988  990  992  994	  +
							   996	998  1000  1002	 1004  1006  1008
 OFFSETL		Word   0000
 SELECTOR		Word   0002
 DCOUNT			Byte   0004
 GTYPE			Byte   0005
 OFFSETH		Word   0006
PDESC							   #316	 3855  3856  3857
 LIMIT			Word   0000
 BASE			Dword  0002
TSS							   #323
 TRLINK			Word   0000
 TRESP0			Dword  0004
 TRSS0			Word   0008
 TRESP1			Dword  000C
 TRSS1			Word   0010
 TRESP2			Dword  0014
 TRSS2			Word   0018
 TRCR3			Dword  001C
 TREIP			Dword  0020
 TREFLAG		Dword  0024
 TREAX			Dword  0028
 TRECX			Dword  002C
 TREDX			Dword  0030
 TREBX			Dword  0034
 TRESP			Dword  0038
 TREBP			Dword  003C
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 118
Symbol Table



 TRESI			Dword  0040
 TREDI			Dword  0044
 TRES			Word   0048
 TRCS			Word   004C
 TRSS			Word   0050
 TRDS			Word   0054
 TRFS			Word   0058
 TRGS			Word   005C
 TRLDTR			Word   0060
 TRTRIP			Word   0064
 TRIOMAP		Word   0066
TYPEAPPLICATION						   #23
 NOOFSECTORS		Word   0000
 STARTINGSECTOR		Word   0002
 NAMEAPPLICATION	Byte   0004
TYPECOMMAND						   #35
 COMMAND		Byte   0000
 APPNAME		Byte   0001
 APPINDEX		Byte   0009

Groups & Segments	Bit Size Align	Combine	Class	   Cref	(defined at #)

APP1LDTSEG		16  0038 Para	none		   #1246  3756	3771  3777  4055
APP1STACKSEG		32  0200 Dword	Stack		   #1904
APP1TSSSEG		32  0070 Para	none		   #1593  3752	3754  3758  3760  4023
APP2LDTSEG		16  0018 Para	none		   #1329
APP2TSSSEG		16  0400 Para	none		   #1649  3767	3769  3775
DEMOCODESEG		32  0464 Para	none		   1697	 1699  1701  #2101  2102  3725
DEMOLDTSEG		16  00A0 Para	none		   #1688  3697	4099
DEMOSTACK0SEG		32  0200 Dword	Stack		   1691	 #1816
DEMOSTACK1SEG		32  0200 Dword	Stack		   1693	 #1825
DEMOSTACK3SEG		16  0200 Para	none		   1139	 1695  #1845
DEMOTSSSEG		16  006A Para	none		   #1777  3695	3786  5121  5177
DMADATASEG		16  0200 Para	Public	DMADATA	   #3631  3780
ETHERNETRECEIVE		32  00E2 Para	none		   #1966  3784
GETCHARLDTSEG		16  0010 Para	none		   #1152  3715	4075
GETCHARSTACKSEG		16  0200 Para	none		   1159	 #1855
GETCHARTSSSEG		16  0069 Para	none		   #1431  3703
GETDECLDTSEG		16  0010 Para	none		   #1194  3717	4083
GETDECSTACKSEG		16  0200 Para	none		   1201	 1219  #1876
GETDECTSSSEG		16  0069 Para	none		   #1470  3705
GETSECLDTSEG		16  0010 Para	none		   #1212  3719	4091
GETSECSTACKSEG		16  0200 Para	none		   #1885
GETSECTSSSEG		16  0069 Para	none		   #1509  3707
GKEYLDTSEG		16  0010 Para	none		   #1132  3713	4067
GKEYTSSSEG		16  0069 Para	none		   #1356  3711
GLOBALDATASEG		16  0112 Para	Public		+  1178	 #1933	3734  4407  4476
			GLOBALDATA
IDTSEG			16  0800 Para	none		   #579	 4220
INTEXCEPTIONSEG		32  0001 Para	none		   #1951  3788
PCODESEG		16  055F Para	Public	CODE	   1175	 #3074	3075  3782
PROTMODEPROCDATASEG	32  0018 Para	Public		   1703	 #1914	2102  3723
RCODESEG		16  0DC5 Para	Public	CODE	   1136	 1156  1198  1216  1234	 3699  3701  #3941  3942
RDATASEG		16  041F Para	Public	REALDATA   1720	 3075  #3655  3693  3942  3950	4144  4396  4466  4576	4681  4780
SEARCHLDTSEG		16  0020 Para	none		   #1171  3727	4106
SEARCHSTACKSEG		16  0200 Para	none		   1184	 #1865
SEARCHTSSSEG		16  0069 Para	none		   #1393  3729
Turbo Assembler	 Version 2.5	    05/19/10 12:24:50	    Page 119
Symbol Table



WRITESECLDTSEG		16  0010 Para	none		   #1230  3721
WRITESECSTACKSEG	16  0200 Para	none		   1237	 #1894
WRITESECTSSSEG		16  0069 Para	none		   #1548  3709
