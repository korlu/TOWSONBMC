Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 1
prcycle.ASM



      1					 ;*******************************************************************************************
      2					 ***************CK/
      3					 ;prcycle.asm
      4					 ;Copyright 2002 Dept of Computer Science, Towson University
      5					 ;Coded	by: Dr.R.K Karne, Rajvardhan Gattu, Xubo Zhang and Ramesh Dandu
      6					 ;  Luyin Sun, Karthick	Venkatasamy
      7					 ;Date:	02/08/02
      8					 ;Date:	03/22/04
      9					 ;Date:	07/01/04
     10					 ;***************************************************************************
     11					 ;Conventions:
     12					 ;X: When X is displayed, we are at the	point of jump to prcycle in aoaboot.
     13					 ;Y: When Y is displayed, we sucessfully jumped	from aoaboot to	the prcycle.
     14					 ;P: When P is displayed, we have entered/re-entered PMode.
     15					 ;R: When R is displayed, we have entered/re-entered RMode.
     16					 ;Z: When Z is displayed, we have sucessfully exited from the program in RMode.
     17					 INCLUDE	 386SCD.INC
1    18
1    19					 .386P
1    20					 ;----------------------------------------------------------------------------
1    21					 ;application structure	for aoa
1    22
1    23	00000000			 typeApplication struc
1    24	00000000  01*(????)			 noOfSectors	 DW	 ?
1    25	00000002  01*(????)			 startingSector	 DW	 ?
1    26	00000004  01*(08*(??))			 nameApplication DB	 8 dup(?)
1    27	0000000C			 typeApplication ends
1    28
1    29
1    30					 ;allApplications	 typeApplication 10 dup(<>)
1    31					 ; ten application vector
1    32
1    33
1    34					 ; command structure
1    35	00000000			 typeCommand		 struc
1    36	00000000  01*(??)			 command	 db	 ?	 ; command
1    37										 ; 0 - exit
1    38										 ; 1 - no command
1    39										 ; 2 - load
1    40										 ; 3 - run
1    41	00000001  01*(08*(??))			 appName	 db	 8 dup(?)
1    42
1    43	00000009  01*(??)			 appIndex	 db	 ?
1    44
1    45	0000000A			 typeCommand		 ends
1    46
1    47					 ;appCommand	 typeCommand <>
1    48					 ;----------------------------------------------------------------------------
1    49					 ; Setup keyboard LED according	to variable NumLock & CapLock
1    50					 ;----------------------------------------------------------------------------
1    51					 KeyboardLED	 MACRO	 NumLock, CapLock	 ; setup keyboard LED
1    52							 LOCAL @@NoCap,@@Write_LED,@@Wait1,@@Wait2,@@Wait3
1    53
1    54							 mov bl, 0
1    55							 mov al, CapLock
1    56							 cmp al, 0
1    57							 jz @@NoCap
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 2
prcycle.ASM



1    58							 or bl,	4
1    59					 @@NoCap:
1    60							 mov al, NumLock
1    61							 cmp al, 0
1    62							 jz @@Write_LED
1    63							 or bl,	2
1    64					 @@Write_LED:
1    65							 mov dx, 64h	 ; set CapLock LED
1    66					 @@Wait1:
1    67							 in al,	dx
1    68							 and al, 2
1    69							 jnz @@Wait1
1    70
1    71							 mov dx, 60h	 ; write LED command
1    72							 mov al, 0edh
1    73							 out dx, al
1    74
1    75							 mov dx, 64h
1    76					 @@Wait2:
1    77							 in al,	dx
1    78							 and al, 2
1    79							 jnz @@Wait2
1    80
1    81							 mov dx, 60h
1    82							 mov al, bl
1    83							 out dx, al
1    84
1    85							 mov dx, 64h
1    86					 @@Wait3:
1    87							 in al,	dx
1    88							 and al, 2
1    89							 jnz @@Wait3
1    90
1    91							 ENDM
1    92					 ;----------------------------------------------------------------------------
1    93					 ; Write configuration data to FDC
1    94					 ;----------------------------------------------------------------------------
1    95					 FDC_out	 MACRO
1    96							 local @@loop
1    97							 push	 edx
1    98							 push	 eax
1    99
1   100							 mov	 dx, 3f4h
1   101					 @@loop:
1   102							 in	 al, dx
1   103							 test	 al, 80h
1   104							 jz	 @@loop
1   105
1   106							 inc	 dx
1   107							 pop	 eax
1   108							 out	 dx, al
1   109
1   110							 pop	 edx
1   111							 ENDM
1   112					 ;----------------------------------------------------------------------------
1   113					 ; Read	a byte from FDC
1   114					 ; Return data is in AL
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 3
prcycle.ASM



1   115					 ;----------------------------------------------------------------------------
1   116					 FDC_in		 MACRO
1   117							 local @@loop
1   118							 push	 edx
1   119
1   120							 mov	 dx, 3f4h
1   121					 @@loop:
1   122							 in	 al, dx
1   123							 test	 al, 80h
1   124							 jz	 @@loop
1   125
1   126							 inc	 dx
1   127							 in	 al, dx
1   128
1   129							 pop	 edx
1   130							 ENDM
1   131					 ;----------------------------------------------------------------------------
1   132					 ; Debug purpose
1   133					 ;----------------------------------------------------------------------------
1   134					 FDC_al		 MACRO	 ps
1   135							 push	 ebx
1   136							 mov	 ebx, ps
1   137							 int	 0fdh
1   138							 pop	 ebx
1   139							 ENDM
1   140					 ;----------------------------------------------------------------------------
1   141					 ; Wait	for floppy interrupt
1   142					 ;----------------------------------------------------------------------------
1   143					 FDC_wait	 MACRO
1   144							 local @@loop
1   145							 push	 eax
1   146							 push	 fs
1   147
1   148							 mov	 ax, RData_Sel
1   149							 mov	 fs, ax
1   150
1   151					 @@loop:
1   152							 mov	 al, fs:[FloppyReady]
1   153							 cmp	 al, 0
1   154							 jz	 @@loop
1   155							 mov	 al, 0
1   156							 mov	 fs:[FloppyReady], al
1   157
1   158							 pop	 fs
1   159							 pop	 eax
1   160							 ENDM
1   161					 ;----------------------------------------------------------------------------
1   162					 ; Delay a while to wait for other stuff
1   163					 ;----------------------------------------------------------------------------
1   164					 MDelay		 MACRO length
1   165							 local @@loop
1   166							 push	 eax
1   167							 push	 ecx
1   168
1   169							 mov	 ecx, length
1   170					 @@loop:
1   171							 xor	 ax, ax
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 4
prcycle.ASM



1   172							 loop @@loop
1   173
1   174							 pop	 ecx
1   175							 pop	 eax
1   176							 ENDM
1   177					 ;----------------------------------------------------------------------------
1   178					 ; Calculate floppy start sector
1   179					 ; Return in AL
1   180					 ;----------------------------------------------------------------------------
1   181					 FDCSector	 MACRO	 sec
1   182							 push	 ebx
1   183							 push	 ecx
1   184
1   185							 mov	 ax, sec
1   186							 mov	 bl, 18
1   187							 div	 bl
1   188							 xor	 cx, cx
1   189							 mov	 cl, ah
1   190							 add	 cl, 1
1   191							 xor	 eax, eax
1   192							 mov	 al, cl
1   193
1   194							 pop	 ecx
1   195							 pop	 ebx
1   196							 ENDM
1   197					 ;----------------------------------------------------------------------------
1   198					 ; Calculate floppy Head
1   199					 ; Return in AL
1   200					 ;----------------------------------------------------------------------------
1   201					 FDCHead MACRO	 sec
1   202							 push	 ebx
1   203
1   204							 xor	 eax, eax
1   205							 mov	 ax, sec
1   206							 mov	 bl, 18
1   207							 div	 bl
1   208							 and	 ah, 0
1   209							 mov	 bl, 2
1   210							 div	 bl
1   211							 mov	 al, ah
1   212							 mov	 ah, 0
1   213
1   214							 pop	 ebx
1   215							 ENDM
1   216					 ;----------------------------------------------------------------------------
1   217					 ; Calculate floppy cylinder
1   218					 ; Return in AL
1   219					 ;----------------------------------------------------------------------------
1   220					 FDCCyl	 MACRO	 sec
1   221							 push	 ebx
1   222
1   223							 xor	 eax, eax
1   224							 mov	 ax, sec
1   225							 mov	 bl, 36
1   226							 div	 bl
1   227							 mov	 ah, 0
1   228
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 5
prcycle.ASM



1   229							 pop	 ebx
1   230							 ENDM
1   231					 ;----------------------------------------------------------------------------
1   232					 NewLineM	 MACRO		 ;prints a newline after puthex
1   233							 push	 eax
1   234							 mov	 al,0dh
1   235							 mov	 ah,14
1   236							 int	 10h
1   237							 mov	 al,0ah
1   238							 mov	 ah,14
1   239							 int	 10h
1   240							 pop	 eax
1   241							 ENDM
1   242
1   243					 ;----------------------------------------------------------------------------
1   244					 ;----------------------------------------------------------------------------
1   245					 EnableA20	 MACRO
1   246							 push	 ax
1   247							 in	 al,92h
1   248							 or	 al,00000010b
1   249							 out	 92h,al
1   250							 pop	 ax
1   251							 ENDM
1   252					 ;----------------------------------------------------------------------------
1   253
1   254					 ;----------------------------------------------------------------------------
1   255					 DisableA20	 MACRO
1   256							 push	 ax
1   257							 in	 al,92h
1   258							 and	 al,11111101b
1   259							 out	 92h,al
1   260							 pop	 ax
1   261							 ENDM
1   262					 ;----------------------------------------------------------------------------
1   263
1   264					 ;----------------------------------------------------------------------------
1   265					 JUMP16		 MACRO	 Selector,Offset
1   266							 DB	 0eah
1   267							 DW	 Offset
1   268							 DW	 Selector
1   269							 ENDM
1   270					 ;----------------------------------------------------------------------------
1   271
1   272					 JUMP32		 MACRO	 Selector,Offset
1   273							 DB	 0eah
1   274							 DW	 OFFSET
1   275							 DW	 0
1   276							 DW	 Selector
1   277							 ENDM
1   278					 ;----------------------------------------------------------------------------
1   279
1   280					 ;----------------------------------------------------------------------------
1   281					 CALL16		 MACRO	 Selector,Offset
1   282							 DB	 9ah
1   283							 DW	 Offset
1   284							 DW	 Selector
1   285							 ENDM
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 6
prcycle.ASM



1   286					 ;----------------------------------------------------------------------------
1   287
1   288					 CALL32		 MACRO	 Selector,Offset
1   289							 DB	 9ah
1   290							 DW	 Offset
1   291							 DW	 0
1   292							 DW	 Selector
1   293							 ENDM
1   294					 ;----------------------------------------------------------------------------
1   295	00000000			 Desc		 STRUC
1   296	00000000  01*(0000)		 LimitL		 DW	 0
1   297	00000002  01*(0000)		 BaseL		 DW	 0
1   298	00000004  01*(00)		 BaseM		 DB	 0
1   299	00000005  01*(00)		 Attributes	 DB	 0
1   300	00000006  01*(00)		 LimitH		 DB	 0
1   301	00000007  01*(00)		 BaseH		 DB	 0
1   302	00000008			 Desc		 ENDS
1   303					 ;----------------------------------------------------------------------------
1   304
1   305					 ;----------------------------------------------------------------------------
1   306	00000000			 Gate		 STRUC
1   307	00000000  01*(0000)		 OffsetL	 DW	 0
1   308	00000002  01*(0000)		 Selector	 DW	 0
1   309	00000004  01*(00)		 DCount		 DB	 0
1   310	00000005  01*(00)		 GType		 DB	 0
1   311	00000006  01*(0000)		 OffsetH	 DW	 0
1   312	00000008			 Gate		 ENDS
1   313					 ;----------------------------------------------------------------------------
1   314
1   315					 ;----------------------------------------------------------------------------
1   316	00000000			 PDesc		 STRUC
1   317	00000000  01*(0000)		 Limit		 DW	 0
1   318	00000002  01*(00000000)		 Base		 DD	 0
1   319	00000006			 PDesc		 ENDS
1   320					 ;----------------------------------------------------------------------------
1   321
1   322					 ;----------------------------------------------------------------------------
1   323	00000000			 TSS		 STRUC
1   324	00000000  01*(0000)		 TRLink		 DW	 0
1   325	00000002  01*(0000)				 DW	 0
1   326	00000004  01*(00000000)		 TRESP0		 DD	 0
1   327	00000008  01*(0000)		 TRSS0		 DW	 0
1   328	0000000A  01*(0000)				 DW	 0
1   329	0000000C  01*(00000000)		 TRESP1		 DD	 0
1   330	00000010  01*(0000)		 TRSS1		 DW	 0
1   331	00000012  01*(0000)				 DW	 0
1   332	00000014  01*(00000000)		 TRESP2		 DD	 0
1   333	00000018  01*(0000)		 TRSS2		 DW	 0
1   334	0000001A  01*(0000)				 DW	 0
1   335	0000001C  01*(00000000)		 TRCR3		 DD	 0
1   336	00000020  01*(00000000)		 TREIP		 DD	 0	;EIP
1   337	00000024  01*(00000000)		 TREFlag	 DD	 0	;EFLAGS
1   338	00000028  01*(00000000)		 TREAX		 DD	 0	;EAX
1   339	0000002C  01*(00000000)		 TRECX		 DD	 0	;ECX
1   340	00000030  01*(00000000)		 TREDX		 DD	 0	;EDX
1   341	00000034  01*(00000000)		 TREBX		 DD	 0	;EBX
1   342	00000038  01*(00000000)		 TRESP		 DD	 0	;ESP
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 7
prcycle.ASM



1   343	0000003C  01*(00000000)		 TREBP		 DD	 0	;EBP
1   344	00000040  01*(00000000)		 TRESI		 DD	 0	;ESI
1   345	00000044  01*(00000000)		 TREDI		 DD	 0	;EDI
1   346	00000048  01*(0000)		 TRES		 DW	 0	;ES
1   347	0000004A  01*(0000)				 DW	 0
1   348	0000004C  01*(0000)		 TRCS		 DW	 0
1   349	0000004E  01*(0000)				 DW	 0
1   350	00000050  01*(0000)		 TRSS		 DW	 0	;SS
1   351	00000052  01*(0000)				 DW	 0
1   352	00000054  01*(0000)		 TRDS		 DW	 0	;DS
1   353	00000056  01*(0000)				 DW	 0
1   354	00000058  01*(0000)		 TRFS		 DW	 0	;FS
1   355	0000005A  01*(0000)				 DW	 0
1   356	0000005C  01*(0000)		 TRGS		 DW	 0	;GS
1   357	0000005E  01*(0000)				 DW	 0
1   358	00000060  01*(0000)		 TRLDTR		 DW	 0
1   359	00000062  01*(0000)				 DW	 0
1   360	00000064  01*(0000)		 TRTrip		 DW	 0
1   361	00000066  01*(0068)		 TRIOMap	 DW	 $+2
1   362	00000068			 TSS		 ENDS
1   363					 ;----------------------------------------------------------------------------
1   364
1   365					 ;----------------------------------------------------------------------------
1   366		  = 0090		 ATDR		 EQU	 90h
1   367		  = 0092		 ATDW		 EQU	 92h
1   368		  = 0093		 ATDWA		 EQU	 93h
1   369		  = 0096		 ATSWA		 EQU	 96h
1   370		  = 0098		 ATCE		 EQU	 98h
1   371		  = 009A		 ATCER		 EQU	 9ah
1   372		  = 009C		 ATCCO		 EQU	 9ch
1   373		  = 009E		 ATCCOR		 EQU	 9eh
1   374					 ;----------------------------------------------------------------------------
1   375
1   376					 ;----------------------------------------------------------------------------
1   377		  = 0082		 ATLDT		 EQU	 82h
1   378		  = 0085		 ATTaskGate	 EQU	 85h
1   379		  = 0089		 AT386TSS	 EQU	 89h
1   380		  = 008C		 AT386CGate	 EQU	 8ch
1   381		  = 008E		 AT386IGate	 EQU	 8eh
1   382		  = 008F		 AT386TGate	 EQU	 8fh
1   383					 ;----------------------------------------------------------------------------
1   384
1   385					 ;----------------------------------------------------------------------------
1   386		  = 0000		 DPL0		 EQU	 00h ;DPL=0
1   387		  = 0020		 DPL1		 EQU	 20h ;DPL=1
1   388		  = 0040		 DPL2		 EQU	 40h ;DPL=2
1   389		  = 0060		 DPL3		 EQU	 60h ;DPL=3
1   390					 ;----------------------------------------------------------------------------
1   391
1   392					 ;----------------------------------------------------------------------------
1   393		  = 0000		 RPL0		 EQU	 00h ;RPL=0
1   394		  = 0001		 RPL1		 EQU	 01h ;RPL=1
1   395		  = 0002		 RPL2		 EQU	 02h ;RPL=2
1   396		  = 0003		 RPL3		 EQU	 03h ;RPL=3
1   397					 ;----------------------------------------------------------------------------
1   398
1   399					 ;----------------------------------------------------------------------------
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 8
prcycle.ASM



1   400		  = 0000		 IOPL0		 EQU	 0000h ;IOPL=0
1   401		  = 1000		 IOPL1		 EQU	 1000h ;IOPL=1
1   402		  = 2000		 IOPL2		 EQU	 2000h ;IOPL=2
1   403		  = 3000		 IOPL3		 EQU	 3000h ;IOPL=3
1   404					 ;----------------------------------------------------------------------------
1   405
1   406					 ;----------------------------------------------------------------------------
1   407		  = 0040		 D32		 EQU	 40h
1   408		  = 0080		 GL		 EQU	 80h
1   409		  = 0004		 TIL		 EQU	 04h
1   410		  = 00020000		 VMFL		 EQU	 00020000h ;VMF=1
1   411		  = 0002		 VMFLW		 EQU	 0002h
1   412		  = 0200		 IFL		 EQU	 00000200h ;IF=1
1   413		  = 00010000		 RFL		 EQU	 00010000h ;
1   414		  = 0001		 RFLW		 EQU	 0001h
1   415		  = 4000		 NTL		 EQU	 00004000h ;NT=1
1   416					 ;----------------------------------------------------------------------------
1   417
1   418					 ;----------------------------------------------------------------------------
1   419		  = 0001		 PL		 EQU	 1
1   420		  = 0000		 RWR		 EQU	 0
1   421		  = 0002		 RWW		 EQU	 2
1   422		  = 0000		 USS		 EQU	 0
1   423		  = 0004		 USU		 EQU	 4
1   424					 ;----------------------------------------------------------------------------
1   425		  = 0064		 HZ		 EQU	 100
1   426		  = 001234DC		 CLOCK_TICK_RATE EQU	 1193180
1   427		  = 2E9C		 LATCH		 EQU	 ((CLOCK_TICK_RATE+HZ/2)/HZ)
1   428					 ;----------------------------------------------------------------------------
1   429
    430					 INCLUDE	 DCYCLE.INC
1   431					 EXTRN		 PUTHEX32R:NEAR
1   432					 EXTRN		 WriteString:NEAR
1   433					 EXTRN		 ClearScreen:NEAR
1   434					 EXTRN		 GETKEYFORMENU:NEAR
1   435					 EXTRN		 NEWLINE:NEAR
1   436					 EXTRN		 GET_PARAMETER:NEAR
1   437					 EXTRN		 ResetPointer:NEAR
1   438					 EXTRN		 PRINTMEMR:NEAR
1   439
1   440
    441					 INCLUDE	 SHARMEM.INC
1   442					 ;Shared Memory	Constants between appilication and aoa
1   443		  = 0000		 S_Timer		 EQU		 00000000h ; software timer value, incremented by   +
    444					 timer interrupt
1   445		  = 0004		 S_SectorNo		 EQU		 00000004h ; 4 byte sector number and another 4	byte+
    446					 spare
1   447					 ; after this element, the GetSecBegin in prcycle stores another data value
1   448					 ;  with +2 location, so keep another 4	bytes as spare here
1   449		  = 000C		 S_IDTOffset		 EQU		 0000000Ch ; used by Timer interrupt
1   450		  = 0010		 S_Cycle_Count		 EQU		 00000010h
1   451					 ; This	is the count used by the Htimer	to calculate the processor clock speed,	which is    +
    452					 stored	in S_Clock_Hz
1   453		  = 0014		 S_Clock_Hz		 EQU		 00000014h ; This shared memory	has the	clock speed +
    454					 in Giga Hertz
1   455		  = 0018		 S_Error_Flag		 EQU		 00000018h ; error flag	indicating that	error	    +
    456					 occured in the	machine
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 9
prcycle.ASM



1   457		  = 001C		 S_Error_Code		 EQU		 0000001Ch ; error code	showing	the IDT	value
1   458		  = 0020		 S_IO_Function_Code	 EQU		 00000020h ; Function Code Indicating the type of   +
    459					 function 4 bytes
1   460					 ;each assembly	interface call will put	this code in memory
1   461		  = 0024		 S_APP_String		 EQU		 00000024h ; 40	bytes Used for storing a string
1   462					 ;all C++ programs and functions can store a string here to be used as a trace
1   463					 ; the string here indicates the last C++ function trace which can help	identify
1   464					 ; the trace code ran before an	error
1   465		  = 004C		 S_Lock1		 EQU		 0000004Ch ; 4 byte lock 0 DISPLAY
1   466		  = 0050		 S_Lock2		 EQU		 00000050h ; 4 byte lock 1 KBD
1   467		  = 0054		 S_Lock3		 EQU		 00000054h ; 4 byte lock 2
1   468		  = 0058		 S_Lock4		 EQU		 00000058h ; 4 byte lock 3
1   469		  = 005C		 S_TID1			 EQU		 0000005ch ; Task ID 1	   DISPLAY
1   470		  = 0060		 S_TID2			 EQU		 00000060h ; Task ID 2	   KBD
1   471		  = 0064		 S_TID3			 EQU		 00000064h ; Task ID 3
1   472		  = 0068		 S_TID4			 EQU		 00000068h ; Task ID 4
1   473		  = 0070		 S_InCount		 EQU		 00000070h ; 4 byte the	no of interrupt	pkts	    +
    474					 received
1   475		  = 0074		 S_OutCount		 EQU		 00000074h ; 4 byte the	no of pkts processed
1   476		  = 0078		 S_PID			 EQU		 00000078h ; 4 byte task id of the process running
1   477		  = 007C		 S_NTFLAG		 EQU		 0000007ch ; 4 byte CPU	NTFLAG
1   478		  = 0080		 S_CIRLISTSTATE		 EQU		 00000080h ; 4 byte cirlist condition
1   479		  = 0084		 S_InRecord		 EQU		 00000084h ; 4 byte in record for cirlist
1   480		  = 0088		 S_OutRecord		 EQU		 00000088h ; 4 byte out	record for cirlist
1   481		  = 008C		 S_ISRCount		 EQU		 0000008Ch ; 4 byte counter used to communicate	betn+
    482					 ISR Rtn and Poll Task
1   483		  = 0090		 S_ISRSTIFlag		 EQU		 00000090h ; 4 byte ISR	STI flag indicating its	    +
    484					 execution, no sti now...
1   485		  = 0094		 S_DUMMY		 EQU		 00000094h ; 8 byte dummy data
1   486		  = 009C		 S_IOBASE		 EQU		 0000009Ch ; 4 byte NIC	device address
1   487		  = 00A0		 S_EINIT_RET		 EQU		 000000a0h ; 4 byte Ethernet Init Ret code
1   488		  = 00A4		 S_Total_Tx_Count	 EQU		 000000a4h ; 4 byte counter counts total pkts	    +
    489					 xmitted
1   490		  = 00A8		 S_DPD_Count		 EQU		 000000a8h ; 4 byte counter
1   491		  = 00AC		 S_Suspend_Command	 EQU		 000000ach ; 4 byte value
1   492		  = 00B0		 S_Suspend_Delay	 EQU		 000000b0h ; 4 byte value
1   493		  = 00B4		 S_TCP_Tx_Count		 EQU		 000000b4h ; total packets sent	by application
1   494
1   495		  = 00B8		 S_TCP_SACK_Count	 EQU		 000000b8h ; total SYN ACK packets sent	by	    +
    496					 application
1   497		  = 00BC		 S_TCP_GACK_Count	 EQU		 000000bch ; total GET ACK packets sent	by	    +
    498					 application
1   499		  = 00C0		 S_TCP_HDR_Count	 EQU		 000000c0h ; total header packets sent by	    +
    500					 application
1   501		  = 00C4		 S_TCP_DAT_Count	 EQU		 000000c4h ; total data	packets	sent by	application
1   502		  = 00C8		 S_TCP_FACK_Count	 EQU		 000000c8h ; total FIN ACK packets sent	by	    +
    503					 application
1   504		  = 00CC		 S_TCP_RESET_Count	 EQU		 000000cch ; total RESET packets sent by application
1   505		  = 00D0		 S_TCP_ARP_Count	 EQU		 000000d0h ; total ARP packets sent by application
1   506
1   507		  = 0100		 S_ITCP_SACK_Count	 EQU		 00000100h ; total interrupts for SYN ACK packets
1   508		  = 0104		 S_ITCP_GACK_Count	 EQU		 00000104h ; total interrupts for GET ACK packets
1   509		  = 0108		 S_ITCP_HDR_Count	 EQU		 00000108h ; total interrupts for header packets
1   510		  = 010C		 S_ITCP_DAT_Count	 EQU		 0000010ch ; total interrrupts for data	packets
1   511		  = 0110		 S_ITCP_FACK_Count	 EQU		 00000110h ; total interrupts for FIN ACK packets
1   512		  = 0114		 S_ITCP_RESET_Count	 EQU		 00000114h ; total interrupts for RESET	packets
1   513		  = 0118		 S_ITCP_ARP_Count	 EQU		 00000118h ; total interrupts for ARP packets
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 10
prcycle.ASM



1   514		  = 011C		 S_ITCP_PRIOR_Count	 EQU		 0000011ch ; interrupt prior count before TCP	    +
    515					 transmissions
1   516					 ;--------------------------------------------------------------------------------
1   517		  = 0120		 S_RTC		     EQU	 00000120h ; real time clock
1   518		  = 0124		 S_DATE		     EQU	 00000124h ; date
1   519		  = 0128		 S_ERR		     EQU	 00000128h ; error
1   520		  = 0130		 S_RTCFLAG		 EQU		 00000130h ; flag
1   521
1   522		  = 0140		 S_LSError		 EQU		 00000140h ; Sector Error when reading floppy
1   523					 ;----------------------------------------------------
1   524		  = 0160		 S_Trace		 EQU		 00000160h ; 128 byte trace data
1   525
1   526					 ;----------------------------------------------------
1   527
1   528					 ; Base	of Shared memory between aoa and application
1   529					 ;--------------------------------------------
1   530		  = 8600		 S_Base			 EQU		 00008600h ; base address of shared memory
1   531
1   532					 ;--------------------------------------------
1   533					 ; Some	other constants
1   534					 ;change the following value if	loading	the program changes
1   535					 ;  most significant 2 bytes
1   536		  = 0011		 D_ADDROFFSET		 EQU		 0011h
1   537		  = 0010		 Video_Sel_Loc		 EQU		 10h
1   538
    539					 PUBLIC		 HexTable, IndexCnt, PrintData,RunFlag
    540					 PUBLIC		 MemoryOffset,MemFlag
    541					 ;******************************************************
    542					 ; MemoryOffset	is used	for printing memory or dump
    543					 ;******************************************************
    544					 EXTRN		 LoaderSize1:word,LoaderSize2:word,StartLogicalSecNum1:word,		    +
    545					 StartLogicalSecNum2:word
    546					 EXTRN		 LoadOffset1:dword,LoadOffset2:dword,ApplNum:byte,JumpOffset1:word,	    +
    547					 JumpOffset2:word
    548					 EXTRN		 BxPointer1:dword,LoadFlag:byte,LoaderSize1m:word,StartLogicalSecNum1m:word
    549					 EXTRN		 AOADisp:NEAR
    550					 ;EXTRN		  AOADisp:far
    551					 EXTRN		 aoaminil1:NEAR
    552					 EXTRN		 aoaminiw1:NEAR
    553					 EXTRN		 Other_Begin0:NEAR,Other_Begin1:NEAR,Other_Begin2:NEAR,	Other_Begin3,	    +
    554					 Other_Begin4, Other_Begin5
    555					 EXTRN		 Other_Begin6:NEAR,Other_Begin7:NEAR,Other_Begin10:NEAR, Other_Begin11,	    +
    556					 Other_Begin12,	Other_Begin13
    557					 EXTRN		 Other_Begin219:NEAR,Other_Begin246:NEAR
    558					 ;---------------------------------------------------------------------------
    559		  = 0020		 EOICOM		 =	 20h	 ; not used
    560		  = 0020		 ICREGP		 =	 20h	 ; not used
    561		  = 0021		 IMREGP		 =	 21h	 ; mask	register
    562		  = 0080		 RELOCATE1	 =	 80h	 ;Program reloaction in	BootMode
    563		  = 0000		 APPL1RELOCATE	 =	 000h	;Program reloaction in ApplicationMode
    564		  = 0000		 BaseOfCode	 =	 0000h	 ;Base of code from PE
    565					 ;RELOCATE1: The code is loaded	at '600' in BootMode includes PSP
    566					 ;So, the executable code is at	'800' which is '80h' for segment adresses
    567					 ;and we need to relocate accordingly.
    568					 ;***************************************************************************
    569					 ;  Interupts in Protection Mode
    570					 ;  ;IDT Segment
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 11
prcycle.ASM



    571					 ;  16 bit segment
    572					 ; whenever, interrupts	are added or deleted to	this segment
    573					 ;  make sure they add up to 256
    574					 ; otherwise, LIDT instruction will fail
    575					 ;***************************************************************************
    576
    577	    0000			 IDTSeg		 SEGMENT PARA USE16
    578	    0000			 IDT		 LABEL	 BYTE
    579							 REPT	 8
    580							 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    581					 Selector 0 -7
    582							 ENDM
1   583	    0000  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    584		  0000			 Selector 0 -7
1   585	    0008  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    586		  0000			 Selector 0 -7
1   587	    0010  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    588		  0000			 Selector 0 -7
1   589	    0018  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    590		  0000			 Selector 0 -7
1   591	    0020  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    592		  0000			 Selector 0 -7
1   593	    0028  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    594		  0000			 Selector 0 -7
1   595	    0030  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    596		  0000			 Selector 0 -7
1   597	    0038  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    598		  0000			 Selector 0 -7
    599	    0040  0167r	0098 00	8F    +			 Gate	 <HTimerBegin, Puthex32I_Sel,,AT386TGate,>	 ;08h: hardware	    +
    600		  0000			 timer interrupt
    601	    0048  0000r	0138 00	8F    +			 Gate	 <Keyboard_Int,	PCode_Sel,,AT386TGate,>		 ;09h: get a key
    602		  0000
    603	    0050  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    604		  0000			 Selector 10
    605	    0058  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    606		  0000			 Selector 11
    607	    0060  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    608		  0000			 Selector 12
    609	    0068  0AC3r	0038 00	8F    +			 Gate	 <OtherBegin13,Other_Sel,,AT386TGate,>		 ; Use this	    +
    610		  0000			 interrupt in PRCYCLE
    611	    0070  03E4r	0098 00	8F    +			 Gate	 <FDC_int, Puthex32I_Sel,,AT386TGate,>		 ;0eh: floppy	    +
    612		  0000			 interrupt 14
    613							 ; another print char exist so we can change
    614	    0078  0444r	0098 00	8F    +			 Gate	 <DisplayBegin,Puthex32I_Sel,,AT386TGate,>	 ;0fh: display a    +
    615		  0000			 character interrupt 15
    616
    617							 REPT	 99
    618							 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    619					 Selector 16 - 114
    620							 ENDM
1   621	    0080  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    622		  0000			 Selector 16 - 114
1   623	    0088  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    624		  0000			 Selector 16 - 114
1   625	    0090  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    626		  0000			 Selector 16 - 114
1   627	    0098  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 12
prcycle.ASM



    628		  0000			 Selector 16 - 114
1   629	    00A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    630		  0000			 Selector 16 - 114
1   631	    00A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    632		  0000			 Selector 16 - 114
1   633	    00B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    634		  0000			 Selector 16 - 114
1   635	    00B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    636		  0000			 Selector 16 - 114
1   637	    00C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    638		  0000			 Selector 16 - 114
1   639	    00C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    640		  0000			 Selector 16 - 114
1   641	    00D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    642		  0000			 Selector 16 - 114
1   643	    00D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    644		  0000			 Selector 16 - 114
1   645	    00E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    646		  0000			 Selector 16 - 114
1   647	    00E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    648		  0000			 Selector 16 - 114
1   649	    00F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    650		  0000			 Selector 16 - 114
1   651	    00F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    652		  0000			 Selector 16 - 114
1   653	    0100  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    654		  0000			 Selector 16 - 114
1   655	    0108  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    656		  0000			 Selector 16 - 114
1   657	    0110  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    658		  0000			 Selector 16 - 114
1   659	    0118  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    660		  0000			 Selector 16 - 114
1   661	    0120  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    662		  0000			 Selector 16 - 114
1   663	    0128  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    664		  0000			 Selector 16 - 114
1   665	    0130  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    666		  0000			 Selector 16 - 114
1   667	    0138  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    668		  0000			 Selector 16 - 114
1   669	    0140  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    670		  0000			 Selector 16 - 114
1   671	    0148  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    672		  0000			 Selector 16 - 114
1   673	    0150  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    674		  0000			 Selector 16 - 114
1   675	    0158  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    676		  0000			 Selector 16 - 114
1   677	    0160  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    678		  0000			 Selector 16 - 114
1   679	    0168  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    680		  0000			 Selector 16 - 114
1   681	    0170  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    682		  0000			 Selector 16 - 114
1   683	    0178  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    684		  0000			 Selector 16 - 114
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 13
prcycle.ASM



1   685	    0180  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    686		  0000			 Selector 16 - 114
1   687	    0188  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    688		  0000			 Selector 16 - 114
1   689	    0190  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    690		  0000			 Selector 16 - 114
1   691	    0198  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    692		  0000			 Selector 16 - 114
1   693	    01A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    694		  0000			 Selector 16 - 114
1   695	    01A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    696		  0000			 Selector 16 - 114
1   697	    01B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    698		  0000			 Selector 16 - 114
1   699	    01B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    700		  0000			 Selector 16 - 114
1   701	    01C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    702		  0000			 Selector 16 - 114
1   703	    01C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    704		  0000			 Selector 16 - 114
1   705	    01D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    706		  0000			 Selector 16 - 114
1   707	    01D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    708		  0000			 Selector 16 - 114
1   709	    01E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    710		  0000			 Selector 16 - 114
1   711	    01E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    712		  0000			 Selector 16 - 114
1   713	    01F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    714		  0000			 Selector 16 - 114
1   715	    01F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    716		  0000			 Selector 16 - 114
1   717	    0200  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    718		  0000			 Selector 16 - 114
1   719	    0208  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    720		  0000			 Selector 16 - 114
1   721	    0210  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    722		  0000			 Selector 16 - 114
1   723	    0218  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    724		  0000			 Selector 16 - 114
1   725	    0220  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    726		  0000			 Selector 16 - 114
1   727	    0228  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    728		  0000			 Selector 16 - 114
1   729	    0230  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    730		  0000			 Selector 16 - 114
1   731	    0238  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    732		  0000			 Selector 16 - 114
1   733	    0240  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    734		  0000			 Selector 16 - 114
1   735	    0248  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    736		  0000			 Selector 16 - 114
1   737	    0250  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    738		  0000			 Selector 16 - 114
1   739	    0258  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    740		  0000			 Selector 16 - 114
1   741	    0260  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 14
prcycle.ASM



    742		  0000			 Selector 16 - 114
1   743	    0268  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    744		  0000			 Selector 16 - 114
1   745	    0270  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    746		  0000			 Selector 16 - 114
1   747	    0278  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    748		  0000			 Selector 16 - 114
1   749	    0280  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    750		  0000			 Selector 16 - 114
1   751	    0288  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    752		  0000			 Selector 16 - 114
1   753	    0290  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    754		  0000			 Selector 16 - 114
1   755	    0298  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    756		  0000			 Selector 16 - 114
1   757	    02A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    758		  0000			 Selector 16 - 114
1   759	    02A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    760		  0000			 Selector 16 - 114
1   761	    02B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    762		  0000			 Selector 16 - 114
1   763	    02B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    764		  0000			 Selector 16 - 114
1   765	    02C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    766		  0000			 Selector 16 - 114
1   767	    02C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    768		  0000			 Selector 16 - 114
1   769	    02D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    770		  0000			 Selector 16 - 114
1   771	    02D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    772		  0000			 Selector 16 - 114
1   773	    02E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    774		  0000			 Selector 16 - 114
1   775	    02E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    776		  0000			 Selector 16 - 114
1   777	    02F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    778		  0000			 Selector 16 - 114
1   779	    02F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    780		  0000			 Selector 16 - 114
1   781	    0300  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    782		  0000			 Selector 16 - 114
1   783	    0308  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    784		  0000			 Selector 16 - 114
1   785	    0310  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    786		  0000			 Selector 16 - 114
1   787	    0318  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    788		  0000			 Selector 16 - 114
1   789	    0320  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    790		  0000			 Selector 16 - 114
1   791	    0328  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    792		  0000			 Selector 16 - 114
1   793	    0330  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    794		  0000			 Selector 16 - 114
1   795	    0338  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    796		  0000			 Selector 16 - 114
1   797	    0340  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    798		  0000			 Selector 16 - 114
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 15
prcycle.ASM



1   799	    0348  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    800		  0000			 Selector 16 - 114
1   801	    0350  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    802		  0000			 Selector 16 - 114
1   803	    0358  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    804		  0000			 Selector 16 - 114
1   805	    0360  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    806		  0000			 Selector 16 - 114
1   807	    0368  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    808		  0000			 Selector 16 - 114
1   809	    0370  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    810		  0000			 Selector 16 - 114
1   811	    0378  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    812		  0000			 Selector 16 - 114
1   813	    0380  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    814		  0000			 Selector 16 - 114
1   815	    0388  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    816		  0000			 Selector 16 - 114
1   817	    0390  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    818		  0000			 Selector 16 - 114
    819	    0398  0B82r	0038 00	8F    +			 Gate	 <OtherBegin73,Other_Sel,,AT386TGate,>		 ; 115 IRQ11 0x73
    820		  0000
    821
    822							 REPT	 3
    823							 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    824					 Selector 116-118
    825							 ENDM
1   826	    03A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    827		  0000			 Selector 116-118
1   828	    03A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    829		  0000			 Selector 116-118
1   830	    03B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    831		  0000			 Selector 116-118
    832
    833							 ;Ethernet Interrupt IRQ15 i.e.	0x77 0r	119
    834							 ; using Interrupt Gate	for Ethernet Interrupt ISR
    835	    03B8  0000r	0140 00	8E    +			 Gate	 <test2,EthernetReceive_Sel,,AT386IGate,>	 ; Ether Receive    +
    836		  0000			 Interrupt 119
    837							 ;in the application, we need to change	the EtherReceive address
    838							 ;Gate	  <OtherBegin0,Other_Sel,,AT386TGate,>		 ; not used 1
    839
    840							 REPT	 115
    841							 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    842					 Selector 120 -	234
    843							 ENDM
1   844	    03C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    845		  0000			 Selector 120 -	234
1   846	    03C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    847		  0000			 Selector 120 -	234
1   848	    03D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    849		  0000			 Selector 120 -	234
1   850	    03D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    851		  0000			 Selector 120 -	234
1   852	    03E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    853		  0000			 Selector 120 -	234
1   854	    03E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    855		  0000			 Selector 120 -	234
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 16
prcycle.ASM



1   856	    03F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    857		  0000			 Selector 120 -	234
1   858	    03F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    859		  0000			 Selector 120 -	234
1   860	    0400  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    861		  0000			 Selector 120 -	234
1   862	    0408  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    863		  0000			 Selector 120 -	234
1   864	    0410  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    865		  0000			 Selector 120 -	234
1   866	    0418  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    867		  0000			 Selector 120 -	234
1   868	    0420  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    869		  0000			 Selector 120 -	234
1   870	    0428  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    871		  0000			 Selector 120 -	234
1   872	    0430  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    873		  0000			 Selector 120 -	234
1   874	    0438  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    875		  0000			 Selector 120 -	234
1   876	    0440  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    877		  0000			 Selector 120 -	234
1   878	    0448  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    879		  0000			 Selector 120 -	234
1   880	    0450  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    881		  0000			 Selector 120 -	234
1   882	    0458  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    883		  0000			 Selector 120 -	234
1   884	    0460  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    885		  0000			 Selector 120 -	234
1   886	    0468  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    887		  0000			 Selector 120 -	234
1   888	    0470  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    889		  0000			 Selector 120 -	234
1   890	    0478  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    891		  0000			 Selector 120 -	234
1   892	    0480  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    893		  0000			 Selector 120 -	234
1   894	    0488  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    895		  0000			 Selector 120 -	234
1   896	    0490  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    897		  0000			 Selector 120 -	234
1   898	    0498  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    899		  0000			 Selector 120 -	234
1   900	    04A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    901		  0000			 Selector 120 -	234
1   902	    04A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    903		  0000			 Selector 120 -	234
1   904	    04B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    905		  0000			 Selector 120 -	234
1   906	    04B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    907		  0000			 Selector 120 -	234
1   908	    04C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    909		  0000			 Selector 120 -	234
1   910	    04C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    911		  0000			 Selector 120 -	234
1   912	    04D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 17
prcycle.ASM



    913		  0000			 Selector 120 -	234
1   914	    04D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    915		  0000			 Selector 120 -	234
1   916	    04E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    917		  0000			 Selector 120 -	234
1   918	    04E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    919		  0000			 Selector 120 -	234
1   920	    04F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    921		  0000			 Selector 120 -	234
1   922	    04F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    923		  0000			 Selector 120 -	234
1   924	    0500  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    925		  0000			 Selector 120 -	234
1   926	    0508  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    927		  0000			 Selector 120 -	234
1   928	    0510  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    929		  0000			 Selector 120 -	234
1   930	    0518  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    931		  0000			 Selector 120 -	234
1   932	    0520  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    933		  0000			 Selector 120 -	234
1   934	    0528  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    935		  0000			 Selector 120 -	234
1   936	    0530  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    937		  0000			 Selector 120 -	234
1   938	    0538  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    939		  0000			 Selector 120 -	234
1   940	    0540  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    941		  0000			 Selector 120 -	234
1   942	    0548  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    943		  0000			 Selector 120 -	234
1   944	    0550  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    945		  0000			 Selector 120 -	234
1   946	    0558  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    947		  0000			 Selector 120 -	234
1   948	    0560  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    949		  0000			 Selector 120 -	234
1   950	    0568  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    951		  0000			 Selector 120 -	234
1   952	    0570  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    953		  0000			 Selector 120 -	234
1   954	    0578  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    955		  0000			 Selector 120 -	234
1   956	    0580  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    957		  0000			 Selector 120 -	234
1   958	    0588  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    959		  0000			 Selector 120 -	234
1   960	    0590  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    961		  0000			 Selector 120 -	234
1   962	    0598  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    963		  0000			 Selector 120 -	234
1   964	    05A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    965		  0000			 Selector 120 -	234
1   966	    05A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    967		  0000			 Selector 120 -	234
1   968	    05B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    969		  0000			 Selector 120 -	234
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 18
prcycle.ASM



1   970	    05B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    971		  0000			 Selector 120 -	234
1   972	    05C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    973		  0000			 Selector 120 -	234
1   974	    05C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    975		  0000			 Selector 120 -	234
1   976	    05D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    977		  0000			 Selector 120 -	234
1   978	    05D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    979		  0000			 Selector 120 -	234
1   980	    05E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    981		  0000			 Selector 120 -	234
1   982	    05E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    983		  0000			 Selector 120 -	234
1   984	    05F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    985		  0000			 Selector 120 -	234
1   986	    05F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    987		  0000			 Selector 120 -	234
1   988	    0600  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    989		  0000			 Selector 120 -	234
1   990	    0608  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    991		  0000			 Selector 120 -	234
1   992	    0610  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    993		  0000			 Selector 120 -	234
1   994	    0618  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    995		  0000			 Selector 120 -	234
1   996	    0620  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    997		  0000			 Selector 120 -	234
1   998	    0628  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
    999		  0000			 Selector 120 -	234
1  1000	    0630  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1001		  0000			 Selector 120 -	234
1  1002	    0638  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1003		  0000			 Selector 120 -	234
1  1004	    0640  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1005		  0000			 Selector 120 -	234
1  1006	    0648  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1007		  0000			 Selector 120 -	234
1  1008	    0650  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1009		  0000			 Selector 120 -	234
1  1010	    0658  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1011		  0000			 Selector 120 -	234
1  1012	    0660  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1013		  0000			 Selector 120 -	234
1  1014	    0668  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1015		  0000			 Selector 120 -	234
1  1016	    0670  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1017		  0000			 Selector 120 -	234
1  1018	    0678  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1019		  0000			 Selector 120 -	234
1  1020	    0680  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1021		  0000			 Selector 120 -	234
1  1022	    0688  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1023		  0000			 Selector 120 -	234
1  1024	    0690  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1025		  0000			 Selector 120 -	234
1  1026	    0698  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 19
prcycle.ASM



   1027		  0000			 Selector 120 -	234
1  1028	    06A0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1029		  0000			 Selector 120 -	234
1  1030	    06A8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1031		  0000			 Selector 120 -	234
1  1032	    06B0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1033		  0000			 Selector 120 -	234
1  1034	    06B8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1035		  0000			 Selector 120 -	234
1  1036	    06C0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1037		  0000			 Selector 120 -	234
1  1038	    06C8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1039		  0000			 Selector 120 -	234
1  1040	    06D0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1041		  0000			 Selector 120 -	234
1  1042	    06D8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1043		  0000			 Selector 120 -	234
1  1044	    06E0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1045		  0000			 Selector 120 -	234
1  1046	    06E8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1047		  0000			 Selector 120 -	234
1  1048	    06F0  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1049		  0000			 Selector 120 -	234
1  1050	    06F8  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1051		  0000			 Selector 120 -	234
1  1052	    0700  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1053		  0000			 Selector 120 -	234
1  1054	    0708  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1055		  0000			 Selector 120 -	234
1  1056	    0710  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1057		  0000			 Selector 120 -	234
1  1058	    0718  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1059		  0000			 Selector 120 -	234
1  1060	    0720  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1061		  0000			 Selector 120 -	234
1  1062	    0728  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1063		  0000			 Selector 120 -	234
1  1064	    0730  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1065		  0000			 Selector 120 -	234
1  1066	    0738  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1067		  0000			 Selector 120 -	234
1  1068	    0740  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1069		  0000			 Selector 120 -	234
1  1070	    0748  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1071		  0000			 Selector 120 -	234
1  1072	    0750  0000r	0150 00	8F    +			 Gate	 <IntException,IntException_Sel,,AT386TGate,>	 ; IntException	    +
   1073		  0000			 Selector 120 -	234
   1074
   1075	    0758  0000 00E8 00 85 0000			 Gate	 <,App1TSSS_Sel,,ATTaskGate,>			 ;0ebh:	Scheduler   +
   1076					 Task 235
   1077							 ;RKK0205
   1078							 ;Gate	  <,App1TSSE_Sel,,ATTaskGate,>			 ;0ech:	Error	    +
   1079					 Recovery Task 236
   1080	    0760  01AAr	0098 00	8F    +			 Gate	 <test1,Puthex32I_Sel,,AT386TGate,>		 ;0ech:	Error	    +
   1081		  0000			 Recovery Task 236
   1082
   1083							 ;Gate	 <MEMFetch, Puthex32I_Sel,,AT386TGate,>		 ;0ech:	free to	use +
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 20
prcycle.ASM



   1084					 236
   1085	    0768  0443r	0098 00	8F    +			 Gate	 <MEMFree, Puthex32I_Sel,,AT386TGate,>		 ;0edh:	free to	use +
   1086		  0000			 237
   1087	    0770  0413r	0098 00	8F    +			 Gate	 <MEMMalloc, Puthex32I_Sel,,AT386TGate,>	 ;0eeh:	malloc new  +
   1088		  0000			 memory	238
   1089	    0778  0000 00E0 00 85 0000			 Gate	 <,App1TSSC_Sel,,ATTaskGate,>			 ;0efh:	Application +
   1090					 1 Child 239
   1091	    0780  0248r	0098 00	8F    +			 Gate	 <scroll,Puthex32I_Sel,,AT386TGate,>		 ;0f0h:	scroll up   +
   1092		  0000			 one line 240
   1093	    0788  029Er	0098 00	8F    +			 Gate	 <CLScreen,Puthex32I_Sel,,AT386TGate,>		 ;0f1h:	clean screen+
   1094		  0000			 241
   1095	    0790  01E6r	0098 00	8F    +			 Gate	 <GetCursor,Puthex32I_Sel,,AT386TGate,>		 ;0f2h:	get the	    +
   1096		  0000			 cursor	postition 242
   1097	    0798  0217r	0098 00	8F    +			 Gate	 <SetCursor,Puthex32I_Sel,,AT386TGate,>		 ;0f3h:	set the	    +
   1098		  0000			 cursor	postion	243
   1099	    07A0  0000 0058 00 85 0000			 Gate	 <,WriteSecTSS_Sel,,ATTaskGate,>		 ;0f4h:	write one   +
   1100					 sector	at a time 244
   1101	    07A8  02D4r	0098 00	8F    +			 Gate	 <Getchar32,Puthex32I_Sel,,AT386TGate,>		 ;0f5h:	get a	    +
   1102		  0000			 character in protect mode 245
   1103	    07B0  0358r	0098 00	8F    +			 Gate	 <Getchar32Buff,Puthex32I_Sel,,AT386TGate,>	 ;0f6h:	get a	    +
   1104		  0000			 character from	the buffer
   1105	    07B8  0444r	0098 00	8F    +			 Gate	 <DisplayBegin,Puthex32I_Sel,,AT386TGate,>	 ;0f7h:	display	a   +
   1106		  0000			 character interrupt 247
   1107	    07C0  0000 00A8 00 85 0000			 Gate	 <,SearchTSS_Sel,,ATTaskGate,>			 ;0f8h:	Search	    +
   1108					 memory	for given value	248
   1109	    07C8  0000 0100 00 85 0000			 Gate	 <,App2TSS_Sel,,ATTaskGate,>			 ;0f9h:	Application +
   1110					 2 249
   1111	    07D0  0000 0050 00 85 0000			 Gate	 <,GetSecTSS_Sel,,ATTaskGate,>			 ;0fah:	read one    +
   1112					 sector	at a time 250
   1113	    07D8  0000 0048 00 85 0000			 Gate	 <,GetDecTSS_Sel,,ATTaskGate,>			 ;0fbh:	get decimal +
   1114					 251
   1115	    07E0  0000 0040 00 85 0000			 Gate	 <,GetCharTSS_Sel,,ATTaskGate,>			 ;0fch:	get	    +
   1116					 character 252
   1117	    07E8  0031r	0098 00	8F    +			 Gate	 <PUTHEX32P,Puthex32I_Sel,,AT386TGate,>		 ;0fdh:	Puthex32P   +
   1118		  0000			 253
   1119	    07F0  0000 00C8 00 85 0000			 Gate	 <,App1TSS_Sel,,ATTaskGate,>			 ;0feh:	Application +
   1120					 1 254
   1121	    07F8  0000 0060 00 85 0000			 Gate	 <,GKeyTSS_Sel,,ATTaskGate,>			 ;0ffh:	AOA display +
   1122					 255
   1123					 ;-------------------------------------------------------------------------
   1124		  = 0800		 IDTLen		 =	 $-IDT
   1125	    0800			 IDTSeg		 ENDS
   1126					 ;***************************************************************************
   1127					 ;  GDT	Segment
   1128					 ;  16 bit segment
   1129					 ;***************************************************************************
   1130	    0000			 GKeyLDTSeg	 SEGMENT PARA USE16
   1131
   1132	    0000			 GLDT		 LABEL	 BYTE
   1133
   1134	    0000  FFFF 0080s 00	98 00 +	 GKeyCode	 Desc	 <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>
   1135		  00
   1136		  = 0004		 GKeyCode_Sel	 =	 GKeyCode-GLDT+TIL
   1137	    0008  01FF 0080s 00	93 00 +	 GKeyStack	 Desc	 <DemoStack3Len-1,DemoStack3Seg+RELOCATE1,,ATDWA,,>
   1138		  00
   1139		  = 000C		 GKeyStack_Sel	 =	 GKeyStack-GLDT+TIL
   1140					 ;--------------------------------------------------------------------------
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 21
prcycle.ASM



   1141		  = 0002		 GKeyLDNum	 =	 ($-GLDT)/(SIZE	Desc)	 ;THE NUMBER OF	INITIAL	BASE
   1142		  = GKEYLDTSEG:0010	 GKeyLDTLen	 =	 $
   1143					 ;--------------------------------------------------------------------------
   1144	    0010			 GKeyLDTSeg	 ENDS
   1145					 ;***************************************************************************
   1146					 ;  GDT	Segment
   1147					 ;for general keyboard interrupt
   1148					 ;  16 bit segment
   1149					 ;***************************************************************************
   1150	    0000			 GetCharLDTSeg	    SEGMENT PARA USE16
   1151
   1152	    0000			 CLDT		 LABEL	 BYTE
   1153
   1154	    0000  FFFF 0080s 00	98 00 +	 GetCharCode	    Desc    <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>
   1155		  00
   1156		  = 0004		 GetCharCode_Sel    =	    GetCharCode-CLDT+TIL
   1157	    0008  01FF 0080s 00	93 00 +	 GetCharStack	    Desc    <GetCharStackLen-1,GetCharStackSeg+RELOCATE1,,ATDWA,,>
   1158		  00
   1159		  = 000C		 GetCharStack_Sel   =	    GetCharStack-CLDT+TIL
   1160					 ;--------------------------------------------------------------------------
   1161		  = 0002		 GetCharLDNum	    =	    ($-CLDT)/(SIZE Desc)    ;THE NUMBER	OF INITIAL BASE
   1162		  = GETCHARLDTSEG:0010	 GetCharLDTLen	    =	    $
   1163					 ;--------------------------------------------------------------------------
   1164	    0010			 GetCharLDTSeg	    ENDS
   1165					 ;***************************************************************************
   1166					 ;  SearchLDTSeg Segment
   1167					 ;  16 bit segment
   1168					 ;***************************************************************************
   1169	    0000			 SearchLDTSeg	   SEGMENT PARA	USE16
   1170
   1171	    0000			 SEARCHLDTS	       LABEL   BYTE
   1172
   1173	    0000  FFFF 0080s 00	98 00 +	 SearchCode	   Desc	   <0ffffh,PCodeSeg+RELOCATE1,,ATCE,,>
   1174		  00
   1175		  = 0004		 SearchCode_Sel	   =	   SearchCode-SEARCHLDTS+TIL
   1176	    0008  0111r	0080s 00 92 00+	 SearchData	   Desc	   <GlobalDataLen-1,GlobalDataSeg+RELOCATE1,,ATDW,,0h>
   1177		  00
   1178		  = 000C		 SearchData_Sel	   =	   SearchData-SEARCHLDTS+TIL
   1179	    0010  FFFF 0000 00 93 CF  +	 SearchForData	   Desc	   <0ffffh,0,0,93h,0cfh,0>
   1180		  00
   1181		  = 0014		 SearchForData_Sel =	   SearchForData-SEARCHLDTS+TIL
   1182	    0018  01FF 0080s 00	93 00 +	 SearchStack	   Desc	   <SearchStackLen-1,SearchStackSeg+RELOCATE1,,ATDWA,,>
   1183		  00
   1184		  = 001C		 SearchStack_Sel   =	   SearchStack-SEARCHLDTS+TIL
   1185					 ;--------------------------------------------------------------------------
   1186		  = 0004		 SearchLDNum	   =	   ($-SEARCHLDTS)/(SIZE	Desc)	 ;THE NUMBER OF	INITIAL	BASE
   1187		  = SEARCHLDTSEG:0020	 SearchLDTLen	   =	   $
   1188					 ;--------------------------------------------------------------------------
   1189	    0020			 SearchLDTSeg	   ENDS
   1190
   1191					 ;***************************************************************************
   1192	    0000			 GetDecLDTSeg	   SEGMENT PARA	USE16
   1193
   1194	    0000			 DLDT		 LABEL	 BYTE
   1195
   1196	    0000  FFFF 0080s 00	98 00 +	 GetDecCode	   Desc	   <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>
   1197		  00
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 22
prcycle.ASM



   1198		  = 0004		 GetDecCode_Sel	   =	   GetDecCode-DLDT+TIL
   1199	    0008  01FF 0080s 00	93 00 +	 GetDecStack	   Desc	   <GetDecStackLen-1,GetDecStackSeg+RELOCATE1,,ATDWA,,>
   1200		  00
   1201		  = 000C		 GetDecStack_Sel   =	   GetDecStack-DLDT+TIL
   1202					 ;--------------------------------------------------------------------------
   1203		  = 0002		 GetDecLDNum	   =	   ($-DLDT)/(SIZE Desc)	   ;THE	NUMBER OF INITIAL BASE
   1204		  = GETDECLDTSEG:0010	 GetDecLDTLen	   =	   $
   1205					 ;--------------------------------------------------------------------------
   1206	    0010			 GetDecLDTSeg	   ENDS
   1207					 ;***************************************************************************
   1208					 ;get sector LDT segment
   1209					 ;***************************************************************************
   1210	    0000			 GetSecLDTSeg	   SEGMENT PARA	USE16
   1211
   1212	    0000			 KLDT		 LABEL	 BYTE
   1213
   1214	    0000  FFFF 0080s 00	98 00 +	 GetSecCode	   Desc	   <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>
   1215		  00
   1216		  = 0004		 GetSecCode_Sel	   =	   GetSecCode-KLDT+TIL
   1217	    0008  01FF 0080s 00	93 00 +	 GetSecStack	   Desc	   <GetDecStackLen-1,GetDecStackSeg+RELOCATE1,,ATDWA,,>
   1218		  00
   1219		  = 000C		 GetSecStack_Sel   =	   GetSecStack-KLDT+TIL
   1220					 ;--------------------------------------------------------------------------
   1221		  = 0002		 GetSecLDNum	   =	   ($-KLDT)/(SIZE Desc)	   ;THE	NUMBER OF INITIAL BASE
   1222		  = GETSECLDTSEG:0010	 GetSecLDTLen	   =	   $
   1223					 ;--------------------------------------------------------------------------
   1224	    0010			 GetSecLDTSeg	   ENDS
   1225					 ;***************************************************************************
   1226					 ;Write	sector LDT segment
   1227					 ;***************************************************************************
   1228	    0000			 WriteSecLDTSeg	     SEGMENT PARA USE16
   1229
   1230	    0000			 WLDT		 LABEL	 BYTE
   1231
   1232	    0000  FFFF 0080s 00	98 00 +	 WriteSecCode	     Desc    <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>
   1233		  00
   1234		  = 0004		 WriteSecCode_Sel    =	     WriteSecCode-WLDT+TIL
   1235	    0008  01FF 0080s 00	93 00 +	 WriteSecStack	     Desc    <WriteSecStackLen-1,WriteSecStackSeg+RELOCATE1,,ATDWA,,>
   1236		  00
   1237		  = 000C		 WriteSecStack_Sel   =	     WriteSecStack-WLDT+TIL
   1238					 ;--------------------------------------------------------------------------
   1239		  = 0002		 WriteSecLDNum	     =	     ($-WLDT)/(SIZE Desc)    ;THE NUMBER OF INITIAL BASE
   1240		  = WRITESECLDTSEG:0010	 WriteSecLDTLen	     =	     $
   1241					 ;--------------------------------------------------------------------------
   1242	    0010			 WriteSecLDTSeg	     ENDS
   1243					 ;***************************************************************************
   1244	    0000			 App1LDTSeg	 SEGMENT PARA USE16
   1245					 ;----------------------------------------------------------------------------
   1246	    0000			 ALDT		 LABEL	 BYTE
   1247
   1248					 ;IApp1Code16	  Desc		 <IApp1CodeLen16-1,IApp1CodeSeg16+RELOCATE1,,ATCE,,>
   1249					 ;IApp1Code16_Sel =		 IApp1Code16-ALDT+TIL
   1250					 ;IApp1Code32	  Desc		 <IApp1CodeLen32-1,IApp1CodeSeg32+RELOCATE1,,ATCE,D32,>
   1251					 ;IApp1Code32_Sel =		 IApp1Code32-ALDT+TIL
   1252					 ;-----------------------------------------------------------------------------
   1253					 ;  SET	APPLICATION 1 SEGMENT DESCRIPTORS
   1254					 ;App1Stack	  Desc	 <0ffffh,400h+APPL1RELOCATE,10h,ATDWA,,>  ;740h
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 23
prcycle.ASM



   1255					 ;App1Stack	  Desc	 <0ffffh,40h+APPL1RELOCATE,10h,ATDWA,,>	 ;740h
   1256					 ;App1Stack	  Desc	 <0a00h,00h+APPL1RELOCATE,11h,ATSWA,,>	;
   1257					 ;App1Stack	  Desc	 <0ffffh,00h+APPL1RELOCATE,11h,ATSWA,,>	 ;
   1258					 ;App1Stack	  Desc	 <0fffh,00h+APPL1RELOCATE,23h,093h,0c0h,01h>  ;
   1259					 ;App1Stack	  Desc	 <0ffffh,00h+APPL1RELOCATE,11h,ATSWA,,>	 ;
   1260					 ;App1Stack	  Desc	 <0ffffh,00h+APPL1RELOCATE,0h,093h,0c0h,02h>  ;
   1261					 ;*************************************************
   1262					 ; The following stack segment will enable stack to
   1263					 ;  start at 01230000h RKK/LSUN	11-07-2003 working for
   1264					 ;  teststack example
   1265					 ; also	change ESP value to 00ffefffh in two places LARGESTACK
   1266					 ;  ---start of	stack 01230000h
   1267					 ;  ---	value in ESP + start of	stack --> top of stack
   1268					 ;  ---	Top of Stack is	01230000+00ffefff = 0222EFFFh
   1269					 ;  --	this is	good for 16M stack
   1270					 ;*************************************************
   1271					 ;App1Stack	  Desc	 <0ffffh,00h+APPL1RELOCATE,23h,093h,0cfh,01h>  ; last working
   1272	    0000  FFFF 0000 11 93 CF  +	 App1Stack	 Desc	 <0ffffh,00h+APPL1RELOCATE,11h,093h,0cfh,00h>  ; last working
   1273		  00
   1274		  = 0004		 App1Stack_Sel	 =	 App1Stack-ALDT+TIL
   1275					 ;------------------------------------------------------------------------------
   1276					 ;descriptor format
   1277					 ; Segment Limit (2 bytes LSB);	Base Address (2	bytes 15-0);Base Address (3rd byte 23-16);
   1278					 ;   P/DPL/S byte 5 1 00 1 0011;
   1279					 ;   G/B/00: 1100 byte 6; 0000 upper digit of limit byte 7
   1280					 ;   Base address is 01230000
   1281					 ;   Limit is 00fff*4k is 00fff000/
   1282					 ;   ESP shoud be initialized to 00ffefffh
   1283					 ;------------------------------------------------------------------------------
   1284					 ; App1Data
   1285					 ; App1Stack
   1286					 ; load	 0033; 0021; 0000; 0001; 1000 as parameters in the menu:
   1287					 ; point all ds, cs, ss	base values to 11
   1288					 ;------------------------------------------------------------------------------
   1289					 ;App1Data	  Desc	 <0ffffh,00h+APPL1RELOCATE,11h,ATDW,D32,>
   1290	    0008  FFFF 0000 11 92 CF  +	 App1Data	 Desc	<0ffffh,00h+APPL1RELOCATE,11h,ATDW,0cfh,0h> ; global bit set
   1291		  00
   1292		  = 000C		 App1Data_Sel	 =	 App1Data-ALDT+TIL
   1293	    0010  FFFF 0000 11 98 CF  +	 App1Code	 Desc	 <0ffffh,BaseOfCode+APPL1RELOCATE,11h,ATCE,0cfh,0h>
   1294		  00
   1295					 ;App1Code	  Desc		 <0ffffh,BaseOfCode+APPL1RELOCATE,20h,ATCE,0cfh,0h>  ;	    +
   1296					 global	bit set
   1297		  = 0014		 App1Code_Sel	 =	 App1Code-ALDT+TIL
   1298	    0018  292B 0014 00 EC 0000	 App1_Sch_Gate	   Gate	   <292Bh,App1Code_Sel,,AT386CGate+DPL3,>
   1299
   1300		  = 001C		 App1_Sch_Sel		 =	 App1_Sch_Gate-ALDT+TIL
   1301
   1302					 ;App1_Code	   Desc		 <0ffffh,292bh,11h,ATCE,0cfh,0h>
   1303					 ;App1Code	  Desc		 <0ffffh,BaseOfCode+APPL1RELOCATE,20h,ATCE,0cfh,0h>  ;	    +
   1304					 global	bit set
   1305					 ;App1_Code_Sel	   =		 App1_Code-ALDT+TIL
   1306
   1307					 ;--------------------------------------------------------------------------------
   1308					 ;App1Stack0	   Desc		 <400h,0h+APPL1RELOCATE,11h,ATSWA+DPL0,,>
   1309	    0020  FFFF 0000 00 93 C0  +	 App1Stack0	  Desc	 <0ffffh,00h+APPL1RELOCATE,0h,093h,0c0h,03h>  ;
   1310		  03
   1311		  = 0024		 App1Stack0_Sel	  =	 App1Stack0-ALDT+TIL
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 24
prcycle.ASM



   1312					 ;App1Stack1	   Desc		 <400h,0h+APPL1RELOCATE,11h,ATSWA+DPL1,,>
   1313	    0028  FFFF 0000 00 93 C0  +	 App1Stack1	  Desc	 <0ffffh,00h+APPL1RELOCATE,0h,093h,0c0h,04h>  ;
   1314		  04
   1315		  = 002C		 App1Stack1_Sel	  =	 App1Stack1-ALDT+TIL
   1316					 ;App1Stack2	   Desc		 <400h,0h+APPL1RELOCATE,11h,ATSWA+DPL3,,>
   1317	    0030  FFFF 0000 00 93 C0  +	 App1Stack2	  Desc	 <0ffffh,00h+APPL1RELOCATE,0h,093h,0c0h,05h>  ;
   1318		  05
   1319		  = 0034		 App1Stack2_Sel	  =	 App1Stack2-ALDT+TIL
   1320					 ;----------------------------------------------------------------------------
   1321		  = 0007		 App1LDNum	 =	 ($-ALDT)/(SIZE	Desc)	 ;THE NUMBER OF	INITIAL	BASE
   1322		  = APP1LDTSEG:0038	 App1LDTLen	 =	 $
   1323					 ;----------------------------------------------------------------------------
   1324	    0038			 App1LDTSeg	 ENDS
   1325					 ;--------------------------------------------------------------------------
   1326					 ;***************************************************************************
   1327	    0000			 App2LDTSeg	 SEGMENT PARA USE16
   1328					 ;----------------------------------------------------------------------------
   1329	    0000			 A2LDT		  LABEL	  BYTE
   1330
   1331	    0000  0A00 0000 41 96 00  +	 App2Stack	 Desc	 <0a00h,0h+APPL1RELOCATE,41h,ATSWA,,>  ;740h
   1332		  00
   1333		  = 0004		 App2Stack_Sel	 =	 App2Stack-A2LDT+TIL
   1334	    0008  FFFF 0000 41 92 40  +	 App2Data	 Desc	<0ffffh,APPL1RELOCATE,41h,ATDW,D32,>
   1335		  00
   1336					 ;App2Data	  Desc	 <0ffffh,00h+APPL1RELOCATE,11h,ATDW,0cfh,0h> ; global bit set
   1337
   1338		  = 000C		 App2Data_Sel	 =	 App2Data-A2LDT+TIL
   1339	    0010  FFFF 0000 40 98 CF  +	 App2Code	 Desc	 <0ffffh,BaseOfCode+APPL1RELOCATE,40h,ATCE,0cfh,0h>
   1340		  00
   1341					 ;App2Code	  Desc		 <0ffffh,BaseOfCode+APPL1RELOCATE,11h,ATCE,0cfh,0h>
   1342		  = 0014		 App2Code_Sel	 =	 App2Code-A2LDT+TIL
   1343					 ;----------------------------------------------------------------------------
   1344		  = 0003		 App2LDNum	 =	 ($-A2LDT)/(SIZE Desc)		 ;THE NUMBER OF	INITIAL	BASE
   1345		  = APP2LDTSEG:0018	 App2LDTLen	 =	 $
   1346					 ;----------------------------------------------------------------------------
   1347	    0018			 App2LDTSeg	 ENDS
   1348					 ;--------------------------------------------------------------------------
   1349					 ;***************************************************************************
   1350					 ;   GkeyTSSSeg	Segment
   1351					 ;   16	bit segment
   1352					 ;   This is a 32 bit TSS format (386 and higher)
   1353					 ;***************************************************************************
   1354	    0000			 GKeyTSSSeg	 SEGMENT PARA USE16
   1355	    0000  00000000				 DD	 0			 ;LINK
   1356	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1357	    0008  ???? ????				 DW	 ?,?
   1358	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1359	    0010  ???? ????				 DW	 ?,?
   1360	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1361	    0018  ???? ????				 DW	 ?,?
   1362	    001C  00000000				 DD	 0			 ;CR3
   1363	    0020  039Er	0000				 DW	 GKeyBegin,0		 ;EIP
   1364	    0024  00000000				 DD	 0			 ;EFLAGS
   1365	    0028  00000000				 DD	 0			 ;EAX
   1366	    002C  00000000				 DD	 0			 ;ECX
   1367	    0030  00000000				 DD	 0			 ;EDX
   1368	    0034  00000000				 DD	 0			 ;EBX
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 25
prcycle.ASM



   1369	    0038  0200 0000				 DW	 DemoStack3Len,0	  ;ESP
   1370	    003C  00000000				 DD	 0			 ;EBP
   1371	    0040  00000000				 DD	 0			 ;ESI
   1372	    0044  00000000				 DD	 0			 ;EDI
   1373	    0048  0008 0000				 DW	 Normal_Sel,0		 ;ES
   1374	    004C  0004 0000				 DW	 GKeyCode_Sel,0		 ;CS
   1375	    0050  000C 0000				 DW	 GKeyStack_Sel,0	 ;SS
   1376	    0054  0008 0000				 DW	 Normal_Sel,0		 ;DS
   1377	    0058  0008 0000				 DW	 Normal_Sel,0		 ;FS
   1378	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1379	    0060  0068 0000				 DW	 GKeyLDT_Sel,0		 ;LDTR
   1380	    0064  0000					 DW	 0			 ;TRAP SIGN
   1381	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1382	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1383		  = GKEYTSSSEG:0069	 GKeyTSSLen	 =	 $
   1384					 ;----------------------------------------------------------------------------
   1385	    0069			 GKeyTSSSeg	 ENDS
   1386					 ;***************************************************************************
   1387					 ;   SearchTSSSeg Segment
   1388					 ;   16	bit segment
   1389					 ;   This is a 32 bit TSS format (386 and higher)
   1390					 ;***************************************************************************
   1391	    0000			 SearchTSSSeg	   SEGMENT PARA	USE16
   1392	    0000  00000000				 DD	 0			 ;LINK
   1393	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1394	    0008  ???? ????				 DW	 ?,?
   1395	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1396	    0010  ???? ????				 DW	 ?,?
   1397	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1398	    0018  ???? ????				 DW	 ?,?
   1399	    001C  00000000				 DD	 0			 ;CR3
   1400	    0020  0486r	0000				 DW	 SearchBegin,0		 ;EIP
   1401	    0024  00000000				 DD	 0			 ;EFLAGS
   1402	    0028  00000000				 DD	 0			 ;EAX
   1403	    002C  00000000				 DD	 0			 ;ECX
   1404	    0030  00000000				 DD	 0			 ;EDX
   1405	    0034  00000000				 DD	 0			 ;EBX
   1406	    0038  0200 0000				 DW	 SearchStackLen,0	 ;ESP
   1407	    003C  00000000				 DD	 0			 ;EBP
   1408	    0040  00000000				 DD	 0			 ;ESI
   1409	    0044  00000000				 DD	 0			 ;EDI
   1410	    0048  0014 0000				 DW	 SearchForData_Sel,0		;ES
   1411	    004C  0004 0000				 DW	 SearchCode_Sel,0	 ;CS
   1412	    0050  001C 0000				 DW	 SearchStack_Sel,0	 ;SS
   1413	    0054  000C 0000				 DW	 SearchData_Sel,0	     ;DS
   1414	    0058  000C 0000				 DW	 SearchData_Sel,0	     ;FS
   1415	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1416	    0060  00A0 0000				 DW	 SearchLDT_Sel,0	 ;LDTR
   1417	    0064  0000					 DW	 0			 ;TRAP SIGN
   1418	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1419	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1420		  = SEARCHTSSSEG:0069	 SearchTSSLen	   =	   $
   1421					 ;----------------------------------------------------------------------------
   1422	    0069			 SearchTSSSeg	   ENDS
   1423
   1424					 ;***************************************************************************
   1425					 ;   GkeyTSSSeg	Segment
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 26
prcycle.ASM



   1426					 ;   16	bit segment
   1427					 ;   This is a 32 bit TSS format (386 and higher)
   1428					 ;***************************************************************************
   1429	    0000			 GetCharTSSSeg	    SEGMENT PARA USE16
   1430	    0000  00000000				 DD	 0			 ;LINK
   1431	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1432	    0008  ???? ????				 DW	 ?,?
   1433	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1434	    0010  ???? ????				 DW	 ?,?
   1435	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1436	    0018  ???? ????				 DW	 ?,?
   1437	    001C  00000000				 DD	 0			 ;CR3
   1438	    0020  0299r	0000				 DW	 GetCharBegin,0		    ;EIP
   1439	    0024  00000000				 DD	 0			 ;EFLAGS
   1440	    0028  00000000				 DD	 0			 ;EAX
   1441	    002C  00000000				 DD	 0			 ;ECX
   1442	    0030  00000000				 DD	 0			 ;EDX
   1443	    0034  00000000				 DD	 0			 ;EBX
   1444	    0038  0200 0000				 DW	 GetCharStackLen,0	    ;ESP
   1445	    003C  00000000				 DD	 0			 ;EBP
   1446	    0040  00000000				 DD	 0			 ;ESI
   1447	    0044  00000000				 DD	 0			 ;EDI
   1448	    0048  0008 0000				 DW	 Normal_Sel,0		 ;ES
   1449	    004C  0004 0000				 DW	 GetCharCode_Sel,0	    ;CS
   1450	    0050  000C 0000				 DW	 GetCharStack_Sel,0	    ;SS
   1451	    0054  0008 0000				 DW	 Normal_Sel,0		 ;DS
   1452	    0058  0008 0000				 DW	 Normal_Sel,0		 ;FS
   1453	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1454	    0060  0070 0000				 DW	 GetCharLDT_Sel,0	    ;LDTR
   1455	    0064  0000					 DW	 0			 ;TRAP SIGN
   1456	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1457	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1458		  = GETCHARTSSSEG:0069	 GetCharTSSLen	    =	    $
   1459					 ;----------------------------------------------------------------------------
   1460	    0069			 GetCharTSSSeg	    ENDS
   1461
   1462					 ;******************************************************************************
   1463					 ;***************************************************************************
   1464					 ;   GetDecTSSSeg Segment
   1465					 ;   16	bit segment
   1466					 ;   This is a 32 bit TSS format (386 and higher)
   1467					 ;***************************************************************************
   1468	    0000			 GetDecTSSSeg	   SEGMENT PARA	USE16
   1469	    0000  00000000				 DD	 0			 ;LINK
   1470	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1471	    0008  ???? ????				 DW	 ?,?
   1472	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1473	    0010  ???? ????				 DW	 ?,?
   1474	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1475	    0018  ???? ????				 DW	 ?,?
   1476	    001C  00000000				 DD	 0			 ;CR3
   1477	    0020  02FFr	0000				 DW	 GetDecBegin,0		   ;EIP
   1478	    0024  00000000				 DD	 0			 ;EFLAGS
   1479	    0028  00000000				 DD	 0			 ;EAX
   1480	    002C  00000000				 DD	 0			 ;ECX
   1481	    0030  00000000				 DD	 0			 ;EDX
   1482	    0034  00000000				 DD	 0			 ;EBX
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 27
prcycle.ASM



   1483	    0038  0200 0000				 DW	 GetDecStackLen,0	 ;ESP
   1484	    003C  00000000				 DD	 0			 ;EBP
   1485	    0040  00000000				 DD	 0			 ;ESI
   1486	    0044  00000000				 DD	 0			 ;EDI
   1487	    0048  0008 0000				 DW	 Normal_Sel,0		 ;ES
   1488	    004C  0004 0000				 DW	 GetDecCode_Sel,0	   ;CS
   1489	    0050  000C 0000				 DW	 GetDecStack_Sel,0	   ;SS
   1490	    0054  0008 0000				 DW	 Normal_Sel,0		 ;DS
   1491	    0058  0008 0000				 DW	 Normal_Sel,0		 ;FS
   1492	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1493	    0060  0078 0000				 DW	 GetDecLDT_Sel,0	   ;LDTR
   1494	    0064  0000					 DW	 0			 ;TRAP SIGN
   1495	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1496	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1497		  = GETDECTSSSEG:0069	 GetDecTSSLen	   =	   $
   1498					 ;----------------------------------------------------------------------------
   1499	    0069			 GetDecTSSSeg	   ENDS
   1500
   1501					 ;******************************************************************************
   1502					 ;   GetSecTSSSeg Segment
   1503					 ;   16	bit segment
   1504					 ;   This is a 32 bit TSS format (386 and higher)
   1505					 ;    Read one sector task
   1506					 ;***************************************************************************
   1507	    0000			 GetSecTSSSeg	   SEGMENT PARA	USE16
   1508	    0000  00000000				 DD	 0			 ;LINK
   1509	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1510	    0008  ???? ????				 DW	 ?,?
   1511	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1512	    0010  ???? ????				 DW	 ?,?
   1513	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1514	    0018  ???? ????				 DW	 ?,?
   1515	    001C  00000000				 DD	 0			 ;CR3
   1516	    0020  0414r	0000				 DW	 GetSecBegin,0		   ;EIP
   1517	    0024  00000000				 DD	 0			 ;EFLAGS
   1518	    0028  00000000				 DD	 0			 ;EAX
   1519	    002C  00000000				 DD	 0			 ;ECX
   1520	    0030  00000000				 DD	 0			 ;EDX
   1521	    0034  00000000				 DD	 0			 ;EBX
   1522	    0038  0200 0000				 DW	 GetSecStackLen,0	 ;ESP
   1523	    003C  00000000				 DD	 0			 ;EBP
   1524	    0040  00000000				 DD	 0			 ;ESI
   1525	    0044  00000000				 DD	 0			 ;EDI
   1526	    0048  0008 0000				 DW	 Normal_Sel,0		 ;ES
   1527	    004C  0004 0000				 DW	 GetSecCode_Sel,0	 ;CS
   1528	    0050  000C 0000				 DW	 GetSecStack_Sel,0	 ;SS
   1529	    0054  0008 0000				 DW	 Normal_Sel,0		 ;DS
   1530	    0058  0008 0000				 DW	 Normal_Sel,0		 ;FS
   1531	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1532	    0060  0080 0000				 DW	 GetSecLDT_Sel,0	 ;LDTR
   1533	    0064  0000					 DW	 0			 ;TRAP SIGN
   1534	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1535	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1536		  = GETSECTSSSEG:0069	 GetSecTSSLen	   =	   $
   1537					 ;----------------------------------------------------------------------------
   1538	    0069			 GetSecTSSSeg	   ENDS
   1539					 ;******************************************************************************
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 28
prcycle.ASM



   1540					 ;******************************************************************************
   1541					 ;   WriteSecTSSSeg Segment
   1542					 ;   16	bit segment
   1543					 ;   This is a 32 bit TSS format (386 and higher)
   1544					 ;    Write one	sector task
   1545					 ;***************************************************************************
   1546	    0000			 WriteSecTSSSeg	     SEGMENT PARA USE16
   1547	    0000  00000000				 DD	 0			 ;LINK
   1548	    0004  ????????				 DD	 ?			 ;STACK	POINTER	LEVEL 0
   1549	    0008  ???? ????				 DW	 ?,?
   1550	    000C  ????????				 DD	 ?			 ;LEVEL	1
   1551	    0010  ???? ????				 DW	 ?,?
   1552	    0014  ????????				 DD	 ?			 ;LEVEL	2
   1553	    0018  ???? ????				 DW	 ?,?
   1554	    001C  00000000				 DD	 0			 ;CR3
   1555	    0020  04BEr	0000				 DW	 WriteSecBegin,0	 ;EIP
   1556	    0024  00000000				 DD	 0			 ;EFLAGS
   1557	    0028  00000000				 DD	 0			 ;EAX
   1558	    002C  00000000				 DD	 0			 ;ECX
   1559	    0030  00000000				 DD	 0			 ;EDX
   1560	    0034  00000000				 DD	 0			 ;EBX
   1561	    0038  0200 0000				 DW	 GetSecStackLen,0	   ;ESP
   1562	    003C  00000000				 DD	 0			 ;EBP
   1563	    0040  00000000				 DD	 0			 ;ESI
   1564	    0044  00000000				 DD	 0			 ;EDI
   1565	    0048  0008 0000				 DW	 Normal_Sel,0		 ;ES
   1566	    004C  0004 0000				 DW	 GetSecCode_Sel,0	 ;CS
   1567	    0050  000C 0000				 DW	 GetSecStack_Sel,0	 ;SS
   1568	    0054  0008 0000				 DW	 Normal_Sel,0		 ;DS
   1569	    0058  0008 0000				 DW	 Normal_Sel,0		 ;FS
   1570	    005C  0008 0000				 DW	 Normal_Sel,0		 ;GS
   1571	    0060  0080 0000				 DW	 GetSecLDT_Sel,0	 ;LDTR
   1572	    0064  0000					 DW	 0			 ;TRAP SIGN
   1573	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1574	    0068  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1575		  = WRITESECTSSSEG:0069	 WriteSecTSSLen	     =	     $
   1576					 ;----------------------------------------------------------------------------
   1577	    0069			 WriteSecTSSSeg	     ENDS
   1578					 ;******************************************************************************
   1579					 ; Application 1 TSS
   1580					 ; This	is a 32	bit TSS	format (386 and	higher)
   1581					 ; ALL the Selectors for the Segment registers being initialized in the
   1582					 ; TSS Segment must be located in the App1LDTSeg
   1583					 ;	 If we want to run a 16	bit internal application open up the
   1584					 ;	 two comments	 I.	 DW	 IApp1Begin16,0
   1585					 ;			 II.	 DW	 IApp1Code16_Sel,0
   1586					 ;
   1587					 ;	 If we want to run a 32	bit internal application open up the
   1588					 ;	 two comments	 I.	 DW	 IApp1Begin32,0
   1589					 ;			 II.	 DW	 IApp1Code32_Sel,0
   1590					 ;******************************************************************************
   1591	00000000			 App1TSSSeg	 SEGMENT PARA USE32
   1592
   1593	00000000			 App1TaskTSS	 LABEL	 BYTE
   1594	00000000  00000000				 DD	 0			 ;LINK
   1595	00000004  0000FFFF				 DD	 0ffffh			 ;stack	0 length
   1596	00000008  00000024				 DD	 App1Stack0_Sel		 ;stack	selector for 0 level
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 29
prcycle.ASM



   1597	0000000C  0000FFFF				 DD	 0ffffh				 ;stack	1 length
   1598	00000010  0000002C				 DD	 App1Stack1_Sel		 ;stack	selector for 1 level
   1599	00000014  0000FFFF				 DD	 0ffffh			   ;stack 2 length
   1600	00000018  00000034				 DD	 App1Stack2_Sel		 ;stack	selector for 2 level
   1601	0000001C  00000000				 DD	 0			 ;CR3
   1602	00000020  00000000				 DD	 0h			 ;EIP
   1603						 ;	 DD	 3202h			   ;EFLAGS
   1604	00000024  00000202				 DD	 0202h			   ;EFLAGS
   1605	00000028  00000000				 DD	 0			 ;EAX
   1606	0000002C  00000000				 DD	 0			 ;ECX
   1607	00000030  00000000				 DD	 0			 ;EDX
   1608	00000034  00000000				 DD	 0			 ;EBX
   1609							 ;DW	  0ffffh,0		 ;App1StackLen,0 ;ESP
   1610							 ;DW	  0d00h,0		 ;App1StackLen,0 ;ESP
   1611							 ;DW	  0ffffh,0013h		 ;App1StackLen,0 ;ESP
   1612							 ;dd	 01ffffh
   1613							 ;dd	 0fffffh
   1614							 ;dd	 0000ffffh
   1615							 ;dd	 00ffefffh		  ;LARGESTACK works for	teststack example
   1616	00000038  01E84800				 dd	 01e84800h		  ; 32 M
   1617							 ;dd	 01ff0000h
   1618							 ;dd	 0000ffffh
   1619							 ; because we use the stack dowside, system will add statck start address by+
   1620					 esp
   1621							 ; this	will be	the actual start address and stack will	go down
   1622							 ; for ex: if the code starts at 00111000h and PSP is at 00110000h
   1623							 ;  we would like to start stack at 00110d00h, in order	to achieve this
   1624							 ;  we can set esp a value of 0d00h, base value	in the selector	will be	0h
   1625							 ;    and the limit will be 0a00h so that 0200h	will be	left for PSP
   1626	0000003C  00000000				 DD	 0			 ;EBP
   1627	00000040  00000000				 DD	 0			 ;ESI
   1628	00000044  00000000				 DD	 0			 ;EDI
   1629	00000048  000C 0000				 DW	 App1Data_Sel,0		 ;ES
   1630	0000004C  0014 0000				 DW	 App1Code_Sel,0		 ;CS
   1631	00000050  0004 0000				 DW	 App1Stack_Sel,0	 ;SS
   1632	00000054  000C 0000				 DW	 App1Data_Sel,0		 ;DS
   1633	00000058  0000 0000				 DW	 0,0			 ;FS
   1634	0000005C  0000 0000				 DW	 0,0			 ;GS
   1635	00000060  00D8 0000				 DW	 App1LDT_Sel,0		 ;LDTR also there in GDT
   1636	00000064  0000					 DW	 0			 ;TRAP SIGN
   1637	00000066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1638	00000068  07*(00)				 DB	 7 DUP(0)		 ;I/O MAPPING Rounding it to 112 bytes in   +
   1639					 the user memory space
   1640	0000006F  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1641		  = APP1TSSSEG:0070	 App1TSSLen	 =	 $			 ; Length of the segment a constant
   1642					 ; this	stored in memory at SizeOf_TSS1	as a word
   1643					 ;----------------------------------------------------------------------------
   1644	00000070			 App1TSSSeg	 ENDS
   1645
   1646					 ;***************************************************************************
   1647	    0000			 App2TSSSeg	 SEGMENT PARA USE16
   1648	    0000			 App2TaskTSS	 LABEL	 BYTE
   1649	    0000  00000000				 DD	 0			 ;LINK
   1650	    0004  00000000				 DD	 0h			 ;stack	0 length
   1651	    0008  00000000				 DD	 0h			 ;stack	selector for 0 level
   1652	    000C  00000000				 DD	 0h			 ;stack	1 length
   1653	    0010  00000000				 DD	 0h			 ;stack	selector for 1 level
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 30
prcycle.ASM



   1654	    0014  00000000				 DD	 0h			 ;stack	2 length
   1655	    0018  00000000				 DD	 0h			 ;stack	selector for 2 level
   1656	    001C  00000000				 DD	 0			 ;CR3
   1657	    0020  00000000				 DD	 0h			 ;EIP
   1658	    0024  000000CA				 DD	 0202			    ;EFLAGS
   1659	    0028  00000000				 DD	 0			 ;EAX
   1660	    002C  00000000				 DD	 0			 ;ECX
   1661	    0030  00000000				 DD	 0			 ;EDX
   1662	    0034  00000000				 DD	 0			 ;EBX
   1663	    0038  0D00 0000				 DW	 0d00h,0		 ;App1StackLen,0 ;ESP
   1664	    003C  00000000				 DD	 0			 ;EBP
   1665	    0040  00000000				 DD	 0			 ;ESI
   1666	    0044  00000000				 DD	 0			 ;EDI
   1667	    0048  000C 0000				 DW	 App2Data_Sel,0		 ;ES
   1668	    004C  0014 0000				 DW	 App2Code_Sel,0		 ;CS
   1669	    0050  0004 0000				 DW	 App2Stack_Sel,0	 ;SS
   1670	    0054  000C 0000				 DW	 App2Data_Sel,0		 ;DS
   1671	    0058  0000 0000				 DW	 0,0			 ;FS
   1672	    005C  0000 0000				 DW	 0,0			 ;GS
   1673	    0060  0110 0000				 DW	 App2LDT_Sel,0		 ;LDTR
   1674	    0064  0000					 DW	 0			 ;TRAP SIGN
   1675	    0066  0068r					 DW	 $+2			 ;I/O MAPPING OFFSET
   1676	    0068  0397*(00)				 DB	 919 DUP(0)		 ;I/O MAPPING
   1677	    03FF  FF					 DB	 0ffh			 ;END OF I/O MAPPING
   1678		  = APP2TSSSEG:0400	 App2TSSLen	 =	 $
   1679					 ;----------------------------------------------------------------------------
   1680	    0400			 App2TSSSeg	 ENDS
   1681
   1682					 ;***************************************************************************
   1683					 ; DemoLDTSeg Segment
   1684					 ; 16 bit segment
   1685					 ;***************************************************************************
   1686	    0000			 DemoLDTSeg	 SEGMENT PARA USE16
   1687
   1688	    0000			 DemoLDT	 LABEL	 BYTE
   1689	    0000  01FF 0080s 00	92 40 +	 DemoStack0		 Desc	 <DemoStack0Len-1,DemoStack0Seg+RELOCATE1,,ATDW+DPL0,D32,>
   1690		  00
   1691	    0008  01F5 0080s 00	B2 40 +	 DemoStack1		 Desc	 <DemoStack1Len-1,DemoStack1Seg+RELOCATE1,,ATDW+DPL1,D32,>
   1692		  00
   1693	    0010  01FF 0080s 00	F2 00 +	 DemoStack3		 Desc	 <DemoStack3Len-1,DemoStack3Seg+RELOCATE1,,ATDW+DPL3,,>
   1694		  00
   1695	    0018  0464r	0080s 00 F8 40+	 DemoCode		 Desc	 <DemoCodeLen-1,DemoCodeSeg+RELOCATE1,,ATCE+DPL3,D32,>
   1696		  00
   1697	    0020  0464r	0080s 00 98 40+	 T32Code		 Desc	 <DemoCodeLen-1,DemoCodeSeg+RELOCATE1,,ATCE,D32,>
   1698		  00
   1699	    0028  0464r	0080s 00 98 40+	 ProtCode		 Desc <DemoCodeLen-1,DemoCodeSeg+RELOCATE1,,ATCE,D32,>
   1700		  00
   1701	    0030  0017r	0080s 00 92 40+	 ProtModeProcData	 Desc <ProtModeProcDataLen-1,ProtModeProcDataSeg+RELOCATE1,,ATDW,   +
   1702		  00			 D32,0h>
   1703					 ; only	BaseL is shifted in InitLDT, so	enter the value	one digit less or left shifted by   +
   1704					 one digit
   1705					 ; for example 8400h offset should be enetered as 840h,	InitLDT	will shift and make it 8400h
   1706	    0038  FFFF 0000 00 92 CF  +	 PrintMemProcData	 Desc	 <0ffffh,0h,0h,ATDW,0cfh,0h>	      ;for loading fs
   1707		  00
   1708	    0040  FFFF 0000 10 92 CF  +	 StartAddress		 Desc	 <0ffffh,0h,10h,ATDW,0cfh,0h>	    ;above 1M descriptor
   1709		  00
   1710	    0048  FFFF 0840 00 92 00  +	 Buffer			 Desc	 <0ffffh,840h,,ATDW,,>	     ;for loading es
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 31
prcycle.ASM



   1711		  00
   1712
   1713					 ; You need to add RDataSeg and	RELOCATE1 here so that the base	value will be
   1714					 ; taken care off
   1715					 ; Do not use DS if you	want to	address	real memory data as DS is already
   1716					 ; being used for protected mode data using ASSUME
   1717					 ; Use es instead to solve this	problem
   1718	    0050  FFFF 0080s 00	92 00 +	 RealData		 Desc	 <0ffffh,RDataSeg+RELOCATE1,,ATDW,,>	   ;for	loading	fs
   1719		  00
   1720	    0058  FFFF 0000 00 98 40  +	 GotoPCode		 Desc	 <0ffffh,APPL1RELOCATE,,ATCE,D32,>
   1721		  00
   1722					 ;------------------------------------------------------------------------
   1723		  = 000C		 DemoLDNum	 =	 ($-DemoLDT)/(SIZE Desc)
   1724					 ;------------------------------------------------------------------------
   1725		  = 0004		 DemoStack0_Sel		 =	 DemoStack0-DemoLDT+TIL+RPL0
   1726		  = 000D		 DemoStack1_Sel		 =	 DemoStack1-DemoLDT+TIL+RPL1
   1727		  = 0017		 DemoStack3_Sel		 =	 DemoStack3-DemoLDT+TIL+RPL3
   1728		  = 001F		 DemoCode_Sel		 =	 DemoCode-DemoLDT+TIL+RPL3
   1729		  = 0024		 T32Code_Sel		 =	 T32Code-DemoLDT+TIL
   1730		  = 002C		 ProtCode_Sel		 =	 ProtCode-DemoLDT+TIL
   1731		  = 0034		 ProtModeProcData_Sel	 =	 ProtModeProcData-DemoLDT+TIL
   1732		  = 003C		 PrintMemProcData_Sel	 =	 PrintMemProcData-DemoLDT+TIL
   1733		  = 0054		 RealData_Sel		 =	 RealData-DemoLDT+TIL
   1734		  = 0044		 StartAddress_Sel	 =	 StartAddress-DemoLDT+TIL
   1735		  = 004C		 Buffer_Sel		 =	 Buffer-DemoLDT+TIL
   1736
   1737		  = 005C		 GotoPCode_Sel		 =	 GotoPCode-DemoLDT+TIL
   1738					 ;------------------------------------------------------------------------
   1739	    0060  0007r	0024 00	EC    +	 ToT32GateA		 Gate	 <T32Begin,T32Code_Sel,,AT386CGate+DPL3,>
   1740		  0000
   1741	    0068  002Ar	0024 00	EC    +	 ToT32GateB		 Gate	 <T32End,T32Code_Sel,,AT386CGate+DPL3,>
   1742		  0000
   1743	    0070  0031r	002C 00	EC    +	 ProtModeProcGate1	 Gate	 <PUTHEX32P,ProtCode_Sel,,AT386CGate+DPL3,>
   1744		  0000
   1745	    0078  008Cr	002C 00	EC    +	 App_Scheduler_Gate	 Gate	 <APPSCHEDULE,ProtCode_Sel,,AT386CGate+DPL3,>
   1746		  0000
   1747	    0080  0099r	002C 00	EC    +	 ProtModeProcGate2	 Gate	 <PRINTMEMP,ProtCode_Sel,,AT386CGate+DPL3,>
   1748		  0000
   1749	    0088  00CFr	002C 00	EC    +	 ProtModeProcGate3	 Gate	 <PRINTSTP, ProtCode_Sel,,AT386CGate+DPL3,>
   1750		  0000
   1751	    0090  012Ar	002C 00	EC    +	 RDWTMemGate		 Gate	 <RDWTMEM,  ProtCode_Sel,,AT386CGate+DPL3,>
   1752		  0000
   1753
   1754	    0098  0000 005C 00 EC 0000	 GotoPGate		 Gate	 <0h,GotoPCode_Sel,,AT386CGate+DPL3,>
   1755					 ;-----------------------------------------------------------------------
   1756		  = 00A0		 DemoLDTLen		 =	 $-DemoLDT
   1757					 ;------------------------------------------------------------------------
   1758		  = 0064		 ToT32A_Sel		 =	 ToT32GateA-DemoLDT+TIL
   1759		  = 006C		 ToT32B_Sel		 =	 ToT32GateB-DemoLDT+TIL
   1760		  = 0074		 Puthex32PGate_Sel	 =	 ProtModeProcGate1-DemoLDT+TIL
   1761		  = 007C		 App_Scheduler_Sel	 =	 App_Scheduler_Gate-DemoLDT+TIL
   1762		  = 0084		 PrintmemPGate_Sel	 =	 ProtModeProcGate2-DemoLDT+TIL
   1763		  = 008C		 PrintStackPGate_Sel	 =     ProtModeProcGate3-DemoLDT+TIL
   1764		  = 0094		 RDWTMemPGate_Sel	 =     RDWTMemGate-DemoLDT+TIL
   1765
   1766		  = 009C		 GotoPGate_Sel	 =	 GotoPGate-DemoLDT+TIL
   1767					 ;----------------------------------------------------------------------------
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 32
prcycle.ASM



   1768	    00A0			 DemoLDTSeg	 ENDS
   1769					 ;----------------------------------------------------------------------------
   1770
   1771					 ;***************************************************************************
   1772					 ; DemoTSSSeg Segment
   1773					 ; 16 bit segment
   1774					 ;***************************************************************************
   1775	    0000			 DemoTSSSeg	 SEGMENT PARA USE16
   1776	    0000  00000000				 DD	 0
   1777	    0004  00000200				 DD	 DemoStack0Len
   1778	    0008  00000004				 DD	 DemoStack0_Sel
   1779	    000C  000001F6				 DD	 DemoStack1Len
   1780	    0010  0000000D				 DD	 DemoStack1_Sel
   1781	    0014  00000000				 DD	 0
   1782	    0018  00000000				 DD	 0
   1783	    001C  00000000				 DD	 0			   ;CR3
   1784	    0020  00000000				 DD	 0			   ;EIP
   1785	    0024  00000000				 DD	 0			   ;EFLAGS
   1786	    0028  00000000				 DD	 0			   ;EAX
   1787	    002C  00000000				 DD	 0			   ;ECX
   1788	    0030  00000000				 DD	 0			   ;EDX
   1789	    0034  00000000				 DD	 0			   ;EBX
   1790	    0038  00000000				 DD	 0			   ;ESP
   1791	    003C  00000000				 DD	 0			   ;EBP
   1792	    0040  00000000				 DD	 0			   ;ESI
   1793	    0044  00000000				 DD	 0			   ;EDI
   1794	    0048  00000000				 DD	 0			   ;ES
   1795	    004C  00000000				 DD	 0			   ;CS
   1796	    0050  00000000				 DD	 0			   ;SS
   1797	    0054  00000000				 DD	 0			   ;DS
   1798	    0058  00000000				 DD	 0			   ;FS
   1799	    005C  00000000				 DD	 0			   ;GS
   1800	    0060  00000028				 DD	 DemoLDT_Sel		   ;LDT
   1801	    0064  0000					 DW	 0
   1802	    0066  0068r					 DW	 $+2
   1803	    0068  FFFF					 DW	 0ffffh
   1804					 ;----------------------------------------------------------------------------
   1805		  = DEMOTSSSEG:006A	 DemoTSSLen	 =	 $
   1806					 ;----------------------------------------------------------------------------
   1807	    006A			 DemoTSSSeg	 ENDS
   1808					 ;----------------------------------------------------------------------------
   1809
   1810					 ;***************************************************************************
   1811					 ; DemoStack0Seg Segment
   1812					 ;  32 bit segment
   1813					 ;***************************************************************************
   1814	00000000			 DemoStack0Seg	 SEGMENT DWORD STACK USE32
   1815		  = 0200		 DemoStack0Len	 =	 512
   1816	00000000  0200*(??)				 DB	 DemoStack0Len DUP(?)
   1817	00000200			 DemoStack0Seg	 ENDS
   1818					 ;--------------------------------------------------------------------------
   1819					 ;***************************************************************************
   1820					 ; DemoStack1Seg Segment
   1821					 ;  32 bit segment
   1822					 ;***************************************************************************
   1823	00000000			 DemoStack1Seg	 SEGMENT DWORD STACK USE32
   1824		  = 01F6		 DemoStack1Len	 =	 502
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 33
prcycle.ASM



   1825	00000000  54				 DB	 'T'
   1826	00000001  44				 DB	 'D'
   1827	00000002  4F				 DB	 'O'
   1828	00000003  53				 DB	 'S'
   1829	00000004  43				 DB	 'C'
   1830	00000005  32				 DB	 '2'
   1831	00000006  30				 DB	 '0'
   1832	00000007  30				 DB	 '0'
   1833	00000008  38				 DB	 '8'
   1834	00000009  54				 DB	 'T'
   1835	0000000A  01F6*(4B)				 DB	 DemoStack1Len DUP('K')
   1836	00000200			 DemoStack1Seg	 ENDS
   1837
   1838					 ;-------------------------------------------------------------------------
   1839					 ;***************************************************************************
   1840					 ; DemoStack3Seg Segment
   1841					 ;  16 bit segment
   1842					 ;***************************************************************************
   1843	    0000			 DemoStack3Seg	 SEGMENT PARA USE16
   1844		  = 0200		 DemoStack3Len	 =	 512
   1845	    0000  0200*(00)				 DB	 DemoStack3Len DUP(0)
   1846					 ;-------------------------------------------------------------------------
   1847	    0200			 DemoStack3Seg	 ENDS
   1848					 ;-------------------------------------------------------------------------
   1849					 ;***************************************************************************
   1850					 ; GetCharStackSeg Segment
   1851					 ;  16 bit segment
   1852					 ;***************************************************************************
   1853	    0000			 GetCharStackSeg   SEGMENT PARA	USE16
   1854		  = 0200		 GetCharStackLen   =	   512
   1855	    0000  0200*(00)				 DB	 GetCharStackLen DUP(0)
   1856					 ;-------------------------------------------------------------------------
   1857	    0200			 GetCharStackSeg   ENDS
   1858					 ;-------------------------------------------------------------------------
   1859					 ;***************************************************************************
   1860					 ; SearchStackSeg Segment
   1861					 ;  16 bit segment
   1862					 ;***************************************************************************
   1863	    0000			 SearchStackSeg	  SEGMENT PARA USE16
   1864		  = 0200		 SearchStackLen	  =	  512
   1865	    0000  0200*(00)				 DB	 SearchStackLen	DUP(0)
   1866					 ;-------------------------------------------------------------------------
   1867	    0200			 SearchStackSeg	  ENDS
   1868					 ;-------------------------------------------------------------------------
   1869					 ;***************************************************************************
   1870					 ;***************************************************************************
   1871					 ; GetDecStackSeg Segment
   1872					 ;  16 bit segment
   1873					 ;***************************************************************************
   1874	    0000			 GetDecStackSeg	  SEGMENT PARA USE16
   1875		  = 0200		 GetDecStackLen	  =	  512
   1876	    0000  0200*(00)				 DB	 GetDecStackLen	DUP(0)
   1877					 ;-------------------------------------------------------------------------
   1878	    0200			 GetDecStackSeg	  ENDS
   1879					 ;***************************************************************************
   1880					 ; GetSecStackSeg Segment
   1881					 ;  16 bit segment
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 34
prcycle.ASM



   1882					 ;***************************************************************************
   1883	    0000			 GetSecStackSeg	  SEGMENT PARA USE16
   1884		  = 0200		 GetSecStackLen	  =	  512
   1885	    0000  0200*(00)				 DB	 GetSecStackLen	DUP(0)
   1886					 ;-------------------------------------------------------------------------
   1887	    0200			 GetSecStackSeg	  ENDS
   1888					 ;***************************************************************************
   1889					 ; WriteSecStackSeg Segment
   1890					 ;  16 bit segment
   1891					 ;***************************************************************************
   1892	    0000			 WriteSecStackSeg   SEGMENT PARA USE16
   1893		  = 0200		 WriteSecStackLen   =	    512
   1894	    0000  0200*(00)				 DB	 WriteSecStackLen DUP(0)
   1895					 ;-------------------------------------------------------------------------
   1896	    0200			 WriteSecStackSeg   ENDS
   1897					 ;-------------------------------------------------------------------------
   1898					 ;***************************************************************************
   1899					 ; App1StackSeg	Segment
   1900					 ;  32 bit segment
   1901					 ;***************************************************************************
   1902	00000000			 App1StackSeg	SEGMENT	DWORD STACK USE32
   1903		  = 0200		 App1StackLen	=	512
   1904	00000000  0200*(??)				 DB	 App1StackLen DUP(?)
   1905	00000200			 App1StackSeg	ENDS
   1906					 ;-------------------------------------------------------------------------
   1907					 ;***************************************************************************
   1908					 ; ProtModeProcDataSeg Segment
   1909					 ; All the protected mode data will go into this segment.
   1910					 ;  32 bit segment
   1911					 ;***************************************************************************
   1912	00000000			 ProtModeProcDataSeg	    SEGMENT public PARA	USE32
   1913
   1914	00000000  30 31	32 33 34 35 36+	 HexTableP	  DB	  '0123456789ABCDEF'
   1915		  37 38	39 41 42 43 44+
   1916		  45 46
   1917	00000010  ????????		 IndexCntP	  DD	  ?
   1918	00000014  ????????		 PrintDataP	  DD	  ?
   1919
   1920		  =		      +	 ProtModeProcDataLen	 =	 $
   1921		  PROTMODEPROCDATASEG:0
   1922		  018
   1923
   1924	00000018			 ProtModeProcDataSeg	    ENDS
   1925					 ;--------------------------------------------------------------------------
   1926					 ;***************************************************************************
   1927					 ; GlobalDataSeg Segment
   1928					 ; All the Global data will be stored in this segment.
   1929					 ;  32 bit segment
   1930					 ;***************************************************************************
   1931	    0000			 GlobalDataSeg	      SEGMENT public PARA USE16	'GlobalData'
   1932
   1933	    0000  50 51	52 53 54 55 56+	 Dummydata	 DB	 'PQRSTUVWXYZ'
   1934		  57 58	59 5A
   1935
   1936	    000B  ??			 StoreChar		 DB	 ?
   1937	    000C  ????????		 StoreDec		 DD	 ?
   1938	    0010  0100*(00)		 SearchKey		 DB	 256 dup(0)
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 35
prcycle.ASM



   1939	    0110  0000			 SearchLen		 dw	 0
   1940
   1941		  = GLOBALDATASEG:0112	 GlobalDataLen	   =	   $
   1942
   1943	    0112			 GlobalDataSeg	      ENDS
   1944
   1945					 ;**************************************************************************
   1946					 ;sample test code for otherbegin code to place	it in C++
   1947					 ;  this code never gets invoked as it will be over ridden by IDT and GDT entries
   1948					 ;**************************************************************************
   1949	00000000			 IntExceptionSeg    SEGMENT PARA USE32
   1950	00000000			 IntException		 PROC FAR
   1951
   1952	00000000  CF					 iretd
   1953	00000001			 IntException ENDP
   1954		  =		      +	 IntExceptionCodeLen	 =  $
   1955		  INTEXCEPTIONSEG:0001
   1956					 ;----------------------------------------------------------------------------
   1957	00000001			 IntExceptionSeg ENDS
   1958
   1959					 ;**************************************************************************
   1960					 ;Sample Test Code Segment
   1961					 ; When	C++ application	ethernet receive ISR is	not setup, this	ISR will
   1962					 ;  run
   1963					 ;--------------------------------------------------------------------------
   1964	00000000			 EthernetReceive    SEGMENT PARA USE32
   1965							 ;ASSUME  CS:EthernetReceive;,ds:ProtModeProcDataSeg;
   1966	00000000			 test2 PROC FAR
   1967	00000000  FA					 cli
   1968	00000001  50					 push	 eax
   1969	00000002  53					 push	 ebx
   1970	00000003  52					 push	 edx
   1971	00000004  0F A0					 push	 fs
   1972
   1973	00000006  66| B8 00C0				 mov	 ax, MEMData_Sel ; zero	base in	protected mode
   1974	0000000A  8E E0					 mov	 fs, ax
   1975	0000000C  BB 00008600				 mov	 ebx,S_Base	 ;base of shared memory	between	aoa and	application
   1976	00000011  83 C3	00				 add	 ebx,S_Timer		 ;index	of timer in shared memory
   1977	00000014  64: 8B 03				 mov	 eax, fs:[ebx]
   1978	00000017  64: 89 03				 mov	 fs:[ebx], eax
   1979	0000001A  BB 00000294				 mov	 ebx, 660
   1980	0000001F  CD FD					 int	 0fdh
   1981
   1982	00000021  66| B8 0049				 mov	 ax, 'I'
   1983	00000025  BB 00000280				 mov	 ebx, 640
   1984	0000002A  CD F7					 int	 0f7h
   1985
   1986							 ;-----------------------------------------
   1987							 ;print	the status of ethernet card
   1988	0000002C  66| B8 0300				 mov	 ax, 300h
   1989	00000030  66| 8B D0				 mov	 dx, ax
   1990	00000033  66| 83 C2 0E				 add	 dx, 0Eh
   1991	00000037  66| ED				 in	 ax, dx
   1992	00000039  BB 00000320				 mov	 ebx, 800
   1993	0000003E  CD FD					 int	 0fdh
   1994							 ;-----------------------------------
   1995							 ; discard the packet in the ethernet buffer
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 36
prcycle.ASM



   1996
   1997	00000040  33 D2					 xor	 edx, edx
   1998	00000042  33 C0					 xor	 eax, eax
   1999	00000044  66| B8 0300				 mov	 ax, 300h
   2000	00000048  66| 8B D0				 mov	 dx, ax	; dx:IO_BASE
   2001	0000004B  66| 83 C2 0E				 add	 dx, 0Eh
   2002	0000004F  66| B8 0801				 mov	 ax, 800h+1h
   2003	00000053  66| EF				 out	 dx, ax
   2004	00000055			 Wait_Command_End2:
   2005	00000055  66| ED				 in	 ax, dx
   2006	00000057  66| 25 1000				 and	 ax, 1000h
   2007							 ;jnz	  Wait_Command_End2
   2008							 ;print	the status of ethernet card
   2009
   2010	0000005B  66| B8 0300				 mov	 ax, 300h
   2011	0000005F  66| 8B D0				 mov	 dx, ax
   2012	00000062  66| 83 C2 0E				 add	 dx, 0Eh
   2013	00000066  66| ED				 in	 ax, dx
   2014	00000068  BB 00000334				 mov	 ebx, 820
   2015	0000006D  CD FD					 int	 0fdh
   2016
   2017							 ;Discard Data header.
   2018	0000006F  66| B8 4000				 mov	 ax, 4000h
   2019	00000073  66| EF				 out	 dx, ax
   2020	00000075			 Wait_Command_End1:
   2021	00000075  66| ED				 in	 ax, dx
   2022	00000077  66| 25 1000				 and	 ax, 1000h
   2023							 ;jnz	  Wait_Command_End1
   2024
   2025							 ;print	the status of ethernet card
   2026	0000007B  66| B8 0300				 mov	 ax, 300h
   2027	0000007F  66| 8B D0				 mov	 dx, ax
   2028	00000082  66| 83 C2 0E				 add	 dx, 0Eh
   2029	00000086  66| ED				 in	 ax, dx
   2030	00000088  BB 00000348				 mov	 ebx, 840
   2031	0000008D  CD FD					 int	 0fdh
   2032	0000008F  66| B8 004A				 mov	 ax, 'J'
   2033	00000093  BB 00000280				 mov	 ebx, 640
   2034	00000098  CD F7					 int	 0f7h
   2035							 ;-----------------------------------
   2036							 ; Acknowledge the interrupt with the ethernet card
   2037	0000009A  66| BA 0300				 mov	 dx, 300h
   2038	0000009E  66| 83 C2 0E				 add	 dx, 0eh
   2039	000000A2  66| B8 6811				 mov	 ax, 6811h
   2040	000000A6  66| EF				 out	 dx, ax
   2041	000000A8			 Wait_Command_End:
   2042	000000A8  66| ED				 in	 ax, dx
   2043	000000AA  66| 25 1000				 and	 ax, 1000h
   2044							 ;jnz	  Wait_Command_End
   2045	000000AE  66| ED				 in	 ax, dx
   2046	000000B0  BB 0000035C				 mov	 ebx, 860
   2047	000000B5  CD FD					 int	 0fdh
   2048
   2049	000000B7  66| B8 004B				 mov	 ax, 'K'
   2050	000000BB  BB 00000280				 mov	 ebx, 640
   2051	000000C0  CD F7					 int	 0f7h
   2052							 ;-----------------------------------------------------
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 37
prcycle.ASM



   2053							 ; Acknowledge the interrupt in	the PCI	2
   2054	000000C2  66| BA 00A0				 mov	 dx, 0A0h
   2055	000000C6  B0 20					 mov	 al, 20h
   2056	000000C8  EE					 out	 dx, al
   2057							 ;--------------------------------------------------------
   2058							 ; Acknowledge the interrupt in	the PCI	1
   2059							 ; this	is because the interupt	int PCI	2 is through PCI 1
   2060	000000C9  66| BA 0020				 mov	 dx, 20h
   2061	000000CD  B0 20					 mov	 al, 20h
   2062	000000CF  EE					 out	 dx, al
   2063							 ;--------------------------------------------------------
   2064							 ; Disable the Ethernet	Card Interrupt
   2065							 ;mov	 dx, 0A1h
   2066							 ;in	 al, dx
   2067							 ;or	 al, 80h
   2068							 ;out	 dx, al
   2069
   2070							 ;--------------------------------------------------------
   2071							 ; Disable the Ethernet	Card Interrupt
   2072							 ;mov	 dx, 0A1h
   2073							 ;in	 al, dx
   2074							 ;and	 al, 7Fh
   2075							 ;out	 dx, al
   2076
   2077	000000D0  66| B8 004C				 mov	 ax, 'L'
   2078	000000D4  BB 00000280				 mov	 ebx, 640
   2079	000000D9  CD F7					 int	 0f7h
   2080
   2081	000000DB  0F A1					 pop	 fs
   2082	000000DD  5A					 pop	 edx
   2083	000000DE  5B					 pop	 ebx
   2084	000000DF  58					 pop	 eax
   2085	000000E0  FB					 sti
   2086	000000E1  CF					 iretd
   2087	000000E2			 test2 ENDP
   2088
   2089		  =		      +	 EthernetReceiveCodeLen	    =  $
   2090		  ETHERNETRECEIVE:00E2
   2091					 ;----------------------------------------------------------------------------
   2092	000000E2			 EthernetReceive ENDS
   2093
   2094					 ;**************************************************************************
   2095					 ;DemoCodeSeg Segment
   2096					 ;  32 bit segment
   2097					 ;  In ProtectedMode all the segments are 32bit
   2098					 ;**************************************************************************
   2099	00000000			 DemoCodeSeg	 SEGMENT PARA USE32
   2100							 ASSUME	 CS:DemoCodeSeg,ds:ProtModeProcDataSeg;, es:RDataSeg
   2101					 ;-------------------------------------------------------------------------
   2102					 ; Do not use 16 bit ds	in democodeseg
   2103					 ;***************************************************************************
   2104					 ; DemoBegin Procedure
   2105					 ;  invoked from T32Begin using	a call gate
   2106					 ;  III.
   2107					 ;***************************************************************************
   2108	00000000			 DemoBegin	 PROC	 FAR
   2109
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 38
prcycle.ASM



   2110							 CALL32	 ToT32B_Sel,0  ; IV.
1  2111	00000000  9A					 DB	 9ah
1  2112	00000001  0000					 DW	 0
1  2113	00000003  0000					 DW	 0
1  2114	00000005  006C					 DW	 ToT32B_Sel
   2115							 ; using a call	gate it	will go	to T32End
   2116							 ; 32 bit to 32	bit gate and call
   2117	00000007			 DemoBegin	 ENDP
   2118					 ;-------------------------------------------------------------------------
   2119					 ;***************************************************************************
   2120					 ; T32Begin Procedure
   2121					 ;  called from	a call gate 16 bit to 32 bit segment transfer
   2122					 ;***************************************************************************
   2123	00000007			 T32Begin	 PROC	 FAR
   2124					 ;-----------------------------------------
   2125	00000007  B0 50					 mov	 al,'P'
   2126	00000009  BB 00000F9E				 mov	 ebx,3998
   2127	0000000E  CD F7					 int	 0f7h
   2128
   2129
   2130					 ;------------------------------------------------
   2131	00000010			 Skip:
   2132					 ;-----------------------------------------
   2133	00000010  66| B8 0004				 mov	 ax,DemoStack0_Sel
   2134	00000014  8E D0					 mov	 ss,ax
   2135	00000016  BC 00000200				 mov	 esp,DemoStack0Len
   2136	0000001B  6A 17					 push	 DWORD PTR DemoStack3_Sel
   2137	0000001D  68 00000200				 push	 DemoStack3Len
   2138	00000022  6A 1F					 push	 DWORD PTR DemoCode_Sel
   2139	00000024  68 00000000r				 push	 OFFSET	DemoBegin
   2140					 ;-------------------------------------------
   2141					 ; III.
   2142					 ; 32 bit to 32	bit transfer using stack
   2143					 ; destination address selector	and offset is
   2144					 ; pushed onto stack and using return it will
   2145					 ; pop the stack to jump to DemoBegin location
   2146					 ;-------------------------------------------
   2147	00000029  CB					 retf
   2148	0000002A			 T32Begin	 ENDP
   2149					 ;--------------------------------------------------------------------------
   2150					 ;***************************************************************************
   2151					 ; T32End Procedure
   2152					 ; IV.
   2153					 ;  invoked from DemoBegin using a call	gate
   2154					 ;***************************************************************************
   2155	0000002A			 T32End		 PROC	 FAR
   2156					 ;--------------------------------------------------------
   2157							 JUMP32	 TempCode_Sel,<OFFSET ToReal> ;	V.
1  2158	0000002A  EA					 DB	 0eah
1  2159	0000002B  01FCr					 DW	 OFFSET	ToReal
1  2160	0000002D  0000					 DW	 0
1  2161	0000002F  0030					 DW	 TempCode_Sel
   2162					 ;--------------------------------------------------------
   2163							 ; using a descriptor now it will go back
   2164							 ; to 16 bit protected mode label ToReal
   2165							 ; and it is on	its way	to real	mode
   2166							 ; this	will be	a 32 bit segment to 16 bit
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 39
prcycle.ASM



   2167							 ; segment transfer using a descriptor
   2168	00000031			 T32End		 ENDP
   2169					 ;***************************************************************************
   2170					 ; PUTHEX32P Procedure
   2171					 ;***************************************************************************
   2172					 ;This procedure prints	the value in EAX in hex-format in PMode.
   2173					 ;Usage	in PMode: load eax with	a value, load ebx with the position of the screen
   2174					 ;and call this	procedure 'CALL32  ProtModeProcGate1_Sel,0'
   2175					 ; This	procedure automatically	increments ebx value to	the next location
   2176					 ;---------------------------------------------------------------------------
   2177	00000031			 PUTHEX32P	 PROC	 FAR
   2178	00000031  51				 PUSH	 ECX
   2179	00000032  57				 PUSH	 EDI
   2180	00000033  1E				 PUSH	 DS
   2181	00000034  50				 push	 eax
   2182
   2183	00000035  53				 push	 ebx
   2184	00000036  50				 push	 eax
   2185
   2186	00000037  66| B8 0090			 mov	 ax,Puthex32Data_Sel
   2187	0000003B  8E D8				 mov	 ds,ax
   2188
   2189	0000003D  58				 pop	 eax
   2190	0000003E  5B				 pop	 ebx
   2191
   2192	0000003F  A3 00000014r			 MOV	 PrintDataP, eax	 ; save	data in	memory
   2193	00000044  B9 00000008			 MOV	 ecx, 8			 ; eight characters
   2194	00000049			 PutHexLoopP:
   2195	00000049  A1 00000014r			 MOV	 eax, PrintDataP	 ; data	in eax
   2196	0000004E  25 F0000000			 AND	 eax, 0F0000000h	 ; select first	nibble
   2197	00000053  C1 C0	04			 ROL	 eax,4			 ; get the count on right
   2198	00000056  A3 00000010r			 MOV	 IndexCntP, eax		 ; store the index
   2199	0000005B  8B 3D	00000010r		 MOV	 edi, IndexCntP
   2200	00000061  8A 87	00000000r		 MOV	 al, BYTE PTR HexTableP[edi]  ;	get hex	character
   2201
   2202	00000067  83 C3	02			 add	 ebx,2			 ; Next	character
   2203	0000006A  CD F7				 int	 0f7h
   2204
   2205	0000006C  A1 00000014r			 MOV	 eax, PrintDataP	 ; get the stored data
   2206	00000071  C1 E0	04			 SHL	 eax, 4			 ; shift to next nibble
   2207	00000074  A3 00000014r			 MOV	 PrintDataP, eax	 ; store remaining data
   2208	00000079  E2 CE				 LOOP	 PutHexLoopP		 ; print all 8 hex characters
   2209
   2210	0000007B  58				 pop	 eax
   2211	0000007C  1F				 POP	 DS
   2212	0000007D  5F				 POP	 EDI
   2213	0000007E  59				 POP	 ECX
   2214					 ;---------------------------------------------------------------------------------
   2215					 ;changed this code on 7-7-2004
   2216	0000007F  52				 push	 edx
   2217	00000080  9C				 pushfd	; turn off NT flag in the CPU not in the TSS
   2218						 ; so that CPU will return to its application during IRETD not to
   2219						 ;  exit from the task using link field	in the TSS
   2220	00000081  5A				 pop	 edx
   2221	00000082  81 E2	FFFFBFFF		 AND	 edx, 0FFFFBFFFh
   2222	00000088  52				 push	 edx
   2223	00000089  9D				 popfd
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 40
prcycle.ASM



   2224	0000008A  5A				 pop	 edx
   2225					 ;--------------------------------------------------------------------------------
   2226	0000008B  CF				 IRETD
   2227	0000008C			 PUTHEX32P	 ENDP
   2228					 ;***************************************************************************
   2229					 ; TEST	Procedure
   2230					 ;***************************************************************************
   2231					 ;This procedure prints	the value in EAX in hex-format in PMode.
   2232					 ;Usage	in PMode: load eax with	a value, load ebx with the position of the screen
   2233					 ;and call this	procedure 'CALL32  ProtModeProcGate1_Sel,0'
   2234					 ;---------------------------------------------------------------------------
   2235	0000008C			 APPSCHEDULE	 PROC	 FAR
   2236	0000008C  50				 push	 eax
   2237	0000008D  53				 push	 ebx
   2238	0000008E  B0 41				 mov	 al,'A'
   2239	00000090  BB 000005DC			 mov	 ebx,1500
   2240	00000095  CD F7				 int	 0f7h
   2241	00000097  5B				 pop	 ebx
   2242	00000098  58				 pop	 eax
   2243
   2244	00000099			 APPSCHEDULE	 ENDP
   2245
   2246					 ;***************************************************************************
   2247					 ;This Procedure prints	the memory in hex-format in Protected mode
   2248					 ;place	the memory location in EAX and position	to display in EBX and call.
   2249					 ;***************************************************************************
   2250	00000099			 PRINTMEMP	 PROC	 FAR
   2251
   2252	00000099  51				 PUSH	 ECX
   2253	0000009A  56				 PUSH	 ESI
   2254	0000009B  57				 PUSH	 EDI
   2255	0000009C  1E				 PUSH	 DS
   2256	0000009D  0F A0				 push	 fs
   2257
   2258	0000009F  50				 push	 eax
   2259	000000A0  66| B8 0034			 mov	 ax,ProtModeProcData_Sel
   2260	000000A4  8E D8				 mov	 ds,ax
   2261	000000A6  58				 pop	 eax
   2262
   2263	000000A7  50				 push	 eax
   2264	000000A8  66| B8 003C			 mov	 ax,PrintMemProcData_Sel
   2265	000000AC  8E E0				 mov	 fs,ax
   2266	000000AE  58				 pop	 eax
   2267
   2268	000000AF  BB 00000320			 mov	 ebx,800		  ; use	CursorPos = 2 or 800 to	start
   2269	000000B4  8B F8				 mov	 edi,eax		  ;
   2270	000000B6  B9 00000080			 mov	 ecx,128
   2271
   2272	000000BB				 memloop:
   2273	000000BB  64: 8B 07			 mov	 eax,fs:[edi]
   2274	000000BE  CD FD				 int	 0fdh
   2275
   2276	000000C0  83 C3	04			 add	 ebx,4
   2277	000000C3  83 C7	04			 add	 edi,4
   2278	000000C6  E2 F3				 loop	 memloop
   2279
   2280	000000C8  0F A1				 pop	 fs
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 41
prcycle.ASM



   2281	000000CA  1F				 POP	 DS
   2282	000000CB  5F				 POP	 EDI
   2283	000000CC  5E				 POP	 ESI
   2284	000000CD  59				 POP	 ECX
   2285	000000CE  CB				 RETF
   2286
   2287	000000CF			 PRINTMEMP	 ENDP
   2288					 ;***************************************************************************
   2289					 ; Print Stack Procedure
   2290					 ;  When printing stack, make sure you do not exceed the limit of the stack
   2291					 ;  ex.	when you print DemoStack0 then the limit is DemoStack0Len
   2292					 ; eax must have number	of bytes to print
   2293					 ; ebx must have the starting point of display to print
   2294					 ; esp is used as current stack	pointer
   2295					 ; ss  is used as current stack	segment
   2296					 ; the printing	is done	from current esp to the	top of the stack
   2297					 ; user	must make sure that you	are not	exceeding the limits of	the stack
   2298					 ;-------------------------------
   2299					 ;    |		  |
   2300					 ;    |-----------|  SS	 Limit
   2301					 ;    |	contents  |
   2302					 ;    |		  |
   2303					 ;    |		  |
   2304					 ;    |-----------| <--- ESP
   2305					 ;    |	EMPTY	  |
   2306					 ;    |		  |
   2307					 ;    ------------- 0
   2308					 ;    Stack Growing Downward
   2309					 ; -----------------------------
   2310					 ;   push ebp  do not disturb ebp in a call
   2311					 ;   mov ebp, esp
   2312					 ;   you must not disturb ESP in a call
   2313					 ;     if you are using	the stack
   2314					 ;   you must save and restore ESP in a	call
   2315					 ;   pop ebp   resore ebp when you return
   2316					 ;------------------------------
   2317					 ;***************************************************************************
   2318	000000CF			 PRINTSTP PROC FAR
   2319
   2320	000000CF  55				 push	 ebp	    ; save bp
   2321	000000D0  8B EC				 mov	 ebp,esp
   2322
   2323	000000D2  56				 push	 esi
   2324	000000D3  51				 push	 ecx
   2325	000000D4  57				 push	 edi
   2326	000000D5  52				 push	 edx
   2327					 ;-----------------------------------------------------------
   2328					 ; set DS for accessing	protected mode data for	PUTHEX32P rtn
   2329					 ;-----------------------------------------------------------
   2330	000000D6  1E				 push	 ds
   2331
   2332	000000D7  50				 push	 eax	  ; save eax on	stack
   2333	000000D8  66| B8 0034			 mov	 ax,ProtModeProcData_Sel
   2334	000000DC  8E D8				 mov	 ds,ax
   2335	000000DE  58				 pop	 eax	  ; restore eax	value passed
   2336					 ; starting point of printing on display at ebx
   2337	000000DF  8B F8				 mov	 edi,eax  ; no of stack	entries	or bytes to print
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 42
prcycle.ASM



   2338	000000E1  BA 00000010			 mov	 edx, 16  ; next line counter
   2339
   2340	000000E6  BE 00000000			 mov	 esi, 0	  ; starting point of print
   2341	000000EB			 LOOPSTACK1:
   2342	000000EB  8B 44	35 00			 mov	 eax,ss:[ebp+esi]
   2343
   2344	000000EF  50				 push	 eax
   2345	000000F0  53				 push	 ebx
   2346	000000F1  B8 00000000			 mov	 eax,0
   2347	000000F6  0F 00	C8			 str	 ax
   2348	000000F9  BB 00000460			 mov	 ebx,1120
   2349	000000FE  CD FD				 int	 0fdh
   2350	00000100  5B				 pop	 ebx
   2351	00000101  58				 pop	 eax
   2352
   2353						 CALL32	 Puthex32PGate_Sel, 0
1  2354	00000102  9A					 DB	 9ah
1  2355	00000103  0000					 DW	 0
1  2356	00000105  0000					 DW	 0
1  2357	00000107  0074					 DW	 Puthex32PGate_Sel
   2358
   2359	00000109  83 C3	02			 add	 ebx, 2
   2360
   2361	0000010C  83 EA	02			 sub	 edx, 2	 ; line	counter
   2362	0000010F  83 FA	00			 cmp	 edx, 0	 ; ready to go to next line
   2363	00000112  75 08				 JNZ	 NONEWLINEP
   2364	00000114  83 C3	10			 add	 ebx, 16 ; next	line pointer
   2365	00000117  BA 00000010			 mov	 edx, 16
   2366	0000011C			     NONEWLINEP:
   2367	0000011C  83 C6	04			 add	 esi,4
   2368	0000011F  3B FE				 cmp	 edi,esi
   2369	00000121  75 C8				 JNZ	 LOOPSTACK1
   2370
   2371	00000123  1F				 pop	 ds
   2372	00000124  5A				 pop	 edx
   2373	00000125  5F				 pop	 edi
   2374	00000126  59				 pop	 ecx
   2375	00000127  5E				 pop	 esi
   2376	00000128  5D				 pop	 ebp	     ; restore reg values
   2377
   2378	00000129  CB				 RETF
   2379
   2380	0000012A			 PRINTSTP ENDP		     ; end of procedure
   2381					 ;***************************************************************************
   2382					 ; This	proc copies the	data from 0000:[8400] to above 1 meg memmory
   2383					 ; staring from	the address given in the descriptor StartAddress_Sel
   2384					 ; and gets the	offset from BxPointer1.
   2385					 ; Dont	use ds to get the BxPointer1 as	BxPointer1 is in 16 bit	Dataseg
   2386					 ; because the default dataseg for this	code segment is	a 32 bit dataseg
   2387					 ; because of the ASSUME directive
   2388					 ; when	user input the offset value for	the program to be loaded
   2389					 ;  it is stored in LoadOffset1	and then it is transferred to BxPointer1
   2390					 ; then	BxPointer1 is used to store each sector	in the memory
   2391					 ; LoadOffset1 contains	the 32 bit offset entered by the user for app1
   2392					 ;***************************************************************************
   2393
   2394	0000012A			 RDWTMEM	 PROC	 FAR
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 43
prcycle.ASM



   2395
   2396	0000012A  66| B8 0054				 mov	 ax,RealData_Sel
   2397	0000012E  8E E8					 mov	 gs,ax		 ;real data segment
   2398
   2399							 ; offset is stored at BxPointer1 in memory prload.asm
   2400	00000130  65: 67| A1 0000e			 mov	 eax,gs:[BxPointer1]
   2401	00000135  BB 00000F76				 mov	 ebx,3958	 ; print offset	at the bottom of screen
   2402	0000013A  CD FD					 int	 0fdh		 ;   puthex32 gate to print
   2403
   2404							 ;int 0f5h		 ; wait	for the	keyboard
   2405							 ; real	mode interrupts	do not work here
   2406
   2407	0000013C  66| B8 0044				 mov	 ax,StartAddress_Sel
   2408	00000140  8E E0					 mov	 fs,ax		 ; start addr above 1M
   2409
   2410	00000142  66| B8 004C				 mov	 ax,Buffer_Sel	 ; 8400	buffer location	select
   2411	00000146  8E C0					 mov	 es,ax
   2412
   2413	00000148  BE 00000000				 mov	 esi,0h		 ; pointer for buffer
   2414	0000014D  65: 67| 8B 3E	0000e			 mov	 edi,gs:[BxPointer1]
   2415	00000153  B9 00000080				 mov	 ecx,128	 ;one sector
   2416							 ; copy	all words in the sector	to above 1M
   2417	00000158			 ReadWrite1:
   2418	00000158  26: 8B 06				 mov	 eax,es:[esi]
   2419	0000015B  64: 89 07				 mov	 fs:[edi],eax
   2420
   2421	0000015E  83 C6	04				 add	 esi,4
   2422	00000161  83 C7	04				 add	 edi,4
   2423
   2424	00000164  E2 F2					 LOOP	 ReadWrite1
   2425
   2426	00000166  CB					 RETF
   2427
   2428	00000167			 RDWTMEM	 ENDP
   2429					 ;----------------------------------------------------------------------------
   2430					 ;***************************************************************************
   2431					 ;HTimerBegin Procedure
   2432					 ; Now it will just display it.
   2433					 ; Whenever a hardware timer 08h arrives, this procedure will be called	thu
   2434					 ;  the	interrupt gate
   2435					 ; we start our	timer value with 0 and increment the value in memory each
   2436					 ; time	the interrupt comes, i.e. every	55 milli seconds
   2437					 ;***************************************************************************
   2438	00000167			 HTimerBegin PROC FAR
   2439	00000167  FA					 cli
   2440	00000168  50					 push	 eax
   2441	00000169  53					 push	 ebx
   2442	0000016A  52					 push	 edx
   2443	0000016B  0F A0					 push	 fs
   2444
   2445	0000016D  B8 00000054				 mov	 eax, 'T'
   2446	00000172  BB 00000F9C				 mov	 ebx, 3996
   2447	00000177  CD F7					 int	 0f7h
   2448
   2449	00000179  66| B8 00C0				 mov	 ax, MEMData_Sel ; zero	base in	protected mode
   2450	0000017D  8E E0					 mov	 fs, ax
   2451	0000017F  BB 00008600				 mov	 ebx,S_Base	 ;base of shared memory	between	aoa and	application
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 44
prcycle.ASM



   2452	00000184  83 C3	00				 add	 ebx,S_Timer		 ;index	of timer in shared memory
   2453
   2454	00000187  64: 8B 03				 mov	 eax, fs:[ebx]
   2455	0000018A  40					 inc	 eax
   2456	0000018B  64: 89 03				 mov	 fs:[ebx], eax
   2457
   2458	0000018E  66| BA 0020				 mov	 dx, 20h
   2459	00000192  B0 20					 mov	 al, 20h
   2460	00000194  EE					 out	 dx, al
   2461	00000195  EB 00					 jmp	 $+2
   2462
   2463							 ;mov	 ax, 'H'
   2464							 ;mov	 ebx, 3990
   2465							 ;int	 0f7h
   2466
   2467	00000197  0F A1					 pop	 fs
   2468	00000199  5A					 pop	 edx
   2469	0000019A  5B					 pop	 ebx
   2470	0000019B  58					 pop	 eax
   2471							 ;-----------------------------------------------------------------
   2472							 ;changed this code on 7-7-2004
   2473	0000019C  52					 push	 edx  ;save edx	on the stack
   2474	0000019D  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2475							 ; so that CPU will return to its application during IRETD not to
   2476							 ;  exit from the task using link field	in the TSS
   2477	0000019E  5A					 pop	 edx ; get the flags into edx
   2478	0000019F  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh ; reset NT flag
   2479	000001A5  52					 push	 edx		 ; store in the	stack
   2480	000001A6  9D					 popfd			 ; get the flags into flag register
   2481	000001A7  5A					 pop	 edx ; restore edx
   2482							 ;-----------------------------------------------------------------
   2483	000001A8  FB					 sti
   2484
   2485	000001A9  CF					 iretd
   2486	000001AA			 HTimerBegin ENDP
   2487
   2488
   2489	000001AA			 test1 PROC FAR
   2490	000001AA  FA					 cli
   2491	000001AB  50					 push	 eax
   2492	000001AC  53					 push	 ebx
   2493	000001AD  52					 push	 edx
   2494	000001AE  0F A0					 push	 fs
   2495
   2496							 ;mov	 eax, 'T'
   2497							 ;mov	 ebx, 800
   2498							 ;int	 0f7h
   2499
   2500	000001B0  66| B8 00C0				 mov	 ax, MEMData_Sel ; zero	base in	protected mode
   2501	000001B4  8E E0					 mov	 fs, ax
   2502	000001B6  BB 00008600				 mov	 ebx,S_Base	 ;base of shared memory	between	aoa and	application
   2503	000001BB  83 C3	00				 add	 ebx,S_Timer		 ;index	of timer in shared memory
   2504
   2505	000001BE  64: 8B 03				 mov	 eax, fs:[ebx]
   2506							 ;inc	 eax
   2507	000001C1  64: 89 03				 mov	 fs:[ebx], eax
   2508
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 45
prcycle.ASM



   2509	000001C4  BB 00000294				 mov	 ebx, 660
   2510	000001C9  CD FD					 int	 0fdh
   2511
   2512	000001CB  66| BA 0020				 mov	 dx, 20h
   2513	000001CF  B0 20					 mov	 al, 20h
   2514	000001D1  EE					 out	 dx, al	 ; read	timer interrupt
   2515	000001D2  EB 00					 jmp	 $+2
   2516
   2517	000001D4  66| B8 0049				 mov	 ax, 'I'
   2518	000001D8  BB 00000280				 mov	 ebx, 640
   2519	000001DD  CD F7					 int	 0f7h
   2520
   2521	000001DF  0F A1					 pop	 fs
   2522	000001E1  5A					 pop	 edx
   2523	000001E2  5B					 pop	 ebx
   2524	000001E3  58					 pop	 eax
   2525	000001E4  FB					 sti
   2526	000001E5  CF					 iretd
   2527	000001E6			 test1 ENDP
   2528
   2529
   2530
   2531
   2532
   2533					 ;-----------------------------------------------------------------
   2534					 ; get the current cursor postion
   2535					 ; return it in	ax
   2536	000001E6			 GetCursor	 proc far
   2537	000001E6  52					 push	 edx
   2538	000001E7  53					 push	 ebx
   2539
   2540	000001E8  33 C0					 xor	 eax, eax
   2541	000001EA  66| BA 03D4				 mov	 dx, 3d4h
   2542	000001EE  B0 0F					 mov	 al, 0fh
   2543	000001F0  EE					 out	 dx, al
   2544	000001F1  66| BA 03D5				 mov	 dx, 3d5h
   2545	000001F5  EC					 in	 al, dx
   2546	000001F6  8A D8					 mov	 bl, al
   2547
   2548	000001F8  66| BA 03D4				 mov	 dx, 3d4h
   2549	000001FC  B0 0E					 mov	 al, 0eh
   2550	000001FE  EE					 out	 dx, al
   2551	000001FF  66| BA 03D5				 mov	 dx, 3d5h
   2552	00000203  EC					 in	 al, dx
   2553	00000204  8A E0					 mov	 ah, al
   2554	00000206  8A C3					 mov	 al, bl
   2555
   2556	00000208  5B					 pop	 ebx
   2557	00000209  5A					 pop	 edx
   2558
   2559					 ;---------------------------------------------------------------------------------
   2560					 ;changed this code on 7-7-2004
   2561							 ;cli
   2562	0000020A  52					 push	 edx
   2563	0000020B  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2564							 ; so that CPU will return to its application during IRETD not to
   2565							 ;  exit from the task using link field	in the TSS
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 46
prcycle.ASM



   2566	0000020C  5A					 pop	 edx;
   2567	0000020D  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2568	00000213  52					 push	 edx
   2569	00000214  9D					 popfd
   2570	00000215  5A					 pop	 edx
   2571							 ;sti
   2572					 ;--------------------------------------------------------------------------------
   2573
   2574	00000216  CF					 iretd
   2575	00000217			 GetCursor	 endp
   2576
   2577					 ; set cursor postion
   2578					 ; ax hodes the	cursor value
   2579	00000217			 SetCursor	 proc far
   2580	00000217  50					 push	 eax
   2581	00000218  52					 push	 edx
   2582	00000219  53					 push	 ebx
   2583
   2584	0000021A  8B D8					 mov	 ebx, eax
   2585	0000021C  66| BA 03D4				 mov	 dx, 3d4h
   2586	00000220  B0 0F					 mov	 al, 0fh
   2587	00000222  EE					 out	 dx, al
   2588	00000223  66| BA 03D5				 mov	 dx, 3d5h
   2589	00000227  8A C3					 mov	 al, bl
   2590	00000229  EE					 out	 dx, al
   2591
   2592	0000022A  66| BA 03D4				 mov	 dx, 3d4h
   2593	0000022E  B0 0E					 mov	 al, 0eh
   2594	00000230  EE					 out	 dx, al
   2595	00000231  66| BA 03D5				 mov	 dx, 3d5h
   2596	00000235  8A C7					 mov	 al, bh
   2597	00000237  EE					 out	 dx, al
   2598
   2599	00000238  5B					 pop	 ebx
   2600	00000239  5A					 pop	 edx
   2601	0000023A  58					 pop	 eax
   2602					 ;---------------------------------------------------------------------------------
   2603					 ;changed this code on 7-7-2004
   2604							 ;cli
   2605	0000023B  52					 push	 edx
   2606	0000023C  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2607							 ; so that CPU will return to its application during IRETD not to
   2608							 ;  exit from the task using link field	in the TSS
   2609	0000023D  5A					 pop	 edx;
   2610	0000023E  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2611	00000244  52					 push	 edx
   2612	00000245  9D					 popfd
   2613	00000246  5A					 pop	 edx
   2614							 ;sti
   2615					 ;--------------------------------------------------------------------------------
   2616	00000247  CF					 iretd
   2617	00000248			 SetCursor	 endp
   2618
   2619					 ; scroll one line up
   2620	00000248			 scroll		 proc far
   2621	00000248  51					 push	 ecx
   2622	00000249  57					 push	 edi
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 47
prcycle.ASM



   2623	0000024A  56					 push	 esi
   2624	0000024B  06					 push	 es
   2625	0000024C  1E					 push	 ds
   2626
   2627	0000024D  66| B8 0010				 mov	 ax, Video_Sel
   2628	00000251  8E E0					 mov	 fs, ax
   2629
   2630	00000253  66| B9 0780				 mov	 cx, 1920
   2631	00000257  66| BB 0000				 mov	 bx, 0
   2632	0000025B			 Movenext:
   2633	0000025B  66| 64: 67| 8B 87   +			 mov	 ax, fs:[bx+160]
   2634		  00A0
   2635	00000262  66| 64: 67| 89 07			 mov	 fs:[bx], ax
   2636	00000267  66| 83 C3 02				 add	 bx, 2
   2637	0000026B  E2 EE					 loop	 Movenext
   2638
   2639	0000026D  66| B9 0050				 mov	 cx, 80
   2640	00000271  66| BB 0EFF				 mov	 bx, 3839
   2641	00000275  66| B8 0000				 mov	 ax, 0
   2642	00000279			 Clearnext:
   2643	00000279  66| 64: 67| 89 07			 mov	 fs:[bx], ax
   2644	0000027E  66| 83 C3 02				 add	 bx, 2
   2645	00000282  E2 F5					 loop	 Clearnext
   2646
   2647	00000284  66| B8 0780				 mov	 ax, 1920
   2648	00000288  CD F3					 int	 0f3h
   2649
   2650	0000028A  1F					 pop	 ds
   2651	0000028B  07					 pop	 es
   2652	0000028C  5E					 pop	 esi
   2653	0000028D  5F					 pop	 edi
   2654	0000028E  59					 pop	 ecx
   2655					 ;---------------------------------------------------------------------------------
   2656					 ;changed this code on 7-7-2004
   2657	0000028F  FA					 cli
   2658	00000290  52					 push	 edx
   2659	00000291  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2660							 ; so that CPU will return to its application during IRETD not to
   2661							 ;  exit from the task using link field	in the TSS
   2662	00000292  5A					 pop	 edx
   2663	00000293  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2664	00000299  52					 push	 edx
   2665	0000029A  9D					 popfd
   2666	0000029B  5A					 pop	 edx
   2667	0000029C  FB					 sti
   2668					 ;--------------------------------------------------------------------------------
   2669	0000029D  CF					 iretd
   2670	0000029E			 scroll		 endp
   2671
   2672					 ; clean screen
   2673	0000029E			 CLScreen	 PROC far
   2674	0000029E  53					 push	 ebx
   2675	0000029F  51					 push	 ecx
   2676	000002A0  50					 push	 eax
   2677	000002A1  0F A0					 push	 fs
   2678
   2679	000002A3  66| B9 07D0				 mov	 cx, 2000
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 48
prcycle.ASM



   2680	000002A7  66| B8 0010				 mov	 ax, Video_Sel
   2681	000002AB  8E E0					 mov	 fs,ax
   2682	000002AD  66| BB 0000				 mov	 bx, 0
   2683	000002B1  66| B8 0000				 mov	 ax,0
   2684	000002B5  66| 64: 67| 89 07		 next:	 mov	 Word ptr fs:[bx], ax
   2685	000002BA  66| 83 C3 02				 add	 bx,2
   2686	000002BE  E2 F5					 loop	 next
   2687
   2688	000002C0  0F A1					 pop	 fs
   2689	000002C2  58					 pop	 eax
   2690	000002C3  59					 pop	 ecx
   2691	000002C4  5B					 pop	 ebx
   2692					 ;---------------------------------------------------------------------------------
   2693					 ;changed this code on 7-7-2004
   2694	000002C5  FA					 cli
   2695	000002C6  52					 push	 edx
   2696	000002C7  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2697							 ; so that CPU will return to its application during IRETD not to
   2698							 ;  exit from the task using link field	in the TSS
   2699	000002C8  5A					 pop	 edx
   2700	000002C9  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2701	000002CF  52					 push	 edx
   2702	000002D0  9D					 popfd
   2703	000002D1  5A					 pop	 edx
   2704	000002D2  FB					 sti
   2705					 ;--------------------------------------------------------------------------------
   2706
   2707	000002D3  CF					 iretd
   2708	000002D4			 CLScreen	 ENDP
   2709
   2710					 ;------------------------------------------------------
   2711					 ; return a character in al
   2712					 ;------------------------------------------------------
   2713	000002D4			 Getchar32	 PROC FAR
   2714	000002D4  53					 push	 ebx
   2715	000002D5  51					 push	 ecx
   2716	000002D6  52					 push	 edx
   2717	000002D7  56					 push	 esi
   2718	000002D8  0F A0					 push	 fs
   2719
   2720	000002DA  66| B8 0018				 mov	 ax, RData_Sel
   2721	000002DE  8E E0					 mov	 fs, ax
   2722
   2723	000002E0  B8 00000308r				 mov	 eax, offset KKQ
   2724	000002E5  8B F0					 mov	 esi, eax
   2725
   2726	000002E7  33 C0					 xor	 eax, eax
   2727	000002E9  CD F2					 int	 0f2h
   2728	000002EB  66| 8B D0				 mov	 dx, ax
   2729	000002EE  66| 52				 push	 dx
   2730	000002F0  66| BB 0002				 mov	 bx, 2
   2731	000002F4  66| F7 E3				 mul	 bx
   2732	000002F7  66| 5A				 pop	 dx
   2733	000002F9  8B C8					 mov	 ecx, eax
   2734
   2735	000002FB			 WaitChar:
   2736	000002FB  64: 67| 8A 1E	0407r			 mov	 bl, fs:[KHead]
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 49
prcycle.ASM



   2737	00000301  64: 67| 8A 3E	0408r			 mov	 bh, fs:[KTail]
   2738	00000307  3A DF					 cmp	 bl, bh
   2739	00000309  74 F0					 je	 WaitChar
   2740
   2741	0000030B  33 DB					 xor	 ebx, ebx
   2742	0000030D  64: 67| 8A 1E	0408r			 mov	 bl, fs:[KTail]
   2743	00000313  03 F3					 add	 esi, ebx
   2744	00000315  64: 8A 06				 mov	 al, byte ptr fs:[esi]
   2745
   2746	00000318  80 FB	FE				 cmp	 bl, 254
   2747	0000031B  74 04					 jz	 RoundChar
   2748	0000031D  FE C3					 inc	 bl
   2749	0000031F  EB 02					 jmp	 UpdateChar
   2750	00000321			 RoundChar:
   2751	00000321  B3 00					 mov	 bl, 0
   2752	00000323			 UpdateChar:
   2753	00000323  64: 67| 88 1E	0408r			 mov	 fs:[KTail], bl
   2754
   2755	00000329  50					 push	 eax
   2756	0000032A  3C 0D					 cmp	 al, 13
   2757	0000032C  74 04					 jz	 NDisp
   2758	0000032E  8B D9					 mov	 ebx, ecx
   2759	00000330  CD F7					 int	 0f7h  ; echo the character
   2760	00000332			 NDisp:
   2761	00000332  66| 42				 inc	 dx
   2762	00000334  66| 81 FA 07D0			 cmp	 dx, 2000
   2763	00000339  7C 04					 jl	 CursorOK
   2764	0000033B  CD F0					 int	 0f0h
   2765	0000033D  EB 05					 jmp	 Charout
   2766	0000033F			 CursorOK:
   2767	0000033F  66| 8B C2				 mov	 ax, dx
   2768	00000342  CD F3					 int	 0f3h
   2769	00000344			 Charout:
   2770
   2771	00000344  58					 pop	 eax
   2772
   2773	00000345  0F A1					 pop	 fs
   2774	00000347  5E					 pop	 esi
   2775	00000348  5A					 pop	 edx
   2776	00000349  59					 pop	 ecx
   2777	0000034A  5B					 pop	 ebx
   2778
   2779					 ;---------------------------------------------------------------------------------
   2780					 ;changed this code on 7-7-2004
   2781							 ;cli
   2782	0000034B  52					 push	 edx
   2783	0000034C  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2784							 ; so that CPU will return to its application during IRETD not to
   2785							 ;  exit from the task using link field	in the TSS
   2786	0000034D  5A					 pop	 edx
   2787	0000034E  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2788	00000354  52					 push	 edx
   2789	00000355  9D					 popfd
   2790	00000356  5A					 pop	 edx
   2791							 ;sti
   2792					 ;--------------------------------------------------------------------------------
   2793	00000357  CF					 iretd
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 50
prcycle.ASM



   2794	00000358			 Getchar32	 ENDP
   2795					 ;-------------------------------------------------------------------------------------------
   2796					 --
   2797					 ; This	is there is a char in the Keybord buffer it will return	the char else it will return+
   2798					 -1
   2799
   2800	00000358			 Getchar32Buff	 PROC FAR
   2801							 ;cli
   2802	00000358  53					 push	 ebx
   2803	00000359  51					 push	 ecx
   2804	0000035A  52					 push	 edx
   2805	0000035B  56					 push	 esi
   2806	0000035C  0F A0					 push	 fs
   2807
   2808	0000035E  66| B8 0018				 mov	 ax, RData_Sel
   2809	00000362  8E E0					 mov	 fs, ax
   2810
   2811	00000364  B8 00000308r				 mov	 eax, offset KKQ
   2812	00000369  8B F0					 mov	 esi, eax
   2813
   2814	0000036B  33 C0					 xor	 eax, eax
   2815	0000036D  CD F2					 int	 0f2h
   2816	0000036F  66| 8B D0				 mov	 dx, ax
   2817	00000372  66| 52				 push	 dx
   2818	00000374  66| BB 0002				 mov	 bx, 2
   2819	00000378  66| F7 E3				 mul	 bx
   2820	0000037B  66| 5A				 pop	 dx
   2821	0000037D  8B C8					 mov	 ecx, eax
   2822
   2823	0000037F			 WaitChar1:
   2824	0000037F  64: 67| 8A 1E	0407r			 mov	 bl, fs:[KHead]
   2825	00000385  64: 67| 8A 3E	0408r			 mov	 bh, fs:[KTail]
   2826	0000038B  3A DF					 cmp	 bl, bh
   2827	0000038D  75 07					 jne	 getc
   2828	0000038F  66| B8 00FE				 mov	 ax,0FEh
   2829	00000393  50					 push	 eax
   2830	00000394  EB 39					 jmp	 Charout1
   2831
   2832	00000396  33 DB			 getc:		 xor	 ebx, ebx
   2833	00000398  64: 67| 8A 1E	0408r			 mov	 bl, fs:[KTail]
   2834	0000039E  03 F3					 add	 esi, ebx
   2835	000003A0  64: 8A 06				 mov	 al, byte ptr fs:[esi]
   2836
   2837	000003A3  80 FB	FE				 cmp	 bl, 254
   2838	000003A6  74 04					 jz	 RoundChar1
   2839	000003A8  FE C3					 inc	 bl
   2840	000003AA  EB 02					 jmp	 UpdateChar1
   2841	000003AC			 RoundChar1:
   2842	000003AC  B3 00					 mov	 bl, 0
   2843	000003AE			 UpdateChar1:
   2844	000003AE  64: 67| 88 1E	0408r			 mov	 fs:[KTail], bl
   2845
   2846	000003B4  50					 push	 eax
   2847	000003B5  3C 0D					 cmp	 al, 13
   2848	000003B7  74 04					 jz	 NDisp1
   2849	000003B9  8B D9					 mov	 ebx, ecx
   2850	000003BB  CD F7					 int	 0f7h  ; echo the character
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 51
prcycle.ASM



   2851	000003BD			 NDisp1:
   2852	000003BD  66| 42				 inc	 dx
   2853	000003BF  66| 81 FA 07D0			 cmp	 dx, 2000
   2854	000003C4  7C 04					 jl	 CursorOK1
   2855	000003C6  CD F0					 int	 0f0h
   2856	000003C8  EB 05					 jmp	 Charout1
   2857	000003CA			 CursorOK1:
   2858	000003CA  66| 8B C2				 mov	 ax, dx
   2859	000003CD  CD F3					 int	 0f3h
   2860	000003CF			 Charout1:
   2861	000003CF  58					 pop	 eax
   2862
   2863	000003D0  0F A1					 pop	 fs
   2864	000003D2  5E					 pop	 esi
   2865	000003D3  5A					 pop	 edx
   2866	000003D4  59					 pop	 ecx
   2867	000003D5  5B					 pop	 ebx
   2868							 ;sti
   2869					 ;---------------------------------------------------------------------------------
   2870					 ;changed this code on 7-7-2004
   2871	000003D6  FA					 cli
   2872	000003D7  52					 push	 edx
   2873	000003D8  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2874							 ; so that CPU will return to its application during IRETD not to
   2875							 ;  exit from the task using link field	in the TSS
   2876	000003D9  5A					 pop	 edx
   2877	000003DA  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2878	000003E0  52					 push	 edx
   2879	000003E1  9D					 popfd
   2880	000003E2  5A					 pop	 edx
   2881							 ;sti
   2882					 ;--------------------------------------------------------------------------------
   2883	000003E3  CF					 iretd
   2884	000003E4			 Getchar32Buff	 ENDP
   2885
   2886					 ;-----------------------------------------------------------------
   2887					 ; FDC_int
   2888					 ; Floppy interrupt handler
   2889					 ;-----------------------------------------------------------------
   2890	000003E4			 FDC_int	 PROC FAR
   2891	000003E4  50					 push	 eax
   2892	000003E5  53					 push	 ebx
   2893	000003E6  52					 push	 edx
   2894	000003E7  0F A0					 push	 fs
   2895
   2896	000003E9  66| B8 0018				 mov	 ax, RData_Sel
   2897	000003ED  8E E0					 mov	 fs, ax
   2898
   2899	000003EF  B0 01					 mov	 al, 1
   2900	000003F1  64: 67| A2 01E3r			 mov	 fs:[FloppyReady], al
   2901
   2902	000003F6  66| BA 0020				 mov	 dx, 20h
   2903	000003FA  B0 20					 mov	 al, 20h
   2904	000003FC  EE					 out	 dx, al
   2905
   2906	000003FD  0F A1					 pop	 fs
   2907	000003FF  5A					 pop	 edx
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 52
prcycle.ASM



   2908	00000400  5B					 pop	 ebx
   2909	00000401  58					 pop	 eax
   2910					 ;---------------------------------------------------------------------------------
   2911					 ;changed this code on 7-7-2004
   2912	00000402  FA					 cli
   2913	00000403  52					 push	 edx
   2914	00000404  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   2915							 ; so that CPU will return to its application during IRETD not to
   2916							 ;  exit from the task using link field	in the TSS
   2917	00000405  5A					 pop	 edx
   2918	00000406  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   2919	0000040C  52					 push	 edx
   2920	0000040D  9D					 popfd
   2921	0000040E  5A					 pop	 edx
   2922	0000040F  FB					 sti
   2923					 ;--------------------------------------------------------------------------------
   2924
   2925	00000410  CF					 iretd
   2926	00000411			 FDC_int	 ENDP
   2927					 ;-----------------------------------------------------------------
   2928					 ;***************************************************************************
   2929					 ;Memory interface entry
   2930					 ;  This interrupt is not used at this point
   2931					 ; It can be used for other purposes
   2932					 ; The procedure is kept to make sure that there 256 interrupts	in IDT
   2933					 ;***************************************************************************
   2934	00000411			 MEMInterface	 PROC	 FAR
   2935
   2936	00000411  CF					 iretd
   2937	00000412			 MEMInterface	 ENDP
   2938					 ;***************************************************************************
   2939					 ;Store	a value	in memory
   2940					 ;  This interrupt is not used at this point
   2941					 ; It can be used for other purposes
   2942					 ; The procedure is kept to make sure that there 256 interrupts	in IDT
   2943					 ;***************************************************************************
   2944	00000412			 getTaskPtr	 PROC	 FAR;
   2945					 ;
   2946					 ;		 push	 gs
   2947					 ;
   2948					 ;		 mov	 ax, RData_Sel		 ; real	data segment base
   2949					 ;		 mov	 gs, ax			 ; gs has real data segment base
   2950					 ;
   2951					 ;		 mov	 eax, gs:[APP1TSSAddr]	 ;get APP1TSSSeg Address
   2952					 ;
   2953					 ;		 pop	 gs
   2954					 ;
   2955					 ;		 iretd
   2956	00000412			 getTaskPtr	 ENDP
   2957					 ;***************************************************************************
   2958					 ;Fetch	a value	from memory
   2959					 ;  This interrupt is not used at this point
   2960					 ; It can be used for other purposes
   2961					 ; The procedure is kept to make sure that there 256 interrupts	in IDT
   2962					 ;***************************************************************************
   2963	00000412			 MEMFetch	 PROC	 FAR
   2964
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 53
prcycle.ASM



   2965	00000412  CF					 iretd
   2966	00000413			 MEMFetch	 ENDP
   2967					 ;***************************************************************************
   2968					 ; This	is a Malloc() type funtion
   2969					 ;   Unused space in memory outside compiler reachable area in main memory
   2970					 ;   User manage his own memory, system	has base and limit of memory areas
   2971					 ; return no of	bytes of memory	available in eax and address ptr as return value
   2972					 ; int AOAmalloc(int*)	using INT 0EEh
   2973					 ; ebx has the no of bytes and eax has the pointer
   2974					 ;***************************************************************************
   2975	00000413			 MEMMalloc	 PROC	 FAR
   2976	00000413  51					 push	 ecx		; save called values
   2977	00000414  56					 push	 esi
   2978	00000415  0F A0					 push	 fs
   2979	00000417  0F A8					 push	 gs
   2980
   2981						 ;	 mov	 ax, MEMData_Sel ;this data selector has 0 base
   2982						 ;	 mov	 fs, ax		 ; 0 base
   2983	00000419  66| B8 0018				 mov	 ax, RData_Sel	 ; real	data segment base
   2984	0000041D  8E E8					 mov	 gs, ax		 ; gs has real data segment base
   2985
   2986	0000041F  65: 67| A1 040Dr			 mov	 eax, gs:[MEMBase] ; get MEMBase value in memory 0200 0000
   2987	00000424  65: 67| 8B 0E	0409r			 mov	 ecx, gs:[MemLimit]; get MEMLimit value	in memory 0400 0000
   2988	0000042A  2B C8					 sub	 ecx, eax	 ; total no of bytes of	memory available
   2989	0000042C  8B D9					 mov	 ebx, ecx	 ; Return ebx pointer, which is	the size of memory  +
   2990					 allocated
   2991
   2992	0000042E  0F A9					 pop	 gs   ;	pop all	restored values
   2993	00000430  0F A1					 pop	 fs
   2994	00000432  5E					 pop	 esi
   2995	00000433  59					 pop	 ecx
   2996					 ;---------------------------------------------------------------------------------
   2997					 ;changed this code on 7-7-2004
   2998	00000434  FA					 cli
   2999	00000435  52					 push	 edx
   3000	00000436  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   3001							 ; so that CPU will return to its application during IRETD not to
   3002							 ;  exit from the task using link field	in the TSS
   3003	00000437  5A					 pop	 edx
   3004	00000438  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   3005	0000043E  52					 push	 edx
   3006	0000043F  9D					 popfd
   3007	00000440  5A					 pop	 edx
   3008	00000441  FB					 sti
   3009					 ;--------------------------------------------------------------------------------
   3010
   3011	00000442  CF					 iretd
   3012	00000443			 MEMMalloc	 ENDP
   3013					 ;***************************************************************************
   3014					 ; MEMFree to free memory
   3015					 ; not used at this point
   3016					 ; it can be used for other interrupt
   3017					 ;***************************************************************************
   3018	00000443			 MEMFree PROC	 FAR
   3019
   3020	00000443  CF					 iretd
   3021	00000444			 MEMFree	 ENDP
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 54
prcycle.ASM



   3022					 ;***************************************************************************
   3023					 ; ebx has the position	and al has the character to display
   3024					 ;***************************************************************************
   3025	00000444			 DisplayBegin	 PROC	 FAR
   3026	00000444  FA					 cli
   3027	00000445  06					 push	 es
   3028	00000446  50				 push	 eax	  ;save	eax
   3029	00000447  50					 push	 eax
   3030
   3031	00000448  66| B8 0010				 mov	 ax,Video_Sel
   3032	0000044C  8E C0					 mov	 es,ax
   3033	0000044E  58					 pop	 eax
   3034							 ;mov	  ah,17h
   3035							 ;mov	 ah, 7
   3036	0000044F  B4 1F				 mov	 ah, 1fh
   3037	00000451  66| 26: 89 03			 mov	 WORD PTR es:[ebx],ax
   3038	00000455  58					 pop	 eax
   3039	00000456  07					 pop	 es
   3040
   3041						 ;-----------------------------------------------------------------
   3042							 ;changed this code on 7-7-2004
   3043	00000457  52					 push	 edx
   3044	00000458  9C					 pushfd	; turn off NT flag in the CPU not in the TSS
   3045							 ; so that CPU will return to its application during IRETD not to
   3046							 ;  exit from the task using link field	in the TSS
   3047	00000459  5A					 pop	 edx
   3048	0000045A  81 E2	FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   3049	00000460  52					 push	 edx
   3050	00000461  9D					 popfd
   3051	00000462  5A					 pop	 edx
   3052						 ;-----------------------------------------------------------------
   3053	00000463  FB					 sti
   3054	00000464  CF					 iretd
   3055
   3056	00000465			 DisplayBegin	 ENDP
   3057
   3058					 ;----------------------------------------------------------------------------
   3059		  = DEMOCODESEG:0465	 DemoCodeLen	 =	 $
   3060					 ;----------------------------------------------------------------------------
   3061	00000465			 DemoCodeSeg	 ENDS
   3062					 ;----------------------------------------------------------------------------
   3063					 ;----------------------------------------------------------------------------
   3064					 ; PCodeSeg
   3065					 ; 16 bit segment for protect mode procedures which have to be in 16 bit segment
   3066					 ;____________________________________________________________________________
   3067	    0000			 PCodeSeg	 SEGMENT PARA public USE16 'CODE'
   3068							 ASSUME	 CS:PCodeSeg,DS:RDataSeg
   3069					 ;***************************************************************************
   3070					 ;Keyboard_Int Procedure
   3071					 ; OUR Hardware	keyboard INTERRUPT
   3072					 ;***************************************************************************
   3073	    0000			 Keyboard_Int PROC FAR
   3074	    0000  66| 50				 push	 eax
   3075	    0002  66| 53				 push	 ebx
   3076	    0004  66| 51				 push	 ecx
   3077	    0006  66| 52				 push	 edx
   3078	    0008  66| 56				 push	 esi
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 55
prcycle.ASM



   3079	    000A  1E					 push	 ds
   3080	    000B  0F A0					 push	 fs
   3081
   3082	    000D  B8 0018				 MOV	 AX, RData_sel		  ;Set up addressing
   3083	    0010  8E E0					 MOV	 fS, AX
   3084	    0012  8E D8					 mov	 ds, ax
   3085	    0014  FA					 cli	 ; disable interrupt
   3086
   3087	    0015  BA 0060				 mov	 dx, 60h ; get a char from keyboard buffer
   3088	    0018  EC					 in	 al, dx
   3089
   3090	    0019  A2 0306r				 mov	 scan, al
   3091	    001C  66| 0F B6 06 0306r			 movzx	 eax, scan
   3092	    0022  E9 03C9				 JMP L_keybd2
   3093	    0025			 L_keybd3:
   3094	    0025  66| 33 C0				 XOR EAX,EAX
   3095	    0028  A2 0301r				 MOV CtrlStat, AL
   3096	    002B  E9 0423				 JMP L_keybd1
   3097	    002E			 L_keybd4:
   3098	    002E  66| 33 C0				 XOR EAX,EAX
   3099	    0031  A2 0302r				 MOV AltStat, AL
   3100	    0034  E9 041A				 JMP L_keybd1
   3101	    0037			 L_keybd5:
   3102	    0037  B0 00					 mov al, 0	 ; release shift key
   3103	    0039  A2 0300r				 MOV ShiftStat,	AL
   3104	    003C  E9 0412				 JMP L_keybd1
   3105	    003F			 L_keybd6:
   3106	    003F  B0 00					 mov al, 0	 ; release shift key
   3107	    0041  A2 0300r				 MOV ShiftStat,	AL
   3108	    0044  E9 040A				 JMP L_keybd1
   3109	    0047			 L_keybd7:
   3110	    0047  66| B8 00000001			 MOV EAX,1
   3111	    004D  A2 0301r				 MOV CtrlStat, AL
   3112	    0050  E9 03FE				 JMP L_keybd1
   3113	    0053			 L_keybd8:
   3114	    0053  66| B8 00000001			 MOV EAX,1
   3115	    0059  A2 0302r				 MOV AltStat, AL
   3116	    005C  E9 03F2				 JMP L_keybd1
   3117	    005F			 L_keybd9:
   3118	    005F  66| 0F BE 06 0300r			 MOVSX EAX,ShiftStat
   3119	    0065  66| B9 00000002			 MOV ECX,2
   3120	    006B  66| 0B C1				 OR EAX,ECX
   3121	    006E  B0 01					 mov al, 1	 ; press shift key
   3122	    0070  A2 0300r				 MOV ShiftStat,	AL
   3123	    0073  E9 03DB				 JMP L_keybd1
   3124	    0076			 L_keybd10:
   3125	    0076  66| 0F BE 06 0300r			 MOVSX EAX,ShiftStat
   3126	    007C  66| B9 00000001			 MOV ECX,1
   3127	    0082  66| 0B C1				 OR EAX,ECX
   3128	    0085  B0 01					 mov al, 1	 ; press shift key
   3129	    0087  A2 0300r				 MOV ShiftStat,	AL
   3130	    008A  E9 03C4				 JMP L_keybd1
   3131	    008D			 L_keybd11:
   3132	    008D  FE 06	0304r				 INC CapLock
   3133	    0091  66| 0F BE 06 0304r			 MOVSX EAX,CapLock
   3134	    0097  66| B9 00000001			 MOV ECX,1
   3135	    009D  66| 23 C1				 AND EAX,ECX
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 56
prcycle.ASM



   3136	    00A0  A2 0304r				 MOV CapLock, AL
   3137							 KeyboardLED NumLock, CapLock
1  3138
1  3139	    00A3  B3 00					 mov bl, 0
1  3140	    00A5  A0 0304r				 mov al, CapLock
1  3141	    00A8  3C 00					 cmp al, 0
1  3142	    00AA  74 03					 jz ??0000
1  3143	    00AC  80 CB	04				 or bl,	4
1  3144	    00AF			 ??0000:
1  3145	    00AF  A0 0303r				 mov al, NumLock
1  3146	    00B2  3C 00					 cmp al, 0
1  3147	    00B4  74 03					 jz ??0001
1  3148	    00B6  80 CB	02				 or bl,	2
1  3149	    00B9			 ??0001:
1  3150	    00B9  BA 0064				 mov dx, 64h	 ; set CapLock LED
1  3151	    00BC			 ??0002:
1  3152	    00BC  EC					 in al,	dx
1  3153	    00BD  24 02					 and al, 2
1  3154	    00BF  75 FB					 jnz ??0002
1  3155
1  3156	    00C1  BA 0060				 mov dx, 60h	 ; write LED command
1  3157	    00C4  B0 ED					 mov al, 0edh
1  3158	    00C6  EE					 out dx, al
1  3159
1  3160	    00C7  BA 0064				 mov dx, 64h
1  3161	    00CA			 ??0003:
1  3162	    00CA  EC					 in al,	dx
1  3163	    00CB  24 02					 and al, 2
1  3164	    00CD  75 FB					 jnz ??0003
1  3165
1  3166	    00CF  BA 0060				 mov dx, 60h
1  3167	    00D2  8A C3					 mov al, bl
1  3168	    00D4  EE					 out dx, al
1  3169
1  3170	    00D5  BA 0064				 mov dx, 64h
1  3171	    00D8			 ??0004:
1  3172	    00D8  EC					 in al,	dx
1  3173	    00D9  24 02					 and al, 2
1  3174	    00DB  75 FB					 jnz ??0004
1  3175
   3176	    00DD  E9 0371				 JMP L_keybd1
   3177	    00E0			 L_keybd12:
   3178	    00E0  FE 06	0303r				 INC NumLock
   3179	    00E4  66| 0F BE 06 0303r			 MOVSX EAX,NumLock
   3180	    00EA  66| B9 00000001			 MOV ECX,1
   3181	    00F0  66| 23 C1				 AND EAX,ECX
   3182	    00F3  A2 0303r				 MOV NumLock, AL
   3183							 KeyboardLED NumLock, CapLock
1  3184
1  3185	    00F6  B3 00					 mov bl, 0
1  3186	    00F8  A0 0304r				 mov al, CapLock
1  3187	    00FB  3C 00					 cmp al, 0
1  3188	    00FD  74 03					 jz ??0005
1  3189	    00FF  80 CB	04				 or bl,	4
1  3190	    0102			 ??0005:
1  3191	    0102  A0 0303r				 mov al, NumLock
1  3192	    0105  3C 00					 cmp al, 0
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 57
prcycle.ASM



1  3193	    0107  74 03					 jz ??0006
1  3194	    0109  80 CB	02				 or bl,	2
1  3195	    010C			 ??0006:
1  3196	    010C  BA 0064				 mov dx, 64h	 ; set CapLock LED
1  3197	    010F			 ??0007:
1  3198	    010F  EC					 in al,	dx
1  3199	    0110  24 02					 and al, 2
1  3200	    0112  75 FB					 jnz ??0007
1  3201
1  3202	    0114  BA 0060				 mov dx, 60h	 ; write LED command
1  3203	    0117  B0 ED					 mov al, 0edh
1  3204	    0119  EE					 out dx, al
1  3205
1  3206	    011A  BA 0064				 mov dx, 64h
1  3207	    011D			 ??0008:
1  3208	    011D  EC					 in al,	dx
1  3209	    011E  24 02					 and al, 2
1  3210	    0120  75 FB					 jnz ??0008
1  3211
1  3212	    0122  BA 0060				 mov dx, 60h
1  3213	    0125  8A C3					 mov al, bl
1  3214	    0127  EE					 out dx, al
1  3215
1  3216	    0128  BA 0064				 mov dx, 64h
1  3217	    012B			 ??0009:
1  3218	    012B  EC					 in al,	dx
1  3219	    012C  24 02					 and al, 2
1  3220	    012E  75 FB					 jnz ??0009
1  3221
   3222	    0130  E9 031E				 JMP L_keybd1
   3223
   3224	    0133			 L_keybd13:
   3225	    0133  FE 06	0305r				 INC ScrLock
   3226	    0137  66| 0F BE 06 0305r			 MOVSX EAX,ScrLock
   3227	    013D  66| B9 00000001			 MOV ECX,1
   3228	    0143  66| 23 C1				 AND EAX,ECX
   3229	    0146  A2 0305r				 MOV ScrLock, AL
   3230	    0149  E9 0305				 JMP L_keybd1
   3231	    014C			 L_keybd14:
   3232	    014C  66| 0F BE 06 0306r			 MOVSX EAX,scan
   3233	    0152  66| B9 00000080			 MOV ECX,128
   3234	    0158  66| 23 C1				 AND EAX,ECX
   3235	    015B  0F 85	028D				 JNZ L_keybd15
   3236	    015F  66| B8 000001E4r			 MOV EAX,OFFSET	keyTable1
   3237	    0165  66| 8B F0				 MOV ESI, EAX
   3238	    0168  66| 0F BE 06 0306r			 MOVSX EAX,scan
   3239	    016E  66| 03 F0				 ADD ESI,EAX
   3240	    0171  66| 67| 0F BE	06			 MOVSX EAX,BYTE	PTR [ESI]
   3241	    0176  A2 0307r				 MOV ascii, AL
   3242	    0179  66| 0F BE 06 0307r			 MOVSX EAX,ascii
   3243	    017F  66| 83 F8 61				 CMP EAX,97
   3244	    0183  0F 9D	C0				 SETGE AL
   3245	    0186  22 C0					 AND AL,AL
   3246	    0188  74 45					 JZ L_keybd20
   3247	    018A  66| 0F BE 06 0307r			 MOVSX EAX,ascii
   3248	    0190  66| 83 F8 7A				 CMP EAX,122
   3249	    0194  0F 9E	C0				 SETLE AL
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 58
prcycle.ASM



   3250	    0197  22 C0					 AND AL,AL
   3251	    0199  74 34					 JZ L_keybd20
   3252	    019B  66| 0F BE 06 0300r			 MOVSX EAX,ShiftStat
   3253	    01A1  66| 23 C0				 AND EAX,EAX
   3254	    01A4  74 0E					 JZ L_keybd18
   3255	    01A6  66| 0F BE 06 0304r			 MOVSX EAX,CapLock
   3256	    01AC  66| 23 C0				 AND EAX,EAX
   3257	    01AF  0F 94	C0				 SETZ AL
   3258	    01B2  22 C0					 AND AL,AL
   3259	    01B4			 L_keybd18:
   3260	    01B4  75 19					 JNZ L_keybd20
   3261	    01B6  66| 0F BE 06 0304r			 MOVSX EAX,CapLock
   3262	    01BC  66| 23 C0				 AND EAX,EAX
   3263	    01BF  74 0E					 JZ L_keybd20
   3264	    01C1  66| 0F BE 06 0300r			 MOVSX EAX,ShiftStat
   3265	    01C7  66| 23 C0				 AND EAX,EAX
   3266	    01CA  0F 94	C0				 SETZ AL
   3267	    01CD  22 C0					 AND AL,AL
   3268	    01CF			 L_keybd20:
   3269	    01CF  74 15					 JZ L_keybd21
   3270	    01D1  66| 0F BE 06 0307r			 MOVSX EAX,ascii
   3271	    01D7  66| B9 00000020			 MOV ECX,32
   3272	    01DD  66| 2B C1				 SUB EAX,ECX
   3273	    01E0  A2 0307r				 MOV ascii, AL
   3274	    01E3  E9 01C0				 JMP L_keybd24
   3275	    01E6			 L_keybd21:
   3276	    01E6  66| 0F BE 06 0300r			 MOVSX EAX,ShiftStat
   3277	    01EC  66| 23 C0				 AND EAX,EAX
   3278	    01EF  0F 84	01B3				 JZ L_keybd23
   3279	    01F3  66| 0F BE 06 0307r			 MOVSX EAX,ascii
   3280	    01F9  E9 0108				 JMP L_keybd25
   3281	    01FC			 L_keybd26:
   3282	    01FC  66| B8 00000021			 MOV EAX,33
   3283	    0202  A2 0307r				 MOV ascii, AL
   3284	    0205  E9 019E				 JMP L_keybd24
   3285	    0208			 L_keybd27:
   3286	    0208  66| B8 00000040			 MOV EAX,64
   3287	    020E  A2 0307r				 MOV ascii, AL
   3288	    0211  E9 0192				 JMP L_keybd24
   3289	    0214			 L_keybd28:
   3290	    0214  66| B8 00000023			 MOV EAX,35
   3291	    021A  A2 0307r				 MOV ascii, AL
   3292	    021D  E9 0186				 JMP L_keybd24
   3293	    0220			 L_keybd29:
   3294	    0220  66| B8 00000024			 MOV EAX,36
   3295	    0226  A2 0307r				 MOV ascii, AL
   3296	    0229  E9 017A				 JMP L_keybd24
   3297	    022C			 L_keybd30:
   3298	    022C  66| B8 00000025			 MOV EAX,37
   3299	    0232  A2 0307r				 MOV ascii, AL
   3300	    0235  E9 016E				 JMP L_keybd24
   3301	    0238			 L_keybd31:
   3302	    0238  66| B8 0000005E			 MOV EAX,94
   3303	    023E  A2 0307r				 MOV ascii, AL
   3304	    0241  E9 0162				 JMP L_keybd24
   3305	    0244			 L_keybd32:
   3306	    0244  66| B8 00000026			 MOV EAX,38
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 59
prcycle.ASM



   3307	    024A  A2 0307r				 MOV ascii, AL
   3308	    024D  E9 0156				 JMP L_keybd24
   3309	    0250			 L_keybd33:
   3310	    0250  66| B8 0000002A			 MOV EAX,42
   3311	    0256  A2 0307r				 MOV ascii, AL
   3312	    0259  E9 014A				 JMP L_keybd24
   3313	    025C			 L_keybd34:
   3314	    025C  66| B8 00000028			 MOV EAX,40
   3315	    0262  A2 0307r				 MOV ascii, AL
   3316	    0265  E9 013E				 JMP L_keybd24
   3317	    0268			 L_keybd35:
   3318	    0268  66| B8 00000029			 MOV EAX,41
   3319	    026E  A2 0307r				 MOV ascii, AL
   3320	    0271  E9 0132				 JMP L_keybd24
   3321	    0274			 L_keybd36:
   3322	    0274  66| B8 0000005F			 MOV EAX,95
   3323	    027A  A2 0307r				 MOV ascii, AL
   3324	    027D  E9 0126				 JMP L_keybd24
   3325	    0280			 L_keybd37:
   3326	    0280  66| B8 0000002B			 MOV EAX,43
   3327	    0286  A2 0307r				 MOV ascii, AL
   3328	    0289  E9 011A				 JMP L_keybd24
   3329	    028C			 L_keybd38:
   3330	    028C  66| B8 0000000F			 MOV EAX,15
   3331	    0292  A2 0307r				 MOV ascii, AL
   3332	    0295  E9 010E				 JMP L_keybd24
   3333	    0298			 L_keybd39:
   3334	    0298  66| B8 0000007B			 MOV EAX,123
   3335	    029E  A2 0307r				 MOV ascii, AL
   3336	    02A1  E9 0102				 JMP L_keybd24
   3337	    02A4			 L_keybd40:
   3338	    02A4  66| B8 0000007D			 MOV EAX,125
   3339	    02AA  A2 0307r				 MOV ascii, AL
   3340	    02AD  E9 00F6				 JMP L_keybd24
   3341	    02B0			 L_keybd41:
   3342	    02B0  66| B8 0000003A			 MOV EAX,58
   3343	    02B6  A2 0307r				 MOV ascii, AL
   3344	    02B9  E9 00EA				 JMP L_keybd24
   3345	    02BC			 L_keybd42:
   3346	    02BC  66| B8 00000022			 MOV EAX,34
   3347	    02C2  A2 0307r				 MOV ascii, AL
   3348	    02C5  E9 00DE				 JMP L_keybd24
   3349	    02C8			 L_keybd43:
   3350	    02C8  66| B8 0000007E			 MOV EAX,126
   3351	    02CE  A2 0307r				 MOV ascii, AL
   3352	    02D1  E9 00D2				 JMP L_keybd24
   3353	    02D4			 L_keybd44:
   3354	    02D4  66| B8 0000007C			 MOV EAX,124
   3355	    02DA  A2 0307r				 MOV ascii, AL
   3356	    02DD  E9 00C6				 JMP L_keybd24
   3357	    02E0			 L_keybd45:
   3358	    02E0  66| B8 0000003C			 MOV EAX,60
   3359	    02E6  A2 0307r				 MOV ascii, AL
   3360	    02E9  E9 00BA				 JMP L_keybd24
   3361	    02EC			 L_keybd46:
   3362	    02EC  66| B8 0000003E			 MOV EAX,62
   3363	    02F2  A2 0307r				 MOV ascii, AL
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 60
prcycle.ASM



   3364	    02F5  E9 00AE				 JMP L_keybd24
   3365	    02F8			 L_keybd47:
   3366	    02F8  66| B8 0000003F			 MOV EAX,63
   3367	    02FE  A2 0307r				 MOV ascii, AL
   3368	    0301  E9 00A2				 JMP L_keybd24
   3369	    0304			 L_keybd25:
   3370	    0304  66| 83 F8 2F				 CMP EAX,47
   3371	    0308  74 EE					 JE L_keybd47
   3372	    030A  66| 83 F8 2E				 CMP EAX,46
   3373	    030E  74 DC					 JE L_keybd46
   3374	    0310  66| 83 F8 2C				 CMP EAX,44
   3375	    0314  74 CA					 JE L_keybd45
   3376	    0316  66| 83 F8 5C				 CMP EAX,92
   3377	    031A  74 B8					 JE L_keybd44
   3378	    031C  66| 83 F8 60				 CMP EAX,96
   3379	    0320  74 A6					 JE L_keybd43
   3380	    0322  66| 83 F8 27				 CMP EAX,39
   3381	    0326  74 94					 JE L_keybd42
   3382	    0328  66| 83 F8 3B				 CMP EAX,59
   3383	    032C  74 82					 JE L_keybd41
   3384	    032E  66| 83 F8 5D				 CMP EAX,93
   3385	    0332  0F 84	FF6E				 JE L_keybd40
   3386	    0336  66| 83 F8 5B				 CMP EAX,91
   3387	    033A  0F 84	FF5A				 JE L_keybd39
   3388	    033E  66| 83 F8 09				 CMP EAX,9
   3389	    0342  0F 84	FF46				 JE L_keybd38
   3390	    0346  66| 83 F8 3D				 CMP EAX,61
   3391	    034A  0F 84	FF32				 JE L_keybd37
   3392	    034E  66| 83 F8 2D				 CMP EAX,45
   3393	    0352  0F 84	FF1E				 JE L_keybd36
   3394	    0356  66| 83 F8 30				 CMP EAX,48
   3395	    035A  0F 84	FF0A				 JE L_keybd35
   3396	    035E  66| 83 F8 39				 CMP EAX,57
   3397	    0362  0F 84	FEF6				 JE L_keybd34
   3398	    0366  66| 83 F8 38				 CMP EAX,56
   3399	    036A  0F 84	FEE2				 JE L_keybd33
   3400	    036E  66| 83 F8 37				 CMP EAX,55
   3401	    0372  0F 84	FECE				 JE L_keybd32
   3402	    0376  66| 83 F8 36				 CMP EAX,54
   3403	    037A  0F 84	FEBA				 JE L_keybd31
   3404	    037E  66| 83 F8 35				 CMP EAX,53
   3405	    0382  0F 84	FEA6				 JE L_keybd30
   3406	    0386  66| 83 F8 34				 CMP EAX,52
   3407	    038A  0F 84	FE92				 JE L_keybd29
   3408	    038E  66| 83 F8 33				 CMP EAX,51
   3409	    0392  0F 84	FE7E				 JE L_keybd28
   3410	    0396  66| 83 F8 32				 CMP EAX,50
   3411	    039A  0F 84	FE6A				 JE L_keybd27
   3412	    039E  66| 83 F8 31				 CMP EAX,49
   3413	    03A2  0F 84	FE56				 JE L_keybd26
   3414	    03A6			 L_keybd23:
   3415	    03A6			 L_keybd24:
   3416	    03A6  66| B8 00000308r			 mov eax, offset KKQ
   3417	    03AC  66| 8B F0				 mov esi, eax
   3418	    03AF  64: 8A 1E 0407r			 mov bl, fs:[KHead]
   3419	    03B4  64: 8A 3E 0408r			 mov bh, fs:[KTail]
   3420
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 61
prcycle.ASM



   3421	    03B9  80 FB	FE				 cmp bl, 254
   3422	    03BC  75 04					 jnz Nottail
   3423	    03BE  B3 00					 mov bl, 0
   3424	    03C0  EB 02					 jmp Cmpequal
   3425	    03C2			 Nottail:
   3426	    03C2  FE C3					 inc bl
   3427	    03C4			 Cmpequal:
   3428	    03C4  3A DF					 cmp bl, bh
   3429	    03C6  0F 84	0087				 je L_keybd1 ; keyboard	buffer full
   3430
   3431	    03CA  66| 33 DB				 xor ebx, ebx
   3432	    03CD  64: 8A 1E 0407r			 mov bl, fs:[KHead]
   3433	    03D2  66| 03 F3				 add esi, ebx
   3434	    03D5  A0 0307r				 mov al, ascii
   3435	    03D8  64: 67| 88 06				 mov fs:[esi], al
   3436
   3437	    03DC  80 FB	FE				 cmp bl, 254
   3438	    03DF  72 04					 jb Nottail2
   3439
   3440	    03E1  B3 00					 mov bl, 0
   3441	    03E3  EB 02					 jmp Cmpequal2
   3442	    03E5			 Nottail2:
   3443	    03E5  FE C3					 inc bl
   3444	    03E7			 Cmpequal2:
   3445	    03E7  64: 88 1E 0407r			 mov fs:[KHead], bl
   3446	    03EC			 L_keybd15:
   3447	    03EC  EB 63					 JMP L_keybd1
   3448	    03EE			 L_keybd2:
   3449	    03EE  66| 83 F8 46				 CMP EAX,70
   3450	    03F2  0F 84	FD3D				 JE L_keybd13
   3451	    03F6  66| 83 F8 45				 CMP EAX,69
   3452	    03FA  0F 84	FCE2				 JE L_keybd12
   3453	    03FE  66| 83 F8 3A				 CMP EAX,58
   3454	    0402  0F 84	FC87				 JE L_keybd11
   3455	    0406  66| 83 F8 36				 CMP EAX,54
   3456	    040A  0F 84	FC68				 JE L_keybd10
   3457	    040E  66| 83 F8 2A				 CMP EAX,42
   3458	    0412  0F 84	FC49				 JE L_keybd9
   3459	    0416  66| 83 F8 38				 CMP EAX,56
   3460	    041A  0F 84	FC35				 JE L_keybd8
   3461	    041E  66| 83 F8 1D				 CMP EAX,29
   3462	    0422  0F 84	FC21				 JE L_keybd7
   3463	    0426  66| 3D 000000B6			 CMP EAX,182
   3464	    042C  0F 84	FC0F				 JE L_keybd6
   3465	    0430  66| 3D 000000AA			 CMP EAX,170
   3466	    0436  0F 84	FBFD				 JE L_keybd5
   3467	    043A  66| 3D 000000B8			 CMP EAX,184
   3468	    0440  0F 84	FBEA				 JE L_keybd4
   3469	    0444  66| 3D 0000009D			 CMP EAX,157
   3470	    044A  0F 84	FBD7				 JE L_keybd3
   3471	    044E  E9 FCFB				 JMP L_keybd14
   3472	    0451			 L_keybd1:
   3473	    0451  E4 61					 in al,	61h	 ; acknowledge the key
   3474	    0453  8A E0					 mov ah, al
   3475	    0455  0C 80					 or al,	80h
   3476	    0457  E6 61					 out 61h, al
   3477	    0459  8A C4					 mov al, ah
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 62
prcycle.ASM



   3478	    045B  E6 61					 out 61h, al
   3479
   3480	    045D  B0 20					 MOV AL,20h			  ;Tell	interrupt handler we're	done
   3481	    045F  E6 20					 OUT 20h,AL
   3482	    0461  FB					 STI				  ;enable interrupts
   3483
   3484	    0462  0F A1					 pop	 fs
   3485	    0464  1F					 pop	 ds
   3486	    0465  66| 5E				 pop	 esi
   3487	    0467  66| 5A				 pop	 edx
   3488	    0469  66| 59				 pop	 ecx
   3489	    046B  66| 5B				 pop	 ebx
   3490	    046D  66| 58				 pop	 eax
   3491					 ;---------------------------------------------------------------------------------
   3492					 ;changed this code on 7-7-2004
   3493	    046F  FA					 cli
   3494	    0470  66| 52				 push	 edx
   3495	    0472  66| 9C				 pushfd	; turn off NT flag in the CPU not in the TSS
   3496							 ; so that CPU will return to its application during IRETD not to
   3497							 ;  exit from the task using link field	in the TSS
   3498	    0474  66| 5A				 pop	 edx
   3499	    0476  66| 81 E2 FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   3500	    047D  66| 52				 push	 edx
   3501	    047F  66| 9D				 popfd
   3502	    0481  66| 5A				 pop	 edx
   3503	    0483  FB					 sti
   3504					 ;--------------------------------------------------------------------------------
   3505	    0484  66| CF		 iretd
   3506	    0486			 Keyboard_Int ENDP
   3507
   3508					 ;***************************************************************************
   3509					 ;SearchBegin Procedure
   3510					 ; Find	a given	pattern	in memory
   3511					 ; fs has RDataSel
   3512					 ; es has base 0 descriptor for	4GB limit SearchForData_Sel
   3513					 ; searches memory from	00000000h to 10000000h
   3514					 ;***************************************************************************
   3515	    0486			 SearchBegin	 PROC	 FAR
   3516
   3517	    0486  66| B8 00000010r			 mov	 eax, offset SearchKey
   3518	    048C  66| 8B F8				 mov	 edi, eax
   3519	    048F  66| 33 C9				 xor	 ecx, ecx
   3520	    0492  66| 33 D2				 xor	 edx, edx
   3521	    0495			 GtChar:
   3522
   3523	    0495  CD FC					 int	 0fch	; get a	character at a time to read pattern
   3524	    0497  64: A0 000Br				 mov	 al, fs:[StoreChar] ; store the	char temporarily
   3525	    049B  3C 0D					 cmp	 al, 0dh	 ; check if it is end of line
   3526	    049D  74 08					 je	 Search	 ; if it is end	of line	then search
   3527
   3528	    049F  41					 inc	 cx	 ; get next character
   3529	    04A0  67| 88 07				 mov	 byte ptr [edi], al ; move the character to key	storage
   3530	    04A3  66| 47				 inc	 edi	 ; next	poitner	for key
   3531	    04A5  EB EE					 jmp	 GtChar	 ; loop	until end of line
   3532
   3533	    04A7				 Search:
   3534	    04A7  64: 89 0E 0110r			 mov	 fs:[SearchLen], cx	 ; Key length
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 63
prcycle.ASM



   3535
   3536							 ; Serch between 00000000H and 10000000H
   3537	    04AC  66| BA 00000320			 mov	 edx, 800  ; starting point of printing	on the screen
   3538	    04B2  66| 33 C0				 xor	 eax, eax
   3539	    04B5  66| 8B F8				 mov	 edi, eax  ; destination index with 0 value
   3540	    04B8  66| B9 00000000			 mov	 ecx, 0	   ; start counter 4 byte with 0 value
   3541
   3542	    04BE  66| B8 00000010r			 mov	 eax, offset SearchKey	; offset only
   3543	    04C4  66| 8B F0				 mov	 esi, eax  ; offset in the source index
   3544	    04C7  64: 8B 0E 0110r			 mov	 cx, fs:[SearchLen]  ; 4 byte length
   3545
   3546	    04CC				 Search1:
   3547
   3548	    04CC  64: 67| 8A 1E				 mov	 bl, byte ptr fs:[esi] ; get first byte	of the key
   3549	    04D0  26: 67| 3A 1F				 cmp	 bl, byte ptr es:[edi] ; starting from 00000000h
   3550	    04D4  74 0D					 jz	 Search2   ; first char	matched	go for next char
   3551
   3552	    04D6  66| 47				 inc	 edi  ;	next
   3553	    04D8  66| 81 FF 10000000			 cmp	 edi, 10000000h	; max limit
   3554	    04DF  72 EB					 jb	 Search1 ; go to next location at destination
   3555	    04E1  EB 64					 jmp	 retn2	 ; limit is done, quit
   3556
   3557	    04E3				 Search2:
   3558	    04E3  66| 56				 push	 esi
   3559	    04E5  66| 57				 push	 edi
   3560	    04E7				 Search3:
   3561	    04E7  49					 dec	 cx
   3562	    04E8  E3 2D					 jcxz	 FindIt
   3563	    04EA  66| 46				 inc	 esi
   3564	    04EC  66| 47				 inc	 edi
   3565	    04EE  66| 81 FF 10000000			 cmp	 edi, 10000000h	 ; search over
   3566	    04F5  73 4C					 jae	 retn1
   3567	    04F7  64: 67| 8A 1E				 mov	 bl, byte ptr fs:[esi]
   3568	    04FB  26: 67| 3A 1F				 cmp	 bl, byte ptr es:[edi]
   3569	    04FF  74 E6					 jz	 Search3
   3570
   3571	    0501  66| 5F				 pop	 edi
   3572	    0503  66| 5E				 pop	 esi
   3573
   3574	    0505  66| 47				 inc	 edi
   3575	    0507  66| 81 FF 10000000			 cmp	 edi, 10000000h
   3576	    050E  73 37					 jae	 retn2
   3577	    0510  64: 8B 0E 0110r			 mov	 cx, fs:[SearchLen]
   3578	    0515  EB B5					 jmp	 Search1
   3579
   3580	    0517				 FindIt:
   3581	    0517  66| 8B C7				 mov	 eax, edi
   3582	    051A  66| 5F				 pop	 edi
   3583	    051C  66| 5E				 pop	 esi
   3584	    051E  66| 8B F8				 mov	 edi, eax
   3585	    0521  66| 33 C9				 xor	 ecx, ecx
   3586	    0524  64: 8B 0E 0110r			 mov	 cx, fs:[SearchLen]
   3587	    0529  49					 dec	 cx
   3588	    052A  66| 2B C1				 sub	 eax, ecx
   3589
   3590	    052D  66| 8B DA				 mov	 ebx, edx
   3591	    0530  CD FD					 int	 0fdh
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 64
prcycle.ASM



   3592	    0532  66| 83 C2 12				 add	 edx, 18
   3593
   3594	    0536  66| 47				 inc	 edi
   3595	    0538  66| 81 FF 10000000			 cmp	 edi, 10000000h
   3596	    053F  73 06					 jae	 retn2
   3597	    0541  EB 89					 jmp	 Search1
   3598
   3599	    0543				 retn1:
   3600	    0543  66| 5F				 pop	 edi
   3601	    0545  66| 5E				 pop	 esi
   3602	    0547				 retn2:
   3603
   3604							 ;This loop displays the destination address at	the end	the search
   3605	    0547  66| 50				 push	 eax
   3606	    0549  66| 53				 push	 ebx
   3607	    054B  66| 8B C7				 mov	 eax,edi ; This	prints the destination address of search
   3608	    054E  66| BB 00000AF0			 mov	 ebx, 2800
   3609	    0554  CD FD					 int	 0fdh
   3610	    0556  66| 5B				 pop	 ebx
   3611	    0558  66| 58				 pop	 eax
   3612
   3613
   3614	    055A  66| CF				 iretd
   3615	    055C  E9 FF27				 jmp	 SearchBegin
   3616	    055F			 SearchBegin	 ENDP
   3617		  = PCODESEG:055F	 PCodeLen     =	      $
   3618	    055F			 PCodeSeg	 ends
   3619					 ;***************************************************************************
   3620					 ; DMADataSeg
   3621					 ; 16 bit, aligned on page
   3622					 ; Used	for DMA	transfer
   3623					 ;***************************************************************************
   3624	    0000			 DMADataSeg	 SEGMENT PARA PUBLIC USE16 'DMADATA'
   3625	    0000  0100*(00)		 DB	 256 DUP(0)
   3626	    0100  0100*(00)		 DB	 256 DUP(0)
   3627	    0200			 DMADataSeg	 ENDS
   3628					 ;***************************************************************************
   3629					 ; MEMStructureSeg
   3630					 ; 16 bit, aligned on page
   3631					 ; Used	for memory structure
   3632					 ; every variable is 18	bytes and has such structure:
   3633					 ; DQ, start address
   3634					 ; DQ, size
   3635					 ; DB, variable	type
   3636					 ; DB, valid
   3637					 ; program can allocate	2000 variables
   3638					 ;***************************************************************************
   3639					 ;MEMStructureSeg	 SEGMENT PARA PUBLIC USE16 'MEMSTRDATA'
   3640					 ;DB	 36000 DUP(0)
   3641					 ;MEMStructureSeg	 ENDS
   3642					 ;***************************************************************************
   3643					 ;RDataSeg Segment
   3644					 ;  16 bit segment
   3645					 ;  all	real mode data should be included in this segment
   3646					 ;***************************************************************************
   3647					 ;
   3648	    0000			 RDataSeg	 SEGMENT PARA  public USE16  'REALDATA'
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 65
prcycle.ASM



   3649					 ;
   3650					 ;----------------------------------------------------------------------------
   3651					 ;GDT
   3652					 ;This example has a base of 00100200h
   3653					 ;LimitL	 BaseL		 BaseM	 Attributes	 LimitH		 BaseH
   3654					 ;----------------------------------------------------------------------------
   3655					 ;FF FF		 00 02		 10	 92		 8F		 00
   3656					 ;----------------------------------------------------------------------------
   3657					 ;LSB1,2nd	 LSB1,2nd		 P DPL S Type	 G D 0 AVL Limit
   3658					 ;----------------------------------------------------------------------------
   3659					 ;P- Segment Present,S-system(callgate must have 0 for S)
   3660					 ;G-Granularity,D=0 ->16bit segment and	addressess and D=1->32 bit
   3661					 ;For CallGate	 Type=1100
   3662					 ;-----------------------------------------
   3663					 ; FF|FF|00|02|10|92|8F|00
   3664					 ;	|     |	 |  |  |
   3665					 ;LimitL|BaseL|BaseM|Attributes|GD0AVL,LimitH|BaseH
   3666					 ; 00 10 02 00
   3667					 ; BaseH BaseM BaseL2nd	BaseL1st
   3668					 ; BYTE	0  --- BYTE 7
   3669					 ;-----------------------------------------
   3670					 ;----------------------------------------------------------------------------
   3671
   3672	    0000			 GDT		 LABEL	 BYTE
   3673	    0000  0000 0000 00 00 00  +	 DUMMY		 Desc	 <00000h,00000h, 000h, 000h, 000h, 000h> ; dummy characters for	    +
   3674		  00			 reference
   3675					 ; It changed from RELOCATE1 to	0800h, seems to	have no	effect
   3676					 ; prcycle code	is starting at 0800h
   3677	    0008  FFFF 0800 00 92 00  +	 Normal		 Desc	 <0ffffh,0800h,,ATDW,,>
   3678		  00
   3679	    0010  7FFF 8000 0B F2 00  +	 VideoBuf	 Desc	 <07fffh,8000h,0bh,ATDW+DPL3,,>
   3680		  00
   3681	    0018			 EFFGDT		 LABEL	 BYTE	; starting point of GDT	entry
   3682					 ;----------------------------------------------------------------------
   3683					 ;RELOCATE1 should be a	segment	register value not the 32 bit address
   3684					 ;All base addressess should be	initialised like a segment register.
   3685					 ;----------------------------------------------------------------------
   3686	    0018  FFFF 0080s 00	92 00 +	 RData		 Desc	 <0ffffh,RDataSeg+RELOCATE1,,ATDW,,>	   ;for	loading	fs
   3687		  00
   3688	    0020  0069r	0080s 00 89 00+	 DemoTSS	 Desc	 <DemoTssLen-1,DemoTSSSeg+RELOCATE1,,AT386TSS,,>
   3689		  00
   3690	    0028  009F 0080s 00	82 00 +	 DemoLDTD	 Desc	 <DemoLDTLen-1,DemoLDTSeg+RELOCATE1,,ATLDT,,>
   3691		  00
   3692	    0030  FFFF 0080s 00	98 00 +	 TempCode	 Desc	 <0ffffh,RCodeSeg+RELOCATE1,,ATCE,,>	 ;RCodeSeg
   3693		  00
   3694	    0038  0DC4r	0080s 00 98 00+	 Other		 Desc	 <RCodeLen-1,RCodeSeg+RELOCATE1,,ATCE,,>
   3695		  00
   3696	    0040  0068r	0080s 00 89 00+	 GetCharTSS	 Desc	 <GetCharTSSLen-1,GetCharTSSSeg+RELOCATE1,,AT386TSS,,>	;AT386TSS = +
   3697		  00			 89h
   3698	    0048  0068r	0080s 00 89 00+	 GetDecTSS	 Desc	 <GetDecTSSLen-1,GetDecTSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS	= 89h
   3699		  00
   3700	    0050  0068r	0080s 00 89 00+	 GetSecTSS	 Desc	 <GetSecTSSLen-1,GetSecTSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS	= 89h
   3701		  00
   3702	    0058  0068r	0080s 00 89 00+	 WriteSecTSS	 Desc	 <WriteSecTSSLen-1,WriteSecTSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS +
   3703		  00			 = 89h
   3704	    0060  0068r	0080s 00 89 00+	 GKeyTSS	 Desc	 <GKeyTSSLen-1,GKeyTSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS = 89h
   3705		  00
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 66
prcycle.ASM



   3706	    0068  000Fr	0080s 00 82 00+	 GKeyLDT	 Desc	 <GKeyLDTLen-1,GKeyLDTSeg+RELOCATE1,,ATLDT,,>
   3707		  00
   3708	    0070  000Fr	0080s 00 82 00+	 GetCharLDT	 Desc	 <GetCharLDTLen-1,GetCharLDTSeg+RELOCATE1,,ATLDT,,>
   3709		  00
   3710	    0078  000Fr	0080s 00 82 00+	 GetDecLDT	 Desc	 <GetDecLDTLen-1,GetDecLDTSeg+RELOCATE1,,ATLDT,,>
   3711		  00
   3712	    0080  000Fr	0080s 00 82 00+	 GetSecLDT	 Desc	 <GetSecLDTLen-1,GetSecLDTSeg+RELOCATE1,,ATLDT,,>
   3713		  00
   3714	    0088  000Fr	0080s 00 82 00+	 WriteSecLDT	 Desc	 <WriteSecLDTLen-1,WriteSecLDTSeg+RELOCATE1,,ATLDT,,>
   3715		  00
   3716	    0090  0017r	0080s 00 92 40+	 Puthex32Data	 Desc	 <ProtModeProcDataLen-1,ProtModeProcDataSeg+RELOCATE1,,ATDW,D32,0h>
   3717		  00
   3718	    0098  0464r	0080s 00 98 40+	 Puthex32I	 Desc	 <DemoCodeLen-1,DemoCodeSeg+RELOCATE1,,ATCE,D32,>
   3719		  00
   3720	    00A0  001Fr	0080s 00 82 00+	 SearchLDT	 Desc	 <SearchLDTLen-1,SearchLDTSeg+RELOCATE1,,ATLDT,,>
   3721		  00
   3722	    00A8  0068r	0080s 00 89 00+	 SearchTSS	 Desc	 <SearchTSSLen-1,SearchTSSSeg+RELOCATE1,,AT386TSS,,>
   3723		  00
   3724	    00B0  FFFF 0000 00 92 CF  +	 G4Data		 Desc	 <0ffffh,0,0,92h,0cfh,0>
   3725		  00
   3726
   3727	    00B8  0111r	0080s 00 92 00+	 GlobalData	 Desc	 <GlobalDataLen-1,GlobalDataSeg+RELOCATE1,,ATDW,,0h>
   3728		  00
   3729					 ; this	descriptor is in GDT, it is not	a task,	any global program can use this
   3730	    00C0  FFFF 0000 00 92 CF  +	 MEMData	 Desc	 <0ffffh,0h,0h,ATDW,0cfh,0h>	 ;Memory interface data	segment
   3731		  00
   3732					 ; MEMData selector does not have any base address everything is zero
   3733
   3734					 ; App1TSS descriptor must be in GDT as	it is a	separate Task
   3735
   3736					 ; All the fields can be modified dynamically in the followong desc if App1TSS Address is   +
   3737					 given to Application
   3738					 ; Currently there can be 4 applications setup in GDT
   3739					 ; each	application 1,2,3,4 are	called parent applications
   3740					 ; all parent applications are fixed in	GDT
   3741					 ; each	parent application is given one	slot for a child task in GDT
   3742					 ; multiple children's tasks are managed in the	application by using this one slot
   3743					 ;  and	a given	API to modify child location in	GDT
   3744					 ;App1TSS	 Desc	 <App1TSSLen-1,0000h,00h,AT386TSS,,02h>	 ;AT386TSS = 89h
   3745	    00C8  006Fr	0080s 00 89 00+	 App1TSS	 Desc	 <App1TSSLen-1,App1TSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS = 89h   +
   3746		  00			 Application
   3747	    00D0  006Fr	0080s 00 92 00+	 App1TSSRW	 Desc	 <App1TSSLen-1,App1TSSSeg+RELOCATE1,,ATDW,,>  ;AT386TSS	= 89h
   3748		  00
   3749	    00D8  0037r	0080s 00 82 00+	 App1LDT	 Desc	 <App1LDTLen-1,App1LDTSeg+RELOCATE1,,ATLDT,,>
   3750		  00
   3751	    00E0  006Fr	0080s 00 89 00+	 App1TSSC	 Desc	 <App1TSSLen-1,App1TSSSeg+RELOCATE1,,AT386TSS,,> ;AT386TSS = 89h    +
   3752		  00			 Client
   3753	    00E8  006Fr	0080s 00 89 00+	 App1TSSS	 Desc	 <App1TSSLen-1,App1TSSSeg+RELOCATE1,,AT386TSS,,> ;AT386TSS = 89h    +
   3754		  00			 Scheduler
   3755	    00F0  0000 0000 00 00 00  +	 App1TSST	 Desc	 <,,,,,>					 ;AT386TSS = 89h    +
   3756		  00			 Timer
   3757	    00F8  0000 0000 00 00 00  +	 App1TSSE	 Desc	 <,,,,,>					 ;AT386TSS = 89h    +
   3758		  00			 Error
   3759
   3760	    0100  03FFr	0080s 00 89 00+	 App2TSS	 Desc	 <App2TSSLen-1,App2TSSSeg+RELOCATE1,,AT386TSS,,>  ;AT386TSS = 89h
   3761		  00
   3762	    0108  03FFr	0080s 00 92 00+	 App2TSSRW	 Desc	 <App2TSSLen-1,App2TSSSeg+RELOCATE1,,ATDW,,>  ;AT386TSS	= 89h
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 67
prcycle.ASM



   3763		  00
   3764	    0110  0037r	0080s 00 82 00+	 App2LDT	 Desc	 <App1LDTLen-1,App1LDTSeg+RELOCATE1,,ATLDT,,>
   3765		  00
   3766	    0118  03FFr	0000 00	89 00 +	 App2TSSC	 Desc	 <App2TSSLen-1,0000h,00h,AT386TSS,,02h>	 ;AT386TSS = 89h
   3767		  02
   3768	    0120  03FFr	0080s 00 92 00+	 App2TSSRWC	 Desc	 <App2TSSLen-1,App2TSSSeg+RELOCATE1,,ATDW,,>  ;AT386TSS	= 89h
   3769		  00
   3770	    0128  0037r	0080s 00 82 00+	 App2LDTC	 Desc	 <App1LDTLen-1,App1LDTSeg+RELOCATE1,,ATLDT,,>
   3771		  00
   3772
   3773	    0130  FFFF 0080s 00	92 00 +	 DMADATA	 Desc	 <0ffffh,DMADataSeg+RELOCATE1,,ATDW,,0H>	 ; for DMA read/write
   3774		  00
   3775	    0138  055Er	0080s 00 98 00+	 PCode		 Desc	 <PCodeLen-1,PCodeSeg+RELOCATE1,,ATCE,,>     ;PCodeSeg
   3776		  00
   3777	    0140  00E1r	0080s 00 98 40+	 EtherDesc	 Desc	 <EthernetReceiveCodeLen-1,EthernetReceive+RELOCATE1,,ATCE,D32,>
   3778		  00
   3779	    0148  0069r	0080s 00 92 00+	 DemoTSSRW	 Desc	 <DemoTSSLen-1,DemoTSSSeg+RELOCATE1,,ATDW,,>  ;AT386TSS	= 89h
   3780		  00
   3781	    0150  0000r	0080s 00 98 40+	 IntExceptionDesc	 Desc	 <IntExceptionCodeLen-1,IntExceptionSeg+RELOCATE1,,ATCE,D32,>
   3782		  00
   3783					 ;		 REPT	 100
   3784					 ;		 Desc	 <00200h,00200h, 020h, 020h, 020h, 020h>
   3785					 ;		 ENDM
   3786					 ;----------------------------------------------------------------------------
   3787		  = 0158		 GDTLen		 =	 $-GDT			  ;total no of entries including dummies
   3788		  = 0028		 GDNum		 =	 ($-EFFGDT)/(SIZE Desc)	  ; number of entries in GDT ex.. 28
   3789					 ;----------------------------------------------------------------------------
   3790		  = 0008		 Normal_Sel	 =	 Normal-GDT
   3791		  = 0010		 Video_Sel	 =	 VideoBuf-GDT
   3792					 ;----------------------------------------------------------------------------
   3793		  = 0020		 DemoTSS_Sel		 =	 DemoTSS-GDT
   3794		  = 0148		 DemoTSSRW_Sel		 =	 DemoTSSRW-GDT
   3795		  = 0028		 DemoLDT_Sel		 =	 DemoLDTD-GDT
   3796		  = 0030		 TempCode_Sel		 =	 TempCode-GDT
   3797		  = 0038		 Other_Sel		 =	 Other-GDT
   3798		  = 0018		 RData_Sel		 =	 RData-GDT
   3799		  = 0060		 GKeyTSS_Sel		 =	 GKeyTSS-GDT
   3800		  = 0040		 GetCharTSS_Sel		 =	 GetCharTSS-GDT
   3801		  = 0048		 GetDecTSS_Sel		 =	 GetDecTSS-GDT
   3802		  = 0050		 GetSecTSS_Sel		 =	 GetSecTSS-GDT
   3803		  = 0058		 WriteSecTSS_Sel	 =	 WriteSecTSS-GDT
   3804		  = 0068		 GKeyLDT_Sel		 =	 GKeyLDT-GDT
   3805		  = 0070		 GetCharLDT_Sel		 =	 GetCharLDT-GDT
   3806		  = 0078		 GetDecLDT_Sel		 =	 GetDecLDT-GDT
   3807		  = 0080		 GetSecLDT_Sel		 =	 GetSecLDT-GDT
   3808		  = 0088		 WriteSecLDT_Sel	 =	 WriteSecLDT-GDT
   3809		  = 0090		 Puthex32Data_Sel	 =	 Puthex32Data-GDT
   3810		  = 0098		 Puthex32I_Sel		 =	 Puthex32I-GDT
   3811		  = 0140		 EthernetReceive_Sel	 =	 EtherDesc-GDT
   3812
   3813		  = 00B8		 GlobalData_Sel		 =	 GlobalData-GDT
   3814
   3815		  = 00C0		 MEMData_Sel		 =	 MEMData-GDT
   3816					 ;MEMStrData_Sel	 =	 MEMStrData-GDT
   3817
   3818		  = 00A0		 SearchLDT_Sel		 =	 SearchLDT-GDT
   3819		  = 00A8		 SearchTSS_Sel		 =	 SearchTSS-GDT
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 68
prcycle.ASM



   3820		  = 00B0		 G4Data_Sel		 =	 G4Data-GDT
   3821
   3822		  = 00C8		 App1TSS_Sel		 =	 App1TSS-GDT
   3823		  = 00E0		 App1TSSC_Sel		 =	 App1TSSC-GDT
   3824		  = 00E8		 App1TSSS_Sel		 =	 App1TSSS-GDT
   3825		  = 00F8		 App1TSSE_Sel		 =	 App1TSSE-GDT
   3826		  = 00F0		 App1TSST_Sel		 =	 App1TSST-GDT
   3827		  = 0100		 App2TSS_Sel		 =	 App2TSS-GDT
   3828		  = 00D0		 App1TSSRW_Sel		 =	 App1TSSRW-GDT
   3829		  = 0108		 App2TSSRW_Sel		 =	 App2TSSRW-GDT
   3830		  = 00D8		 App1LDT_Sel		 =	 App1LDT-GDT
   3831		  = 0110		 App2LDT_Sel		 =	 App2LDT-GDT
   3832		  = 0130		 DMAData_Sel		 =	 DMADATA-GDT		 ; DMA data segment selector
   3833		  = 0138		 PCode_Sel		 =	 PCode-GDT		 ; 16 bit segment for protect mode
   3834		  = 0150		 IntException_Sel	 =	 IntExceptionDesc-GDT
   3835					 ;----------------------------------------------------------------------------
   3836	    0158  30 31	32 33 34 35 36+	 HexTable	 DB	 '0123456789ABCDEF'
   3837		  37 38	39 41 42 43 44+
   3838		  45 46
   3839	    0168  ????????		 IndexCnt	 DD	 ?
   3840	    016C  41424344		 PrintData	 DD	 'ABCD'
   3841	    0170  0070r			 SizeOf_TSS1	 DW	 App1TSSLen ; length of	the App1TSS seg	is stored here
   3842
   3843					 ;offset:segment
   3844	    0172  0000 0000		 RealJumpAddr	 dw	 0000h,0000h
   3845
   3846	    0176  10*(00)		 LoadArray	 db	 16 dup(0)
   3847					 ;----------------------------------------------------------------------------
   3848	    0186  0157 00000000		 VGDTR		 PDesc	 <GDTLen-1,>  ;	lenght of GDT is initialized, 2	bytes
   3849	    018C  07FF 00000000		 VIDTR		 PDesc	 <IDTLen-1,>
   3850	    0192  03FF 00000000		 NORVIDTR	 PDesc	 <3FFh,>
   3851	    0198  ??			 IMaskRegV	 DB	 ?
   3852	    0199  ????			 SPVar		 DW	 ?
   3853	    019B  ????			 SSVar		 DW	 ?
   3854	    019D  0000			 RERunFlag	 DW	 0000h	     ; This flag remembers that	the app1 ran once
   3855									     ; This flag is used to reinitialize the TSS for APP1 in+
   3856					 RunAppl Module
   3857					 ;----------------------------------------------------------------------------
   3858	    019F  0D 0A	20 20 20 20 20+	 prompt1    DB	13,10,'		 Press any key to continue... ',0
   3859		  20 20	20 20 20 50 72+
   3860		  65 73	73 20 61 6E 79+
   3861		  20 6B	65 79 20 74 6F+
   3862		  20 63	6F 6E 74 69 6E+
   3863		  75 65	2E 2E 2E 20 00
   3864					 ;----------------------------------------------------------------------------
   3865					 ; This	offset is used to print	memory w.r.t base in the desc
   3866					 ; This	should be initialised before calling PRINTMEMP call gate
   3867					 ;		 mov	 eax,ds:[MemPrintOffset]
   3868					 ;		 CALL16	 PrintmemPGate_Sel,0h
   3869					 ;----------------------------------------------------------------------------
   3870
   3871	    01C9  ????????		 MemPrintOffset		 dd	 ?
   3872	    01CD  00000021		 AnyCounter		 dd	 00000021h ; sector 33 to print	sectors
   3873	    01D1  00			 LoadCounter		 db	 0
   3874	    01D2  00000000		 RunFlag		 dd	 0
   3875	    01D6  00			 MemFlag		 db	 0
   3876	    01D7  00001234		 MemoryOffset		 dd	 1234h	; actual memory	location where the offset is stored
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 69
prcycle.ASM



   3877
   3878					 ;----------------------------------------------------------------------------
   3879	    01DB  00000000		 abdtemp		 dd	 0
   3880	    01DF  00000000		 AppGDTPtr		 dd	 0	 ; Temp	variable declared to test the no of GDT	    +
   3881					 entries changed
   3882
   3883					 ;----------------------------------------------------------------------------
   3884	    01E3  00			 FloppyReady		 db	 0
   3885					 ;----------------------------------------------------------------------------
   3886					 ; Keyboard key	map
   3887	    01E4  00 1B	31 32 33 34 35+	 keyTable1 DB 00,1bh,31h,32h,33h,34h,35h,36h,37h,38h,39h,30h,2dh,3dh,08h,09h
   3888		  36 37	38 39 30 2D 3D+
   3889		  08 09
   3890	    01F4  71 77	65 72 74 79 75+		   DB 'q','w','e','r','t','y','u','i','o','p','[',']',0dh,00
   3891		  69 6F	70 5B 5D 0D 00
   3892	    0202  61 73	64 66 67 68 6A+		   DB 'a','s','d','f','g','h','j','k','l',';',27h,'`',00,'\'
   3893		  6B 6C	3B 27 60 00 5C
   3894	    0210  7A 78	63 76 62 6E 6D+		   DB 'z','x','c','v','b','n','m',',','.','/',00,'*',00,' ',00
   3895		  2C 2E	2F 00 2A 00 20+
   3896		  00
   3897	    021F  00 00	00 00 00 00 00+		   DB  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2dh,0,0,0,2Bh,0,0,0,0,0
   3898		  00 00	00 00 00 00 00+
   3899		  00 2D	00 00 00 2B 00+
   3900		  00 00	00 00
   3901	    0238  C8*(00)			   DB  200 dup(0)
   3902					 ; The Following Variables are used by the Keyboard handler
   3903	    0300  00			 ShiftStat	 DB 00
   3904	    0301  00			 CtrlStat	 DB 00
   3905	    0302  00			 AltStat	 DB 00
   3906	    0303  00			 NumLock	 DB 00
   3907	    0304  00			 CapLock	 DB 00
   3908	    0305  00			 ScrLock	 DB 00
   3909	    0306  00			 scan		 DB 00
   3910	    0307  00			 ascii		 DB 00
   3911					 ; Kernel keyboard Que,	the first byte holds the pointer
   3912	    0308  FF*(00)		 KKQ		 DB 255	dup(0)
   3913	    0407  00			 KHead		 DB 0	 ; next	byte
   3914	    0408  00			 KTail		 DB 0	 ; next	available byte
   3915					 ; Memory parameters required in AOA
   3916	    0409  10000000		 MEMLimit	 dd	 10000000h  ; Max Limit	of memory allocation 64MB
   3917	    040D  02000000		 MEMBase	 dd	 02000000h  ; Base start of memory for allocation 32MB
   3918	    0411  0000			 MEMCX		 dw	 0
   3919	    0413  ????????		 APP1TSSAddr	 dd	 ?	    ; This is the address of the task segment
   3920
   3921	    0417  0000			 SLSecNum1mS	 dw	 0
   3922	    0419  0000			 LSize1mS	 dw	 0
   3923	    041B  00000000		 BxP1S		 dd	 0
   3924					 ; user	does Malloc() once and gets total size of memory available and mem ptr
   3925					 ;
   3926					 ;----------------------------------------------------------------------------
   3927	    041F			 RDataSeg	 ENDS
   3928					 ;***************************************************************************
   3929					 ;RCodeSeg Segment
   3930					 ; 16 bit segment
   3931					 ;  all	real code procedures must be placed in this segment
   3932					 ;***************************************************************************
   3933					 ;
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 70
prcycle.ASM



   3934	    0000			 RCodeSeg	 SEGMENT PARA public USE16 'CODE'
   3935							 ASSUME	 CS:RCodeSeg,DS:RDataSeg
   3936					 ;----------------------------------------------------------------------------
   3937					 ; START of prcycle here
   3938					 ; Watch out IDT and 256 interrupts, make sure they are	coded right in the
   3939					 ;   segment, otherwise, LIDT will fail
   3940					 ;----------------------------------------------------------------------------
   3941	    0000			 Start		 PROC
   3942
   3943	    0000  B8 0000s				 mov	 ax,RDataSeg
   3944	    0003  05 0080				 add	 ax,RELOCATE1
   3945	    0006  8E D8					 mov	 ds,ax
   3946	    0008  B0 59					 mov	 al,'Y'
   3947	    000A  B4 0E					 mov	 ah,14
   3948	    000C  CD 10					 int	 10h
   3949
   3950						     ;********************************************************
   3951							 ; get the NIC device address and store	it in shared memory
   3952							 ; this	has to be done only in real mode
   3953						     ;********************************************************
   3954	    000E  B4 B1					 mov ah, 0b1h	 ; function  PCI BIOS p23
   3955	    0010  B0 02					 mov al, 02h	 ; find	PCI device PCI BIOS p23
   3956							 ;3com
   3957							 ;mov cx, 9200h	 ; device id p71
   3958							 ;mov dx, 10b7h	  ; subsystem vendor id	p71
   3959							 ; intel
   3960	    0012  B9 100E				 mov cx, 100eh
   3961	    0015  BA 8086				 mov dx, 8086h
   3962	    0018  BE 0000				 mov si, 0
   3963	    001B  CD 1A					 int 1ah	 ; calls PCI BIOS interrupt
   3964	    001D  72 04					 jc carry1	 ; error
   3965	    001F  32 C9					 xor cl, cl	 ; good
   3966	    0021  EB 02					 jmp next100
   3967	    0023					 carry1:
   3968	    0023  B1 01					 mov cl, 1	 ; cl is 1 or 0
   3969	    0025					 next100:
   3970	    0025  66| 8B C3				 mov eax,ebx;
   3971	    0028  66| C1 E0 10				 sal eax, 16	 ; move	to left
   3972	    002C  8A D9					 mov bl, cl
   3973	    002E  8B C3					 mov ax, bx
   3974							 ; eax has the following data
   3975							 ;----------------------
   3976							 ; BH |	 BL | AH | CL
   3977							 ; bus no | device no in 5 bits	| return code |	0 - success 1 -fail
   3978							 ;----------------------
   3979	    0030  66| C1 F8 10				 sar eax, 16
   3980	    0034  66| BB 00000000			 mov ebx, 0
   3981	    003A  66| 8B D8				 mov ebx, eax	; bh, bl has bus no and	device no
   3982
   3983	    003D  66| B8 00000000			 mov eax, 0
   3984	    0043  B4 B1					 mov ah, 0b1h  ; function  PCI BIOS p23
   3985	    0045  B0 0A					 mov al, 0ah   ; read config dword p19 PCI
   3986							 ;3com
   3987							 ;mov di, 10h	; offset 10h p/65
   3988							 ; intel
   3989	    0047  BF 0018				 mov di, 18h
   3990	    004A  CD 1A					 int 01ah      ; calls PCI BIOS	interrupt
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 71
prcycle.ASM



   3991	    004C  66| 8B C1				 mov eax, ecx
   3992	    004F  66| 81 E1 0000FFFE			 and ecx, 0fffeh	; make the last	bit zero
   3993	    0056  66| 8B C1				 mov eax, ecx		; this is the device address
   3994
   3995	    0059  1E					 push ds
   3996	    005A  66| 50				 push eax
   3997	    005C  B8 0000				 mov ax, 0
   3998	    005F  8E D8					 mov ds, ax
   3999
   4000	    0061  66| BB 00008600			 mov ebx, S_Base
   4001	    0067  66| 81 C3 0000009C			 add ebx, S_IOBASE
   4002	    006E  66| 58				 pop eax
   4003	    0070  66| 67| 89 03				 mov DWORD PTR ds:[ebx], eax  ;	store it in shared memory
   4004	    0074  1F					 pop ds
   4005
   4006							 ;mov eax, 0
   4007							 ;mov eax, DWORD PTR es:[ebx]
   4008							 ;CALL PUTHEX32R ; prints the value in EAX
   4009							 ;mov al, ' ';	  ; print a blank
   4010							 ;mov ah, 14
   4011							 ;int 10h
   4012
   4013							 ;********************************************************
   4014							 ; Store Task Segment of Appliation in memory
   4015							 ; which can be	used by	AO for task switching
   4016	    0075  66| B8 00000000s			 mov	 eax,SEG App1TSSSeg	 ; get the segment addtess of APP1TSSSeg
   4017	    007B  66| 05 00000080			 add	 eax, RELOCATE1
   4018	    0081  66| C1 E0 04				 shl	 eax, 4			 ; then	convert	that into a pointer with the+
   4019					 lower 16 bit offset
   4020	    0085  66| A3 0413r				 mov	 ds:[APP1TSSAddr], eax
   4021							 ;********************************************************
   4022
   4023							 ;KAR_________________________________________________________
   4024							 ;mov	 eax,SEG RDataSeg
   4025							 ;add	 eax,RELOCATE1
   4026							 ;shl	 eax,4
   4027	    0089  66| B8 00000000r			 mov	 eax,OFFSET GDT	 ; Get the offset of GDT starting entry	to be used  +
   4028					 by setand getGDTEntry
   4029	    008F  66| A3 01DFr				 mov	 ds:[AppGDTPtr], eax
   4030							 ;____________________________________________________________
   4031							 EnableA20
1  4032	    0093  50					 push	 ax
1  4033	    0094  E4 92					 in	 al,92h
1  4034	    0096  0C 02					 or	 al,00000010b
1  4035	    0098  E6 92					 out	 92h,al
1  4036	    009A  58					 pop	 ax
   4037	    009B  FC					 cld
   4038
   4039	    009C  E8 00B7				 CALL	 InitGDT
   4040	    009F  E8 0113				 call	 InitIDT
   4041
   4042	    00A2  8C 16	019Br				 mov	 SSVar,ss
   4043	    00A6  89 26	0199r				 mov	 SPVar,sp
   4044	    00AA  0F 01	0E 0192r			 sidt	 QWORD PTR NORVIDTR
   4045	    00AF  E4 21					 in	 al,IMREGP
   4046	    00B1  A2 0198r				 mov	 BYTE PTR IMaskRegV,al
   4047
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 72
prcycle.ASM



   4048	    00B4  B8 0000s				 mov	 ax,App1LDTSeg ; APP1 LDT Seg Address
   4049	    00B7  05 0080				 add	 ax, RELOCATE1 ; add relocate
   4050	    00BA  8E E0					 mov	 fs,ax	       ; fs has	the LDT	Segment
   4051	    00BC  B9 0007				 mov	 cx,App1LDNum  ; no of entries to be loaded in LDT
   4052	    00BF  BE 0000r				 mov	 si,OFFSET ALDT; offset	of first entry
   4053
   4054	    00C2  E8 00D5				 CALL	 InitLDT       ; load APP1 LDT entries
   4055					 ;------------------------------------------------------
   4056					 ; add RELOCATE1 as the	booter located this code at
   4057					 ; a different location, for example at	0800h
   4058					 ; so the segment value	in that	case is	at 80h
   4059					 ;------------------------------------------------------
   4060	    00C5  B8 0000s				 mov	 ax,GKeyLDTSeg
   4061	    00C8  05 0080				 add	 ax, RELOCATE1
   4062	    00CB  8E E0					 mov	 fs,ax
   4063	    00CD  B9 0002				 mov	 cx,GKeyLDNum
   4064	    00D0  BE 0000r				 mov	 si,OFFSET GLDT
   4065
   4066	    00D3  E8 00C4				 CALL	 InitLDT
   4067					 ;------------------------------------------------------
   4068	    00D6  B8 0000s				 mov	 ax,GetCharLDTSeg
   4069	    00D9  05 0080				 add	 ax, RELOCATE1
   4070	    00DC  8E E0					 mov	 fs,ax
   4071	    00DE  B9 0002				 mov	 cx,GetCharLDNum
   4072	    00E1  BE 0000r				 mov	 si,OFFSET CLDT
   4073
   4074	    00E4  E8 00B3				 CALL	 InitLDT
   4075					 ;------------------------------------------------------
   4076	    00E7  B8 0000s				 mov	 ax,GetDecLDTSeg
   4077	    00EA  05 0080				 add	 ax, RELOCATE1
   4078	    00ED  8E E0					 mov	 fs,ax
   4079	    00EF  B9 0002				 mov	 cx,GetDecLDNum
   4080	    00F2  BE 0000r				 mov	 si,OFFSET DLDT
   4081
   4082	    00F5  E8 00A2				 CALL	 InitLDT
   4083					 ;------------------------------------------------------
   4084	    00F8  B8 0000s				 mov	 ax,GetSecLDTSeg
   4085	    00FB  05 0080				 add	 ax, RELOCATE1
   4086	    00FE  8E E0					 mov	 fs,ax
   4087	    0100  B9 0002				 mov	 cx,GetSecLDNum
   4088	    0103  BE 0000r				 mov	 si,OFFSET KLDT
   4089
   4090	    0106  E8 0091				 CALL	 InitLDT
   4091					 ;------------------------------------------------------
   4092	    0109  B8 0000s				 mov	 ax,DemoLDTSeg
   4093	    010C  05 0080				 add	 ax, RELOCATE1
   4094	    010F  8E E0					 mov	 fs,ax
   4095	    0111  BE 0000r				 mov	 si,OFFSET DemoLDT
   4096	    0114  B9 000C				 mov	 cx,DemoLDNum
   4097	    0117  E8 0080				 CALL	 InitLDT
   4098					 ;------------------------------------------------------
   4099	    011A  B8 0000s				 mov	 ax,SearchLDTSeg
   4100	    011D  05 0080				 add	 ax, RELOCATE1
   4101	    0120  8E E0					 mov	 fs,ax
   4102	    0122  BE 0000r				 mov	 si,OFFSET SEARCHLDTS
   4103	    0125  B9 0004				 mov	 cx,SearchLDNum
   4104	    0128  E8 006F				 CALL	 InitLDT
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 73
prcycle.ASM



   4105
   4106					 ;------------------------------------------------------
   4107					 ; GDT table must be located in	real memory
   4108					 ;  we tried to	place it at 0200 0000 and we were
   4109					 ;  not	able to	change the Base	value in GDTR
   4110					 ; setup all GDT related things	before switching to
   4111					 ;  protected mode 4-9-04
   4112					 ;------------------------------------------------------
   4113	    012B  0F 01	16 0186r			 lgdt	 QWORD PTR VGDTR ;load GDT reg
   4114
   4115
   4116					 ; 6 byte VGDTR	is loaded into visible part of the GDTR	registerr
   4117					 ; The contents	of VGDTR was set up by InitGDT call
   4118					 ;------------------------------------------------------
   4119	    0130  FA					 cli
   4120	    0131  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4121	    0136  0F 20	C0				 mov	 eax,cr0
   4122	    0139  0C 01					 or	 al,1
   4123	    013B  0F 22	C0				 mov	 cr0,eax   ; turn on prot mode bit
   4124					 ;----------------------------------------------------------
   4125							 JUMP16	 <TempCode_Sel>,<OFFSET	Virtual> ; I
1  4126	    013E  EA					 DB	 0eah
1  4127	    013F  01EBr					 DW	 OFFSET	Virtual
1  4128	    0141  0030					 DW	 TempCode_Sel
   4129					 ;----------------------------------------------------------
   4130					 ;This jump is required	to switch to protection	mode
   4131					 ; It will load	CS and EIP values during this long jump
   4132					 ; It uses TempCode_Sel	descriptor to jump
   4133					 ; You will not	go below this step until you return from
   4134					 ; protection mode to exit from	the program
   4135					 ;------------------------------------------------------
   4136
   4137	    0143  B8 0000s		 Real:		 mov	 ax,RDataSeg
   4138	    0146  05 0080				 add	 ax, RELOCATE1
   4139	    0149  8E D8					 mov	 ds,ax
   4140	    014B  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4141	    0150  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4142	    0155  FB					 sti
   4143
   4144	    0156			 Start		 ENDP
   4145					 ;***************************************************************************
   4146					 ;InitGDT Procedure
   4147					 ;  Initialize all GDT entries
   4148					 ;***************************************************************************
   4149
   4150	    0156			 InitGDT	 PROC
   4151	    0156  B9 0028				 mov	 cx,GDNum ; no of entries to be	loaded into GDT	ex 28
   4152	    0159  BE 0018r				 mov	 si,OFFSET EFFGDT ;starting location of	first entry
   4153
   4154
   4155
   4156	    015C  B8 0000		 InitG:		 mov	 ax,0
   4157	    015F  8A 64	07				 mov	 ah, BYTE PTR[si].BaseH
   4158	    0162  8A 44	04				 mov	 al, BYTE PTR[si].BaseM
   4159	    0165  3D 0000				 cmp	 ax,0
   4160	    0168  75 19					 JNZ	 SKIPCHANGE
   4161	    016A  8B 44	02				 mov	 ax,[si].BaseL
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 74
prcycle.ASM



   4162	    016D  66| 0F B7 C0				 movzx	 eax,ax
   4163	    0171  66| C1 E0 04				 shl	 eax,4
   4164	    0175  66| 0F A4 C2 10			 shld	 edx,eax,16   ;	0002 --> 0200 8	bytes alltogether
   4165	    017A  89 44	02				 mov	 WORD PTR [si].BaseL,ax	; 2 bytes
   4166	    017D  88 54	04				 mov	 BYTE PTR [si].BaseM,dl	; 1 byte
   4167	    0180  88 74	07				 mov	 BYTE PTR [si].BaseH,dh	; 1 byte
   4168
   4169
   4170	    0183  83 C6	08		 SKIPCHANGE:	 add	 si,SIZE Desc
   4171	    0186  E2 D4					 loop	 InitG
   4172
   4173	    0188  BA 0000				 mov	 dx,0h
   4174	    018B  BB 0010				 mov	 bx,16
   4175	    018E  8C D8					 mov	 ax,ds
   4176	    0190  F7 E3					 mul	 bx
   4177	    0192  A3 0188r				 mov	 WORD PTR VGDTR.Base,ax	; lower	2 byte GDT base	address	is stored in+
   4178					 VGDTR 4eb0
   4179	    0195  89 16	018Ar				 mov	 WORD PTR VGDTR.Base+2,dx ; higher 2 byte GDT base address is stored+
   4180					 in VGDTR 0000
   4181	    0199  C3					 ret
   4182	    019A			 InitGDT	 ENDP
   4183					 ;***************************************************************************
   4184					 ;InitLDT Procedure
   4185					 ;  Initialize all LDT entries
   4186					 ;  rearraning the BaseL bytes
   4187					 ; It does not modify BaseH and	BaseM
   4188					 ; It is also rearranging the bytes in the same	segment	in memory
   4189					 ; It does not modify BaseH and	BaseM
   4190					 ; It is also rearranging the bytes in the same	segment	in memory
   4191					 ;***************************************************************************
   4192	    019A			 InitLDT	 PROC
   4193	    019A  64: 8B 44 02		 ILDT:		 mov	 ax,WORD PTR FS:[si].BaseL
   4194	    019E  66| 0F B7 C0				 movzx	 eax,ax
   4195	    01A2  66| C1 E0 04				 shl	 eax,4
   4196	    01A6  66| 0F A4 C2 10			 shld	 edx,eax,16
   4197	    01AB  64: 89 44 02				 mov	 WORD PTR fs:[si].BaseL,ax
   4198							 ;the following	two lines insert 0s in BaseM and BaseH
   4199							 ;  base L is shifted because we only put one digit less in this field
   4200							 ; inorder to use above	1M we should comment the following two lines
   4201						 ;	 mov	 BYTE PTR fs:[si].BaseM,dl
   4202						 ;	 mov	 BYTE PTR fs:[si].BaseH,dh
   4203	    01AF  83 C6	08				 add	 si,SIZE Desc
   4204	    01B2  E2 E6					 loop	 ILDT
   4205	    01B4  C3					 ret
   4206	    01B5			 InitLDT	 ENDP
   4207					 ;***************************************************************************
   4208					 ;InitIDT Procedure
   4209					 ; Initialize all interrupt descriptor table entries
   4210					 ;***************************************************************************
   4211	    01B5			 InitIDT	 PROC
   4212	    01B5  BB 0010				 mov	 bx,16
   4213	    01B8  B8 0000s				 mov	 ax, IDTSeg
   4214	    01BB  05 0080				 add	 ax, RELOCATE1
   4215	    01BE  F7 E3					 mul	 bx
   4216	    01C0  A3 018Er				 mov	 WORD PTR VIDTR.Base,ax
   4217
   4218					 ;-----------------------------------------------------------------------------
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 75
prcycle.ASM



   4219					 ; This	part of	the code stores	the absolute address of	IDT in shared memory
   4220
   4221	    01C3  66| 53				 push	 ebx
   4222						 ;RKK COMMENT EXTRA PUSH
   4223							 ;push	 es
   4224	    01C5  66| 50				 push	 eax
   4225
   4226	    01C7  66| BB 00000000			 mov	 ebx,0
   4227	    01CD  B8 8600				 mov	 ax, S_Base
   4228	    01D0  05 000C				 add	 ax, S_IDTOffset
   4229	    01D3  8B D8					 mov	 bx ,ax
   4230	    01D5  B8 0000				 mov	 ax, 0
   4231	    01D8  8E C0					 mov	 es, ax
   4232	    01DA  66| 58				 pop	 eax
   4233	    01DC  26: 67| 89 03				 mov	 WORD PTR es:[ebx], ax
   4234	    01E0  26: 67| 8B 03				 mov	 ax, WORD PTR es:[ebx]
   4235	    01E4  66| 5B				 pop	 ebx
   4236					 ;-----------------------------------------------------------------------------
   4237	    01E6  89 16	0190r				 mov	 WORD PTR VIDTR.Base+2,dx
   4238	    01EA  C3					 ret
   4239	    01EB			 InitIDT	 ENDP
   4240					 ;***************************************************************************
   4241					 ;Virtual Procedure
   4242					 ;  entry point	to protected mode
   4243					 ;***************************************************************************
   4244					 ;  I.	It is invoked from real	mode after mode	bit is set as a	long jump
   4245					 ;  This is the	first stage after protected mode bit is	set
   4246					 ;
   4247	    01EB			 Virtual	 PROC	 FAR
   4248	    01EB  B8 0020				 mov	 ax,DemoTSS_Sel
   4249	    01EE  0F 00	D8				 ltr	 ax  ; load task register
   4250	    01F1  B8 0028				 mov	 ax,DemoLDT_Sel	; load LDTR register
   4251	    01F4  0F 00	D0				 lldt	 ax
   4252					 ;--------------------------------------------------------------------
   4253							 JUMP16	 ToT32A_Sel,0	 ;II. Jump to Prot Mode	Seg
1  4254	    01F7  EA					 DB	 0eah
1  4255	    01F8  0000					 DW	 0
1  4256	    01FA  0064					 DW	 ToT32A_Sel
   4257										 ; T32Code_Sel and T32Begin
   4258					 ;--------------------------------------------------------------------
   4259					 ; This	jump is	from 16	bit to 32 bit segments using a call gate
   4260					 ; once	this jump occurs, then you are in 32 bit protected mode
   4261					 ; The following step will not be reached from here
   4262					 ;--------------------------------------------------------------------
   4263					 ;  V. The following code will be executed when	the program returns
   4264					 ;    from protected mode on its way to	real mode
   4265					 ;    this is at 16 bit	protected mode
   4266					 ;    application calls	can be made
   4267					 ;--------------------------------------------------------------------
   4268	    01FC			 ToReal:
   4269	    01FC			 loop1:				  ;interrupt takes us to AoA menu and
   4270	    01FC  FB					 sti
   4271
   4272	    01FD  CD FF					 int	 0ffh	  ; go to menu interrupt
   4273	    01FF  66| BB 00000F9E			 mov	 ebx,3998
   4274	    0205  B0 50					 mov	 al,'P'
   4275	    0207  CD F7					 int	 0f7h
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 76
prcycle.ASM



   4276
   4277	    0209  B8 0054				 mov	 ax,RealData_Sel
   4278	    020C  8E E0					 mov	 fs,ax
   4279
   4280	    020E  64: 80 3E 01D6r 05			 cmp	 fs:[MemFlag], 5
   4281	    0214  74 44					 je	 GoSearch
   4282
   4283	    0216  64: 80 3E 01D6r 01			 cmp	 fs:[MemFlag],1
   4284	    021C  74 46					 je	 PrintMemory
   4285
   4286	    021E  64: 80 3E 0000e 01			 cmp	 fs:[LoadFlag],1
   4287	    0224  75 2F					 jne	 RunApplications
   4288
   4289	    0226			 LoadApplications:
   4290	    0226  E8 045A				 CALL	 InitLoad
   4291							 ;--------------------------------------------------------
   4292	    0229  06					 push	 es
   4293							 ; save	start sector, number of	sectors	and address offset
   4294	    022A  B8 0054				 mov	 ax,RealData_Sel
   4295	    022D  8E C0					 mov	 es,ax
   4296
   4297	    022F  66| B8 00000000			 mov	 eax, 0
   4298	    0235  26: A1 0000e				 mov	 ax, es:[StartLogicalSecNum1m] ; start sector
   4299	    0239  26: A3 0417r				 mov	 es:[SLSecNum1mS], ax
   4300
   4301	    023D  26: A1 0000e				 mov	 ax, es:[LoaderSize1m] ; number	of sectors
   4302	    0241  26: A3 0419r				 mov	 es:[LSize1mS],	ax
   4303
   4304	    0245  66| 26: A1 0000e			 mov	 eax, es:[BxPointer1] ;	address	offset
   4305	    024A  66| 26: A3 041Br			 mov	 es:[BxP1S], eax
   4306
   4307	    024F  07					 pop	 es
   4308							 ;--------------------------------------------------------
   4309
   4310	    0250  E8 0303				 CALL	 ReadSectorsAll	; read all sectors if flag is set
   4311										; loads	application disk into memory
   4312	    0253  EB A7					 jmp	 loop1
   4313	    0255			 RunApplications:
   4314							 ;---------------------------------------------
   4315							 ;KAR Sample to	test if	the GDT	can be moved to	Data Segment of	APP
   4316							 ; APP1TSSAddr location	has the	address	of App1TSS segment
   4317							 ;KAREND
   4318							 ;---------------------------------------------
   4319
   4320	    0255  E8 048D				 CALL	 RunAppl
   4321	    0258  EB 20					 jmp	 GoBackToLoop
   4322	    025A			 GoSearch:
   4323	    025A  CD F8					 int	 0f8h
   4324	    025C  64: C6 06 01D6r 00			 mov	 fs:[MemFlag], 0
   4325	    0262  EB 98					 jmp	 loop1
   4326
   4327	    0264			 PrintMemory:
   4328	    0264  66| B8 00000000			 mov	 eax,0
   4329	    026A  66| 64: A1 01D7r			 mov	 eax,fs:[MemoryOffset] ; memory	dump option 9
   4330							 CALL16	 PrintmemPGate_Sel,0h
1  4331	    026F  9A					 DB	 9ah
1  4332	    0270  0000					 DW	 0h
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 77
prcycle.ASM



1  4333	    0272  0084					 DW	 PrintmemPGate_Sel
   4334	    0274  64: 80 26 01D6r 00			 and	 fs:[MemFlag],0
   4335	    027A			 GoBackToLoop:
   4336					 ;--------------------------------------------------------------------
   4337						 JUMP16	 ToT32A_Sel,0	 ;  II.	Jump to	Protected Mode Seg
1  4338	    027A  EA					 DB	 0eah
1  4339	    027B  0000					 DW	 0
1  4340	    027D  0064					 DW	 ToT32A_Sel
   4341									 ; T32Code_Sel and T32Begin
   4342					 ;--------------------------------------------------------------------
   4343					 ; Steps II and	V are our P-R cycle loop
   4344					 ; Step	II takes it to protected mode and when it is done it
   4345					 ; comes back to step V.
   4346					 ;--------------------------------------------------------------------
   4347					 ;--------------------------------------------------------------------
   4348					 ;We would never go beyond this	point unless we	comment	P-R cycle loop
   4349					 ;By doing so you would	return to real mode and	print 'Z'
   4350					 ;--------------------------------------------------------------------
   4351	    027F  B8 0008				 mov	 ax,Normal_Sel
   4352	    0282  8E D8					 mov	 ds,ax
   4353	    0284  8E C0					 mov	 es,ax
   4354	    0286  8E E0					 mov	 fs,ax
   4355	    0288  8E E8					 mov	 gs,ax
   4356	    028A  8E D0					 mov	 ss,ax
   4357
   4358							 ;cli
   4359	    028C  0F 20	C0				 mov	 eax,cr0
   4360	    028F  24 FE					 and	 al,11111110b
   4361	    0291  0F 22	C0				 mov	 cr0,eax
   4362							 JUMP16	 <SEG Real+RELOCATE1>,<OFFSET Real>
1  4363	    0294  EA					 DB	 0eah
1  4364	    0295  0143r					 DW	 OFFSET	Real
1  4365	    0297  0080s					 DW	 SEG Real+RELOCATE1
   4366
   4367	    0299			 Virtual	 ENDP
   4368					 ;***************************************************************************
   4369					 ;GetCharBegin Procedure
   4370					 ;***************************************************************************
   4371	    0299			 GetCharBegin	 PROC	 FAR
   4372
   4373
   4374	    0299  1E					 push	 ds
   4375	    029A  06					 push	 es
   4376	    029B  0F A0					 push	 fs
   4377	    029D  0F A8					 push	 gs
   4378	    029F  B8 0008				 mov	 ax,Normal_Sel
   4379	    02A2  8E D0					 mov	 ss,ax
   4380	    02A4  0F 20	C0				 mov	 eax,cr0
   4381	    02A7  24 FE					 and	 al,11111110b
   4382	    02A9  0F 22	C0				 mov	 cr0,eax     ; set the control register
   4383							 JUMP16	 <Seg GetChar+RELOCATE1>,<OFFSET GetChar>  ;SWITCH TO REAL MODE
1  4384	    02AC  EA					 DB	 0eah
1  4385	    02AD  02B1r					 DW	 OFFSET	GetChar
1  4386	    02AF  0080s					 DW	 Seg GetChar+RELOCATE1
   4387
   4388	    02B1			 GetChar:
   4389	    02B1  B8 0000s				 mov	 ax,RDataSeg
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 78
prcycle.ASM



   4390	    02B4  05 0080				 add	 ax, RELOCATE1
   4391	    02B7  8E D8					 mov	 ds,ax
   4392	    02B9  66| 8B EC				 mov	 ebp,esp
   4393	    02BC  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4394	    02C1  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4395	    02C6  FB					 sti
   4396
   4397					 ;------------------------------------------------------------------------
   4398					 ;We are returned to RealMode from ProtMode include all	RMode code here...
   4399					 ;------------------------------------------------------------------------
   4400	    02C7  B8 0000s				 mov	 ax,GlobalDataSeg
   4401	    02CA  05 0080				 add	 ax,RELOCATE1
   4402	    02CD  8E E0					 mov	 fs,ax
   4403	    02CF			 GetChar1:
   4404
   4405	    02CF  B4 10					 mov	 ah,10h
   4406	    02D1  CD 16					 int	 16h	 ;bios interrupt to get	char from console
   4407
   4408					 ;------------------------------------------------------------------------
   4409					 ;To display character at the same position
   4410					 ;------------------------------------------------------------------------
   4411	    02D3  B4 0E					 mov	 ah,14
   4412	    02D5  CD 10					 int	 10h	 ; to display the char at the same position
   4413
   4414	    02D7  64: A2 000Br				 mov	 fs:[StoreChar],al
   4415							 ;cli					  ;SWITCH TO PM
   4416
   4417	    02DB  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4418	    02E0  0F 20	C0				 mov	 eax,cr0
   4419	    02E3  0C 01					 or	 al,1
   4420	    02E5  0F 22	C0				 mov	 cr0,eax
   4421
   4422							 JUMP16	 <GetCharCode_Sel>,<OFFSET GetCharV> ;TO PROTECTED MODE
1  4423	    02E8  EA					 DB	 0eah
1  4424	    02E9  02EDr					 DW	 OFFSET	GetCharV
1  4425	    02EB  0004					 DW	 GetCharCode_Sel
   4426
   4427	    02ED			 GetCharV:
   4428	    02ED  B8 000C				 mov	 ax,GetCharStack_Sel
   4429	    02F0  8E D0					 mov	 ss,ax
   4430	    02F2  66| 8B E5				 mov	 esp,ebp
   4431	    02F5  0F A9					 pop	 gs
   4432	    02F7  0F A1					 pop	 fs
   4433	    02F9  07					 pop	 es
   4434	    02FA  1F					 pop	 ds
   4435
   4436	    02FB  66| CF				 iretd
   4437	    02FD  EB 9A					 jmp	 GetCharBegin
   4438	    02FF			 GetCharBegin	    ENDP
   4439					 ;***************************************************************************
   4440					 ;GetDecBegin Procedure
   4441					 ;***************************************************************************
   4442	    02FF			 GetDecBegin	PROC	FAR
   4443	    02FF  1E					 push	 ds
   4444	    0300  06					 push	 es
   4445	    0301  0F A0					 push	 fs
   4446	    0303  0F A8					 push	 gs
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 79
prcycle.ASM



   4447	    0305  B8 0008				 mov	 ax,Normal_Sel
   4448	    0308  8E D0					 mov	 ss,ax
   4449	    030A  0F 20	C0				 mov	 eax,cr0
   4450	    030D  24 FE					 and	 al,11111110b
   4451	    030F  0F 22	C0				 mov	 cr0,eax
   4452
   4453							 JUMP16	 <Seg GetDec+RELOCATE1>,<OFFSET	GetDec>	 ;SWITCH TO REAL MODE
1  4454	    0312  EA					 DB	 0eah
1  4455	    0313  0317r					 DW	 OFFSET	GetDec
1  4456	    0315  0080s					 DW	 Seg GetDec+RELOCATE1
   4457	    0317			 GetDec:
   4458
   4459	    0317  B8 0000s				 mov	 ax,RDataSeg
   4460	    031A  05 0080				 add	 ax, RELOCATE1
   4461	    031D  8E D8					 mov	 ds,ax
   4462	    031F  66| 8B EC				 mov	 ebp,esp
   4463	    0322  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4464	    0327  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4465	    032C  FB					 sti
   4466					 ;------------------------------------------------------------------------
   4467					 ;We are returned to RealMode from ProtMode include all	RMode code here...
   4468					 ;------------------------------------------------------------------------
   4469	    032D  B8 0000s				 mov	 ax,GlobalDataSeg
   4470	    0330  05 0080				 add	 ax,RELOCATE1
   4471	    0333  8E E0					 mov	 fs,ax
   4472	    0335			 GetDec1:
   4473	    0335  66| 53				 PUSH	 EBX
   4474	    0337  66| 51				 PUSH	 ECX
   4475	    0339  66| 33 DB				 XOR	 EBX,EBX	 ; EBX=0
   4476	    033C  66| B9 0000000A			 MOV	 ECX,0ah	 ; ECX=10
   4477	    0342			 GetNextDigit_getint:
   4478	    0342  B4 10					 MOV	 AH, 10h	 ; function 10h: Waits for keyboard input
   4479	    0344  CD 16					 INT	 16h		 ; get input from keyboard
   4480
   4481	    0346  66| 50				 PUSH	 EAX		 ; displays "char-by-char"
   4482	    0348  B4 0E					 mov	 ah,14		 ; the integer being input by user
   4483	    034A  CD 10					 int	 10h
   4484	    034C  66| 58				 POP	 EAX
   4485
   4486	    034E  66| 53				 push	 ebx
   4487	    0350  2C 30					 SUB	 AL,'0'		 ; ASCII[0..9] -> DIGIT[0..9]
   4488	    0352  8A D8					 mov	 bl, al
   4489	    0354  66| 33 C0				 xor	 eax,eax
   4490	    0357  8A C3					 mov	 al, bl
   4491	    0359  3C 0D					 cmp	 al, 0dh
   4492	    035B  74 18					 je	 exit_getint32
   4493	    035D  66| 5B				 pop	 ebx
   4494
   4495						 ; CL holds integer "10", when encounter either	"return"
   4496						 ; or other characters all cause mov ax, bx
   4497
   4498	    035F  3A C1					 CMP	 AL,CL
   4499	    0361  73 0A					 JAE	 NotDigit_getint ; if there is new integer from	keyboard, SWAP AX,BX
   4500
   4501	    0363  66| 93				 xchg	 ebx, eax
   4502	    0365  66| F7 E1				 MUL	 ECX		 ; EAX=EAX*10
   4503	    0368  66| 03 D8				 add	 ebx, eax
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 80
prcycle.ASM



   4504	    036B  EB D5					 JMP	 GetNextDigit_getint
   4505	    036D			 NotDigit_getint:
   4506	    036D  66| 8B C3				 mov	 eax, ebx
   4507	    0370  66| 64: A3 000Cr			 mov	 fs:[StoreDec],eax
   4508							 ; store the read integer value	in real	memory segment
   4509							 ;   where data	is stored
   4510
   4511	    0375			 exit_getint32:
   4512	    0375  66| 59				 POP	 ECX
   4513	    0377  66| 5B				 POP	 EBX
   4514
   4515							 ;cli					  ;SWITCH TO PM
   4516	    0379  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4517	    037E  0F 20	C0				 mov	 eax,cr0
   4518	    0381  0C 01					 or	 al,1
   4519	    0383  0F 22	C0				 mov	 cr0,eax
   4520
   4521							 JUMP16	 <GetDecCode_Sel>,<OFFSET GetDecV> ;TO PROTECTED MODE
1  4522	    0386  EA					 DB	 0eah
1  4523	    0387  038Br					 DW	 OFFSET	GetDecV
1  4524	    0389  0004					 DW	 GetDecCode_Sel
   4525
   4526	    038B			 GetDecV:
   4527	    038B  B8 000C				 mov	 ax,GetDecStack_Sel
   4528	    038E  8E D0					 mov	 ss,ax
   4529	    0390  66| 8B E5				 mov	 esp,ebp
   4530	    0393  0F A9					 pop	 gs
   4531	    0395  0F A1					 pop	 fs
   4532	    0397  07					 pop	 es
   4533	    0398  1F					 pop	 ds
   4534	    0399  66| CF				 iretd
   4535	    039B  E9 FF61				 jmp	 GetDecBegin
   4536	    039E			 GetDecBegin	   ENDP
   4537					 ;***************************************************************************
   4538					 ;GKeyBegin Procedure
   4539					 ;***************************************************************************
   4540	    039E			 GKeyBegin	 PROC	 FAR
   4541
   4542	    039E  1E					 push	 ds
   4543	    039F  06					 push	 es
   4544	    03A0  0F A0					 push	 fs
   4545	    03A2  0F A8					 push	 gs
   4546					 ;********************************************
   4547					 ;printing in protected	mode and getting a charectar in	Pmode.
   4548					 ;		 mov	 eax,0h
   4549					 ;		 mov	 eax,12345678h
   4550					 ;		 mov	 ebx,800h	 ;display position on screen
   4551					 ;		 int	 0fdh		 ;PUTHEX32P interrupt gate
   4552					 ;		 int	 0fch		 ;get charectar	from keyboard interrupt	gate
   4553					 ;********************************************
   4554
   4555	    03A4  B8 0008				 mov	 ax,Normal_Sel
   4556	    03A7  8E D0					 mov	 ss,ax
   4557	    03A9  0F 20	C0				 mov	 eax,cr0
   4558	    03AC  24 FE					 and	 al,11111110b
   4559	    03AE  0F 22	C0				 mov	 cr0,eax
   4560					 ;************************************************
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 81
prcycle.ASM



   4561					 ; when	we jump	from protected mode to real mode,
   4562					 ;   we	should keep CS value 0000h and place the
   4563					 ;   offset in the jump, otherwise, in real mode
   4564					 ; if CS value is not zero, we could have problems
   4565					 ;   with calls	and other stuff
   4566					 ; this	assumes	that in	real mode, we will stay	within
   4567					 ;    one segment that is, 64k code
   4568					 ;************************************************
   4569	    03B1  B8 0000s				 mov	 ax,RDataSeg	  ; set	up dataseg
   4570	    03B4  05 0080				 add	 ax, RELOCATE1
   4571	    03B7  8E D8					 mov	 ds,ax
   4572					 ; we do not use this jump as we need to set CS	to 0h
   4573					 ;CS and IP will be loaded with	the below jump
   4574					 ;		 JUMP16	 <Seg GetKey+RELOCATE1>,<OFFSET	GetKey>	 ;SWITCH TO REAL MODE
   4575					 ; compute the address to be jumped in real mode as follows
   4576					 ;
   4577	    03B9  66| B8 00000000			 mov	 eax,0h
   4578	    03BF  B8 0000s				 mov	 ax,seg	Getkey ; segment value
   4579	    03C2  C1 E0	04				 shl	 ax,4	       ; shift left 4 bits
   4580	    03C5  05 0800				 add	 ax,800h       ; start of code for real	code 600+200 PSP
   4581	    03C8  05 03D2r				 add	 ax,offset GetKey ; offset for this label within real code
   4582	    03CB  A3 0172r				 mov	 [RealJumpAddr],ax ; store the value in	real data segment
   4583	    03CE  FF 2E	0172r				 JMP	 dword ptr [RealJumpAddr] ; long jump CS:IP
   4584	    03D2			 GetKey:
   4585
   4586	    03D2  66| 8B EC				 mov	 ebp,esp
   4587	    03D5  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4588	    03DA  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4589	    03DF  FB					 sti
   4590					 ;------------------------------------------------------------------------
   4591					 ;We are returned to RealMode from ProtMode include all	RMode code here...
   4592					 ;------------------------------------------------------------------------
   4593	    03E0			 GetKey1:
   4594
   4595	    03E0  66| BE 0000019Fr			 mov	 esi,offset prompt1
   4596	    03E6  E8 0000e				 call	 WriteString
   4597	    03E9  B4 10					 mov	 ah,10h
   4598	    03EB  CD 16					 int	 16h
   4599
   4600	    03ED  E8 0000e				 call	 AOADisp
   4601
   4602							 ;cli					  ;SWITCH TO PM
   4603	    03F0  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4604	    03F5  0F 20	C0				 mov	 eax,cr0
   4605	    03F8  0C 01					 or	 al,1
   4606	    03FA  0F 22	C0				 mov	 cr0,eax
   4607							 JUMP16	 <GKeyCode_Sel>,<OFFSET	GetKeyV> ;TO PROTECTED MODE
1  4608	    03FD  EA					 DB	 0eah
1  4609	    03FE  0402r					 DW	 OFFSET	GetKeyV
1  4610	    0400  0004					 DW	 GKeyCode_Sel
   4611	    0402  B8 000C		 GetKeyV:	 mov	 ax,GKeyStack_Sel
   4612	    0405  8E D0					 mov	 ss,ax
   4613	    0407  66| 8B E5				 mov	 esp,ebp
   4614
   4615
   4616	    040A  0F A9					 pop	 gs
   4617	    040C  0F A1					 pop	 fs
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 82
prcycle.ASM



   4618	    040E  07					 pop	 es
   4619	    040F  1F					 pop	 ds
   4620	    0410  66| CF				 iretd
   4621	    0412  EB 8A					 jmp	 GKeyBegin
   4622	    0414			 GKeyBegin	 ENDP
   4623					 ;***************************************************************************
   4624					 ;GetSecBegin Procedure
   4625					 ;  comes here from a protected	mode through interrupt 0fah
   4626					 ;  0fah is used to read one sector from disk and store	it
   4627					 ;    in a buffer at 8400h
   4628					 ; this	buffer data in memory can be copied to other locations
   4629					 ;   above 1M using RDWTMEM routine
   4630					 ;***************************************************************************
   4631	    0414			 GetSecBegin	 PROC	 FAR
   4632
   4633	    0414  1E					 push	 ds
   4634	    0415  06					 push	 es
   4635	    0416  0F A0					 push	 fs
   4636	    0418  0F A8					 push	 gs
   4637							 ;-----------------------------------------------------------
   4638							 ;Checks for the StartSecNo in the shared memory if it is -1 its loaded	from+
   4639					 StartSecNum1m
   4640							 ;Else it is loaded from the shared memory location
   4641							 ;-----------------------------------------------------------
   4642	    041A  B8 00C0				 mov	 ax,MEMData_Sel; zero selector
   4643	    041D  8E C0					 mov	 es,ax	       ; es has	zero selector
   4644	    041F  66| BB 00008600			 mov	 ebx,S_Base    ; 8600h for shared mem
   4645	    0425  66| 83 C3 04				 add	 ebx,S_SectorNo	; offset of the	sectorno in shared mem
   4646	    0429  26: 67| 8B 03				 mov	 ax, WORD PTR es:[ebx] ; read shared mem for sectorno
   4647	    042D  3D FFFF				 cmp	 ax,-1	       ; check if it is	-1, menu loading will set this to -1
   4648	    0430  74 16					 je	 LoadOneSecForMenu ; yes, it is	-1, then goto process
   4649							 ; no, this load is for	an application,	who stores sector no in	S_SectorNo
   4650	    0432  B8 0018				 mov	 ax,RData_Sel  ; RDataSeg
   4651	    0435  8E E0					 mov	 fs,ax	       ; fs has	RDAtaSeg to refer to Start...
   4652	    0437  64: A1 0000e				 mov	 ax, WORD PTR fs:[StartLogicalSecNum1m]
   4653	    043B  26: 67| 89 43	02			 mov	 WORD PTR es:[ebx+2], ax ; store this value in shared mem temporarily
   4654	    0440  26: 67| 8B 03				 mov	 ax, WORD PTR es:[ebx];	read the sectorno placed by the	application
   4655	    0444  64: A3 0000e				 mov	 WORD PTR fs:[StartLogicalSecNum1m],ax ; store this in		    +
   4656					 StartLogicalSecNum1m
   4657							 ;in both cases	the starting sector number is stored in	StartLogicalSecNum1m
   4658							 ; normal stack	pointer
   4659
   4660	    0448			 LoadOneSecForMenu:
   4661							 ;Actual interrupt code	starts here
   4662	    0448  B8 0008				 mov	 ax,Normal_Sel
   4663	    044B  8E D0					 mov	 ss,ax
   4664
   4665							 ;turn off the CR0 bit for protected mode
   4666	    044D  0F 20	C0				 mov	 eax,cr0
   4667	    0450  24 FE					 and	 al,11111110b
   4668	    0452  0F 22	C0				 mov	 cr0,eax
   4669
   4670							 JUMP16	 <Seg GetSec+RELOCATE1>,<OFFSET	GetSec>	 ;SWITCH TO REAL MODE
1  4671	    0455  EA					 DB	 0eah
1  4672	    0456  045Ar					 DW	 OFFSET	GetSec
1  4673	    0458  0080s					 DW	 Seg GetSec+RELOCATE1
   4674	    045A  B8 0000s		 GetSec:	 mov	 ax,RDataSeg				 ; in real mode	now
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 83
prcycle.ASM



   4675	    045D  05 0080				 add	 ax, RELOCATE1	       ;RdataSeg is located w.r.t 800h or RELOCATE1
   4676	    0460  8E D8					 mov	 ds,ax
   4677	    0462  66| 8B EC				 mov	 ebp,esp
   4678							 ; initialize the real mode interrupt vectors
   4679	    0465  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4680	    046A  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4681	    046F  FB					 sti
   4682					 ;------------------------------------------------------------------------
   4683					 ;We are returned to RealMode from ProtMode include all	RMode code here...
   4684					 ;------------------------------------------------------------------------
   4685	    0470			 GetSec1:
   4686							 ; call	mini loader to load one	sector
   4687	    0470  E8 0000e				 call	 aoaminil1
   4688
   4689							 ;cli					  ;SWITCH TO PM
   4690	    0473  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4691	    0478  0F 20	C0				 mov	 eax,cr0
   4692	    047B  0C 01					 or	 al,1
   4693	    047D  0F 22	C0				 mov	 cr0,eax
   4694							 JUMP16	 <GetSecCode_Sel>,<OFFSET GetSecV> ;TO PROTECTED MODE
1  4695	    0480  EA					 DB	 0eah
1  4696	    0481  0485r					 DW	 OFFSET	GetSecV
1  4697	    0483  0004					 DW	 GetSecCode_Sel
   4698	    0485			 GetSecV:
   4699	    0485  B8 000C				 mov	 ax,GetSecStack_Sel
   4700	    0488  8E D0					 mov	 ss,ax
   4701	    048A  66| 8B E5				 mov	 esp,ebp
   4702							 ;Actual code ends here
   4703							;----------------------------------
   4704							 ;restore the StartSectorNum1... value for the initial sectorno
   4705
   4706	    048D  B8 00C0				 mov	 ax,MEMData_Sel; zero selector
   4707	    0490  8E C0					 mov	 es,ax	       ; es has	zero selector
   4708	    0492  66| BB 00008600			 mov	 ebx,S_Base    ; 8600h for shared mem
   4709	    0498  66| 83 C3 04				 add	 ebx,S_SectorNo	; offset of the	sectorno in shared mem
   4710	    049C  26: 67| 8B 03				 mov	 ax, WORD PTR es:[ebx] ; read shared mem for sectorno
   4711	    04A0  3D FFFF				 cmp	 ax,-1	       ; if it is -1 it	is not an application read
   4712	    04A3  74 0E					 je	 LoadOneSecForAppRestore ; else	it is an application
   4713	    04A5  B8 0018				 mov	 ax,RData_Sel  ; RDataSeg
   4714	    04A8  8E E0					 mov	 fs,ax	       ; fs has	RDAtaSeg to refer to Start...
   4715
   4716	    04AA  26: 67| 8B 43	02			 mov	 ax, WORD PTR es:[ebx+2]; read the sectorno placed by the	    +
   4717					 application
   4718	    04AF  64: A3 0000e				 mov	 WORD PTR fs:[StartLogicalSecNum1m],ax ; store this in Start....
   4719
   4720	    04B3			 LoadOneSecForAppRestore:
   4721							;---------------------------------
   4722	    04B3  0F A9					 pop	 gs
   4723	    04B5  0F A1					 pop	 fs
   4724	    04B7  07					 pop	 es
   4725	    04B8  1F					 pop	 ds
   4726
   4727	    04B9  66| CF				 iretd
   4728	    04BB  E9 FF56				 jmp	 GetSecBegin
   4729	    04BE			 GetSecBegin	   ENDP
   4730					 ;***************************************************************************
   4731					 ;WriteSecBegin	Procedure
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 84
prcycle.ASM



   4732					 ;  comes here from a protected	mode through interrupt 0f4h
   4733					 ;  0f4h is used to write one sector from 8400 h to disk given a sector	no
   4734					 ; this	call is	always invoked by an application through 0f4h interrupt
   4735					 ; shared memory has the sector	number just like read a	sector
   4736					 ; only	read or	write at a time	can be done by the application
   4737					 ;***************************************************************************
   4738	    04BE			 WriteSecBegin	   PROC	   FAR
   4739
   4740
   4741	    04BE  1E					 push	 ds
   4742	    04BF  06					 push	 es
   4743	    04C0  0F A0					 push	 fs
   4744	    04C2  0F A8					 push	 gs
   4745
   4746							 ;-----------------------------------------------------------
   4747	    04C4  B8 00C0				 mov	 ax,MEMData_Sel; zero selector
   4748	    04C7  8E C0					 mov	 es,ax	       ; es has	zero selector
   4749	    04C9  66| BB 00008600			 mov	 ebx,S_Base    ; 8600h for shared mem
   4750	    04CF  66| 83 C3 04				 add	 ebx,S_SectorNo	; offset of the	sectorno in shared mem
   4751	    04D3  B8 0018				 mov	 ax,RData_Sel  ; RDataSeg
   4752	    04D6  8E E0					 mov	 fs,ax	       ; fs has	RDAtaSeg to refer to Start...
   4753
   4754	    04D8  64: A1 0000e				 mov	 ax, WORD PTR fs:[StartLogicalSecNum1m]
   4755	    04DC  26: 67| 89 43	02			 mov	 WORD PTR es:[ebx+2], ax ; store this value in shared mem temporarily
   4756
   4757	    04E1  26: 67| 8B 03				 mov	 ax, WORD PTR es:[ebx];	read the sectorno placed by the	application
   4758	    04E5  64: A3 0000e				 mov	 WORD PTR fs:[StartLogicalSecNum1m],ax ; store this in Start....
   4759							 ;-----------------------------------------------------------
   4760							 ;Actual interrupt code	starts here
   4761	    04E9  B8 0008				 mov	 ax,Normal_Sel
   4762	    04EC  8E D0					 mov	 ss,ax
   4763
   4764							 ;turn off the CR0 bit for protected mode
   4765	    04EE  0F 20	C0				 mov	 eax,cr0
   4766	    04F1  24 FE					 and	 al,11111110b
   4767	    04F3  0F 22	C0				 mov	 cr0,eax
   4768
   4769							 JUMP16	 <Seg WriteSec+RELOCATE1>,<OFFSET WriteSec>  ;SWITCH TO	REAL MODE
1  4770	    04F6  EA					 DB	 0eah
1  4771	    04F7  04FBr					 DW	 OFFSET	WriteSec
1  4772	    04F9  0080s					 DW	 Seg WriteSec+RELOCATE1
   4773	    04FB  B8 0000s		 WriteSec:	 mov	 ax,RDataSeg				 ; in real mode	now
   4774	    04FE  05 0080				 add	 ax, RELOCATE1	       ;RdataSeg is located w.r.t 800h or RELOCATE1
   4775	    0501  8E D8					 mov	 ds,ax
   4776	    0503  66| 8B EC				 mov	 ebp,esp
   4777							 ; initialize the real mode interrupt vectors
   4778	    0506  0F B2	26 0199r			 lss	 sp,DWORD PTR SPVar
   4779	    050B  0F 01	1E 0192r			 lidt	 QWORD PTR NORVIDTR
   4780	    0510  FB					 sti
   4781					 ;------------------------------------------------------------------------
   4782					 ;We are returned to RealMode from ProtMode include all	RMode code here...
   4783					 ;------------------------------------------------------------------------
   4784	    0511			 WriteSec1:
   4785							 ; call	mini Writer to load one	sector
   4786	    0511  E8 0000e				 call	 aoaminiw1
   4787
   4788							 ;cli					  ;SWITCH TO PM
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 85
prcycle.ASM



   4789	    0514  0F 01	1E 018Cr			 lidt	 QWORD PTR VIDTR
   4790	    0519  0F 20	C0				 mov	 eax,cr0
   4791	    051C  0C 01					 or	 al,1
   4792	    051E  0F 22	C0				 mov	 cr0,eax
   4793							 JUMP16	 <WriteSecCode_Sel>,<OFFSET WriteSecV> ;TO PROTECTED MODE
1  4794	    0521  EA					 DB	 0eah
1  4795	    0522  0526r					 DW	 OFFSET	WriteSecV
1  4796	    0524  0004					 DW	 WriteSecCode_Sel
   4797	    0526			 WriteSecV:
   4798	    0526  B8 000C				 mov	 ax,WriteSecStack_Sel
   4799	    0529  8E D0					 mov	 ss,ax
   4800	    052B  66| 8B E5				 mov	 esp,ebp
   4801							 ;Actual code ends here
   4802							;----------------------------------
   4803							 ;restore the StartSectorNum1... value for the initial sectorno
   4804
   4805	    052E  B8 00C0				 mov	 ax,MEMData_Sel; zero selector
   4806	    0531  8E C0					 mov	 es,ax	       ; es has	zero selector
   4807	    0533  66| BB 00008600			 mov	 ebx,S_Base    ; 8600h for shared mem
   4808	    0539  66| 83 C3 04				 add	 ebx,S_SectorNo	; offset of the	sectorno in shared mem
   4809	    053D  B8 0018				 mov	 ax,RData_Sel  ; RDataSeg
   4810	    0540  8E E0					 mov	 fs,ax	       ; fs has	RDAtaSeg to refer to Start...
   4811
   4812	    0542  26: 67| 8B 43	02			 mov	 ax, WORD PTR es:[ebx+2]; read the sectorno placed by the	    +
   4813					 application
   4814	    0547  64: A3 0000e				 mov	 WORD PTR fs:[StartLogicalSecNum1m],ax ; store this in Start....
   4815							;---------------------------------
   4816	    054B  0F A9					 pop	 gs
   4817	    054D  0F A1					 pop	 fs
   4818	    054F  07					 pop	 es
   4819	    0550  1F					 pop	 ds
   4820
   4821	    0551  66| CF				 iretd
   4822	    0553  E9 FF68				 jmp	 WriteSecBegin
   4823	    0556			 WriteSecBegin	     ENDP
   4824
   4825					 ;***************************************************************************
   4826					 ; Read	Sectors	From Disk
   4827					 ; this	procedure is invoked to	read all sectors from the disk starting	from
   4828					 ;  the
   4829					 ;***************************************************************************
   4830	    0556			 ReadSectorsAll	    PROC  C  NEAR USES ds eax ebx
   4831
   4832							 ;disable timer	while reading sectors
1  4833	    0556  1E				 PUSH	 DS
1  4834	    0557  66| 50			 PUSH	 EAX
1  4835	    0559  66| 53			 PUSH	 EBX
1  4836	    055B  66| 52				 push	 edx
   4837	    055D  66| 50				 push	 eax
   4838	    055F  BA 0021				 mov	 dx,21h	; disable timer	interrupt
   4839	    0562  B0 01					 mov	 al,01h
   4840	    0564  EE					 out	 dx,al
   4841	    0565  66| 58				 pop	 eax
   4842	    0567  66| 5A				 pop	 edx
   4843
   4844							 ;--------------------------------------------
   4845							 ; save	start sector, number of	sectors	and address offset
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 86
prcycle.ASM



   4846	    0569			 readagain:
   4847	    0569  06					 push	 es
   4848	    056A  B8 0018				 mov	 ax,RData_Sel
   4849	    056D  8E C0					 mov	 es,ax
   4850
   4851	    056F  66| B8 00000000			 mov	 eax, 0
   4852	    0575  26: A1 0417r				 mov	 ax, es:[SLSecNum1mS]
   4853	    0579  26: A3 0000e				 mov	 es:[StartLogicalSecNum1m], ax ; start sector
   4854
   4855	    057D  26: A1 0419r				 mov	 ax, es:[LSize1mS]
   4856	    0581  26: A3 0000e				 mov	 es:[LoaderSize1m], ax ; number	of sectors
   4857
   4858	    0585  66| 26: A1 041Br			 mov	 eax, es:[BxP1S]
   4859	    058A  66| 26: A3 0000e			 mov	 es:[BxPointer1], eax ;	address	offset
   4860
   4861							 ;-------------------------------
   4862	    058F  B8 00C0				 mov ax, MEMData_Sel
   4863							 ; This	is a zero base selector	to access shared memory	between	aoa and	    +
   4864					 application
   4865	    0592  0F A0					 push	 fs
   4866	    0594  8E E0					 mov	 fs, ax
   4867	    0596  66| BB 00008600			 mov	 ebx, S_Base
   4868	    059C  66| 81 C3 00000140			 add	 ebx, S_LSError
   4869	    05A3  66| B8 00000000			 mov	 eax, 0
   4870	    05A9  66| 64: 67| 89 03			 mov	 fs:[ebx], eax	   ;reset LSector Error	if any
   4871	    05AE  0F A1					 pop	 fs
   4872	    05B0  07					 pop	 es
   4873							 ;-------------------------------
   4874
   4875	    05B1  B8 0018				 mov	 ax,RData_Sel ;	real data seg
   4876	    05B4  8E D8					 mov	 ds,ax
   4877	    05B6			 readsectors:
   4878	    05B6  A1 0000e				 mov	 ax,ds:[LoaderSize1m] ;	get no of sectors to read
   4879	    05B9  3D 0000				 cmp	 ax,0		     ; is all sectors read?
   4880	    05BC  0F 86	00AB				 jbe	 nomoresectors	     ; yes, get	out of loop
   4881
   4882							 ;------------------------------
   4883							 ; we set a -1 flag in shared memory so	that
   4884							 ; when	menu loads application program,	starting
   4885							 ; sector is used as defined in	StartLogicalSecNum1
   4886							 ; otherwise, when an application program needs	to read	a
   4887							 ;  sector, then it will store its sector no in	this location
   4888							 ;------------------------------
   4889	    05C0  06					 push	 es
   4890	    05C1  66| 50				 push	 eax
   4891	    05C3  66| 53				 push	 ebx
   4892	    05C5  B8 00C0				 mov	 ax,MEMData_Sel
   4893	    05C8  8E C0					 mov	 es,ax
   4894	    05CA  66| BB 00008600			 mov	 ebx,S_Base
   4895	    05D0  66| 83 C3 04				 add	 ebx,S_SectorNo
   4896	    05D4  26: 67| C7 03	FFFF			 mov	 WORD PTR es:[ebx],-1; To make sure the	controll in the	shared mem  +
   4897					 is set	to -1
   4898	    05DA  66| 5B				 pop	 ebx
   4899	    05DC  66| 58				 pop	 eax
   4900	    05DE  07					 pop	 es
   4901
   4902	    05DF  CD FA					 int	 0fah		     ; read one	sector
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 87
prcycle.ASM



   4903							;-------------------------------
   4904	    05E1  B8 00C0				 mov ax, MEMData_Sel	     ; this is in protected mode
   4905							 ; This	is a zero base selector	to access shared memory	between	aoa and	    +
   4906					 application
   4907	    05E4  0F A0					 push	 fs
   4908	    05E6  8E E0					 mov	 fs, ax
   4909	    05E8  66| BB 00008600			 mov	 ebx, S_Base
   4910	    05EE  66| 81 C3 00000140			 add	 ebx, S_LSError
   4911	    05F5  66| 64: 67| 8B 03			 mov	 eax, fs:[ebx]	  ;check if there is LSector Error
   4912	    05FA  0F A1					 pop	 fs
   4913							 ;-------------------------------
   4914	    05FC  66| 83 F8 00				 cmp	 eax, 0
   4915	    0600  74 36					 jz	 continueread
   4916							 ;;reset LSError
   4917							 ;;-------------
   4918	    0602  B8 00C0				 mov ax, MEMData_Sel	     ; this is in protected mode
   4919							 ; This	is a zero base selector	to access shared memory	between	aoa and	    +
   4920					 application
   4921	    0605  0F A0					 push	 fs
   4922	    0607  8E E0					 mov	 fs, ax
   4923	    0609  66| BB 00008600			 mov	 ebx, S_Base
   4924	    060F  66| 81 C3 00000140			 add	 ebx, S_LSError
   4925	    0616  66| B8 00000000			 mov	 eax, 0
   4926	    061C  66| 64: 67| 89 03			 mov	 fs:[ebx], eax
   4927	    0621  0F A1					 pop	 fs
   4928							 ;;-------------
   4929	    0623  66| C7 06 01CDr     +			 mov	 ds:[AnyCounter], 021h
   4930		  00000021
   4931	    062C  66| C7 06 01C9r     +			 mov	 ds:[MemPrintOffset], 0
   4932		  00000000
   4933	    0635  E9 FF31				 jmp	 readagain
   4934							 ;------------------------------------
   4935	    0638			 continueread:
   4936							 CALL16	 RDWTMemPGate_Sel,0h ; copy sector to higher memory
1  4937	    0638  9A					 DB	 9ah
1  4938	    0639  0000					 DW	 0h
1  4939	    063B  0094					 DW	 RDWTMemPGate_Sel
   4940	    063D  66| A1 0000e				 mov	 eax,ds:[BxPointer1]
   4941	    0641  66| A3 01C9r				 mov	 ds:[MemPrintOffset],eax
   4942	    0645  66| FF 06 01CDr			 inc	 ds:[AnyCounter]	 ; increment sector counter
   4943
   4944	    064A  66| A1 01CDr				 mov	 eax,ds:[AnyCounter]	 ; get the sector counter
   4945	    064E  66| BB 00000F62			 mov	 ebx,3938		 ; print the counter at	the bottom
   4946	    0654  CD FD					 int	 0fdh			 ; puthex32 interrupt
   4947
   4948	    0656  66| 81 06 0000e     +			 add	 ds:[BxPointer1],200h	 ; update the BxPointer	for next sector
   4949		  00000200
   4950	    065F  66| 81 06 01C9r     +			 add	 ds:[MemPrintOffset],200h; update the memory print pointer for next +
   4951		  00000200		 sector
   4952	    0668  E9 FF4B				 jmp	 readsectors		 ; loop	until all sectors are read
   4953
   4954	    066B			 nomoresectors:
   4955	    066B  66| C7 06 01C9r     +			 mov	 ds:[MemPrintOffset],0h	 ; reset memory	print offset
   4956		  00000000
   4957	    0674  66| C7 06 01CDr     +			 mov	 ds:[AnyCounter],21h	  ; reset sector counter
   4958		  00000021
   4959
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 88
prcycle.ASM



1  4960	    067D  66| 5B			 POP	 EBX
1  4961	    067F  66| 58			 POP	 EAX
1  4962	    0681  1F				 POP	 DS
1  4963	    0682  C3				 RET	 0000h
   4964
   4965	    0683			 ReadSectorsAll	 ENDP
   4966					 ;***************************************************************************
   4967	    0683			 InitLoad	 PROC  C  NEAR ;SES ds eax ebx
   4968	    0683  0F A0					 push	 fs
   4969	    0685  B8 0054				 mov	 ax,RealData_Sel
   4970	    0688  8E E0					 mov	 fs,ax
   4971
   4972	    068A  64: 80 3E 0000e 31			 cmp	 fs:[ApplNum],31h
   4973	    0690  75 23					 jne	 LoadApp2
   4974
   4975	    0692  64: A1 0000e				 mov	 ax,fs:[LoaderSize1]
   4976	    0696  64: A3 0000e				 mov	 fs:[LoaderSize1m],ax
   4977	    069A  64: A1 0000e				 mov	 ax,fs:[StartLogicalSecNum1]
   4978	    069E  64: A3 0000e				 mov	 fs:[StartLogicalSecNum1m],ax
   4979	    06A2  66| 64: A1 0000e			 mov	 eax,fs:[LoadOffset1]
   4980
   4981	    06A7  66| 64: A3 0000e			 mov	 fs:[BxPointer1],eax
   4982	    06AC  66| 64: 83 0E	01D2r +			 or	 fs:[RunFlag],1
   4983		  01
   4984	    06B3  EB 27					 jmp	 LoadApp
   4985	    06B5			 LoadApp2:
   4986	    06B5  64: A1 0000e				 mov	 ax,fs:[LoaderSize2]
   4987	    06B9  64: A3 0000e				 mov	 fs:[LoaderSize1m],ax
   4988	    06BD  64: A1 0000e				 mov	 ax,fs:[StartLogicalSecNum2]
   4989	    06C1  64: A3 0000e				 mov	 fs:[StartLogicalSecNum1m],ax
   4990	    06C5  66| B8 00000000			 mov	 eax,0
   4991	    06CB  66| 64: A1 0000e			 mov	 eax,fs:[LoadOffset2]
   4992	    06D0  66| 64: A3 0000e			 mov	 fs:[BxPointer1],eax
   4993	    06D5  66| 64: 83 0E	01D2r +			 or	 fs:[RunFlag],2
   4994		  02
   4995	    06DC			 LoadApp:
   4996	    06DC  64: C6 06 0000e 00			 mov	 fs:[LoadFlag],0
   4997	    06E2  0F A1					 pop	 fs
   4998
1  4999	    06E4  C3				 RET	 0000h
   5000
   5001	    06E5			 InitLoad  ENDP
   5002					 ;***************************************************************************
   5003					 ; Running Application
   5004					 ;***************************************************************************
   5005	    06E5			 RunAppl  PROC	C  NEAR	;SES ds	eax ebx
   5006	    06E5  0F A0					 push	 fs
   5007	    06E7  0F A8					 push	 gs
   5008	    06E9  06					 push	 es
   5009
   5010	    06EA  B8 00D0				 mov	 ax,App1TSSRW_Sel   ; selector for application task segment	    +
   5011					 App1TSSeg
   5012	    06ED  8E E8					 mov	 gs,ax		    ; gs pointing to task segment
   5013	    06EF  B8 0054				 mov	 ax,RealData_Sel
   5014	    06F2  8E E0					 mov	 fs,ax		    ; fs pointing to real data segment RDATASEG
   5015	    06F4  66| 64: A1 01D2r			 mov	 eax,fs:[RunFlag]
   5016	    06F9  66| 83 E0 01				 and	 eax,01h	    ; if the run flag is set then run
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 89
prcycle.ASM



   5017	    06FD  66| 83 F8 01				 cmp	 eax,1
   5018	    0701  0F 85	01C0				 jne	 RunNext
   5019	    0705  66| BB 00000000r			 mov	 ebx, OFFSET App1TaskTSS  ; offset of the TaskTSS for app1
   5020	    070B  66| B8 00000000			 mov	 eax,0h
   5021							 ;mov	 eax, fs:[LoadOffset1]	  ; offset entered by the user during load
   5022							 ; we changed all base vlaues to 11 in the prcycle for cs, ds, ss
   5023							 ; LoadOffset1 is used to load program in memory
   5024	    0711  64: 03 06 0000e			 add	 ax,fs:[JumpOffset1]	  ; add	16 bit code segment offset entered  +
   5025					 by user
   5026	    0716  66| 65: 67| 89 43 20			 mov	 DWORD PTR gs:[ebx].TREIP,eax ;load EIP	value in the task segment
   5027
   5028							 ;mov	 eax, 0ffffh		; 64k cache
   5029							 ;mov	 eax, 0ffefffh		  ;LARGESTACK works for	teststack example
   5030	    071C  66| B8 01E84800			 mov	 eax, 01e84800h		  ; for	32 M stack size
   5031							 ;mov	 eax, 02200000h		  ; for	32 M stack size
   5032	    0722  66| 65: 67| 89 43 38			 mov	 dword ptr gs:[ebx].TRESP, eax ; load ESP value	in the task segment
   5033	    0728  66| B8 00000000			 mov	 eax, 0
   5034	    072E  66| 65: 67| 89 43 3C			 mov	 dword ptr gs:[ebx].TREBP, eax ; load EBP
   5035							 ;mov	 eax, 3202h
   5036							 ;mov	 dword ptr gs:[ebx].TREFlag, eax ; load	eflags
   5037	    0734  66| B8 00000202			 mov	 eax,0202h
   5038	    073A  66| 65: 67| 89 43 24			 mov	 dword ptr gs:[ebx].TREFlag, eax ; load	eflags
   5039																    +
   5040					 ;--------------------------------------------------------------------------------------
   5041							 ;Temp setup for App2
   5042
   5043	    0740  B8 0108				 mov	 ax,App2TSSRW_Sel   ; selector for application task segment	    +
   5044					 App1TSSeg
   5045	    0743  8E E8					 mov	 gs,ax		    ; gs pointing to task segment
   5046	    0745  B8 0054				 mov	 ax,RealData_Sel
   5047	    0748  8E E0					 mov	 fs,ax		    ; fs pointing to real data segment RDATASEG
   5048	    074A  66| BB 00000000r			 mov	 ebx, OFFSET App2TaskTSS  ; offset of the TaskTSS for app1
   5049	    0750  66| B8 00000000			 mov	 eax,0h
   5050	    0756  66| 64: A1 0000e			 mov	 eax, fs:[LoadOffset1]	  ; offset entered by the user during load
   5051	    075B  64: 03 06 0000e			 add	 ax,fs:[JumpOffset1]	  ; add	16 bit code segment offset entered  +
   5052					 by user
   5053	    0760  05 15DD				 add	 ax,015ddh
   5054	    0763  66| 65: 67| 89 43 20			 mov	 DWORD PTR gs:[ebx].TREIP,eax ;load EIP	value in the task segment
   5055
   5056							 ;mov	 eax, 0ffffh		; 64k cache
   5057							 ;mov	 eax, 0ffefffh		  ;LARGESTACK works for	teststack example
   5058	    0769  66| B8 01E84800			 mov	 eax, 01e84800h		  ; for	32 M stack size
   5059	    076F  66| 65: 67| 89 43 38			 mov	 dword ptr gs:[ebx].TRESP, eax ; load ESP value	in the task segment
   5060	    0775  66| B8 00000000			 mov	 eax, 0
   5061	    077B  66| 65: 67| 89 43 3C			 mov	 dword ptr gs:[ebx].TREBP, eax ; load EBP
   5062	    0781  66| B8 00004202			 mov	 eax,4202h
   5063	    0787  66| 65: 67| 89 43 24			 mov	 dword ptr gs:[ebx].TREFlag, eax ; load	eflags
   5064
   5065							 ;------------------------------------------------
   5066	    078D  1E					 push	 ds
   5067							 ; Check for ReRun flag	if the flag is not zero	reload the App1	TSS from    +
   5068					 0200 location
   5069							 ; else	copy App1TSS to	0200 location
   5070	    078E  B8 0018				 mov	 ax, Rdata_Sel
   5071	    0791  8E D8					 mov	 ds, ax
   5072	    0793  A1 019Dr				 mov	 ax, WORD PTR ds:[RERunFlag]
   5073	    0796  3D 0000				 cmp	 ax, 0
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 90
prcycle.ASM



   5074	    0799  75 7B					 jnz	 CPY0200
   5075
   5076	    079B  B8 0001				 mov	 ax, 1
   5077	    079E  A3 019Dr				 mov	 WORD PTR ds:[RERunFlag], ax
   5078	    07A1  1F					 pop	 ds
   5079							 ;------------------------------------------------------
   5080							 ;RKK Transfer a sample	TSS to user memory which can be	used
   5081							 ;  for	creating other TSS
   5082
   5083	    07A2  0F A0					 push	 fs
   5084	    07A4  0F A8					 push	 gs
   5085	    07A6  B8 00D0				 mov	 ax, App1TSSRW_Sel ; read/write	selector for TSS Segment App1
   5086	    07A9  8E E8					 mov	 gs, ax		   ; gs	with TSS segment
   5087	    07AB  66| BE 00000000r			 mov	 esi, OFFSET App1TaskTSS ; offset of TSS segment
   5088
   5089	    07B1  66| BB 02000000			 mov	 ebx, 02000000h	   ; user application memory address
   5090	    07B7  B8 00C0				 mov	 ax,MEMData_Sel	   ; 0 base selector for protected mode
   5091	    07BA  8E E0					 mov	 fs,ax		   ; use 0 base	selector
   5092
   5093	    07BC  66| B9 00000000			 mov	 ecx,0
   5094	    07C2  B8 0018				 mov	 ax, RData_Sel
   5095	    07C5  1E					 push	 ds		   ; get SizeOf_TSS1
   5096	    07C6  8E D8					 mov	 ds, ax
   5097	    07C8  8B 0E	0170r				 mov	 cx, WORD PTR ds:[SizeOf_TSS1]
   5098	    07CC  1F					 pop	 ds
   5099
   5100	    07CD			 movtssuserapp1:
   5101	    07CD  65: 67| 8A 06				 mov	 al, BYTE PTR gs:[esi] ; move TSS to user memory
   5102	    07D1  64: 67| 88 03				 mov	 BYTE PTR fs:[ebx], al ;    byte at a time
   5103	    07D5  66| 46				 inc	 esi
   5104	    07D7  66| 43				 inc	 ebx
   5105	    07D9  E2 F2					 loop	 movtssuserapp1		; loop
   5106	    07DB  0F A9					 pop	 gs
   5107	    07DD  0F A1					 pop	 fs
   5108					 ;----------------------------------------------------------------
   5109					 ; copy	the Demo Code TSS to 02001000
   5110	    07DF  0F A0					 push	 fs
   5111	    07E1  0F A8					 push	 gs
   5112	    07E3  B8 0148				 mov	 ax, DemoTSSRW_Sel ; read/write	selector for TSS Segment App1
   5113	    07E6  8E E8					 mov	 gs, ax		   ; gs	with TSS segment
   5114	    07E8  66| BE 00000000r			 mov	 esi, OFFSET DemoTSSSeg	; offset of TSS	segment
   5115
   5116	    07EE  66| BB 02001000			 mov	 ebx, 02001000h	   ; user application memory address
   5117	    07F4  B8 00C0				 mov	 ax,MEMData_Sel	   ; 0 base selector for protected mode
   5118	    07F7  8E E0					 mov	 fs,ax		   ; use 0 base	selector
   5119
   5120	    07F9  66| B9 00000000			 mov	 ecx,0
   5121	    07FF  B9 006A				 mov	 cx, 6Ah	 ; This	is the length of DemoTSS got form the List  +
   5122					 File
   5123										 ; it is a hardcoded value
   5124	    0802			 movtssuserapp3:
   5125	    0802  65: 67| 8A 06				 mov	 al, BYTE PTR gs:[esi] ; move TSS to user memory
   5126	    0806  64: 67| 88 03				 mov	 BYTE PTR fs:[ebx], al ;    byte at a time
   5127	    080A  66| 46				 inc	 esi
   5128	    080C  66| 43				 inc	 ebx
   5129	    080E  E2 F2					 loop	 movtssuserapp3		; loop
   5130	    0810  0F A9					 pop	 gs
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 91
prcycle.ASM



   5131	    0812  0F A1					 pop	 fs
   5132					 ;----------------------------------------------------------------
   5133	    0814  EB 72					 JMP	 CPY0200SKP		 ; Skip	CPY 0200 to App1 TSS
   5134					 ;---------------------------------------------------------------------------------
   5135					 ; Copy	the TSS	in 0200	location to App1 TSS to	reinitialize the APP1 TSS to re	run the	    +
   5136					 application
   5137					 ; without rebooting the computer
   5138	    0816			 CPY0200:
   5139
   5140	    0816  0F A0					 push	 fs
   5141	    0818  0F A8					 push	 gs
   5142	    081A  B8 00D0				 mov	 ax, App1TSSRW_Sel ; read/write	selector for TSS Segment App1
   5143	    081D  8E E8					 mov	 gs, ax		   ; gs	with TSS segment
   5144	    081F  66| BE 00000000r			 mov	 esi, OFFSET App1TaskTSS ; offset of TSS segment
   5145
   5146	    0825  66| BB 02000000			 mov	 ebx, 02000000h	   ; user application memory address
   5147	    082B  B8 00C0				 mov	 ax,MEMData_Sel	   ; 0 base selector for protected mode
   5148	    082E  8E E0					 mov	 fs,ax		   ; use 0 base	selector
   5149
   5150	    0830  66| B9 00000000			 mov	 ecx,0
   5151	    0836  B8 0018				 mov	 ax, RData_Sel
   5152	    0839  1E					 push	 ds		   ; get SizeOf_TSS1
   5153	    083A  8E D8					 mov	 ds, ax
   5154	    083C  8B 0E	0170r				 mov	 cx, WORD PTR ds:[SizeOf_TSS1]
   5155	    0840  1F					 pop	 ds
   5156	    0841			 movtssuserapp2:
   5157
   5158	    0841  64: 67| 8A 03				 mov	 al, BYTE PTR fs:[ebx];	   byte	at a time
   5159	    0845  65: 67| 88 06				 mov	 BYTE PTR gs:[esi], al;	   move	TSS to App1 TSS
   5160	    0849  66| 46				 inc	 esi
   5161	    084B  66| 43				 inc	 ebx
   5162	    084D  E2 F2					 loop	 movtssuserapp2		; loop
   5163	    084F  0F A9					 pop	 gs
   5164	    0851  0F A1					 pop	 fs
   5165					 ;----------------------------------------------------------------------------
   5166	    0853  0F A0					 push	 fs
   5167	    0855  0F A8					 push	 gs
   5168	    0857  B8 0148				 mov	 ax, DemoTSSRW_Sel ; read/write	selector for TSS Segment App1
   5169	    085A  8E E8					 mov	 gs, ax		   ; gs	with TSS segment
   5170	    085C  66| BE 00000000r			 mov	 esi, OFFSET DemoTSSSeg	; offset of TSS	segment
   5171
   5172	    0862  66| BB 02001000			 mov	 ebx, 02001000h	   ; user application memory address
   5173	    0868  B8 00C0				 mov	 ax,MEMData_Sel	   ; 0 base selector for protected mode
   5174	    086B  8E E0					 mov	 fs,ax		   ; use 0 base	selector
   5175
   5176	    086D  66| B9 00000000			 mov	 ecx,0
   5177	    0873  B9 006A				 mov	 cx, 6Ah	 ; This	is the length of DemoTSS got form the List  +
   5178					 File
   5179										 ; it is a hardcoded value
   5180	    0876			 movtssuserapp4:
   5181	    0876  64: 67| 8A 03				 mov	 al, BYTE PTR fs:[ebx];	   byte	at a time
   5182	    087A  65: 67| 88 06				 mov	 BYTE PTR gs:[esi], al;	   move	TSS to App1 TSS
   5183	    087E  66| 46				 inc	 esi
   5184	    0880  66| 43				 inc	 ebx
   5185	    0882  E2 F2					 loop	 movtssuserapp4		; loop
   5186	    0884  0F A9					 pop	 gs
   5187	    0886  0F A1					 pop	 fs
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 92
prcycle.ASM



   5188					 ;----------------------------------------------------------------------------
   5189	    0888			 CPY0200SKP:
   5190
   5191	    0888  66| 52			 push	 edx
   5192	    088A  66| 50			 push	 eax
   5193	    088C  BA 0021			 mov	 dx,21h	; disable timer	interrupt
   5194	    088F  B0 01				 mov	 al,01h
   5195	    0891  EE				 out	 dx,al
   5196	    0892  66| 58			 pop	 eax
   5197	    0894  66| 5A			 pop	 edx
   5198
   5199	    0896  CD FE					 int	 0feh		   ; run AO as a single	interrupt gate APPL1
   5200	    0898  66| 64: 81 26	01D2r +			 and	 fs:[RunFlag],0feh
   5201		  000000FE
   5202																    +
   5203					 ;----------------------------------------------------------------------------
   5204							 ;TEMP Print EFlags
   5205	    08A2  B8 0108				 mov	 ax,App2TSSRW_Sel   ; selector for application task segment	    +
   5206					 App1TSSeg
   5207	    08A5  8E E8					 mov	 gs,ax		    ; gs pointing to task segment
   5208	    08A7  66| BB 00000000r			 mov	 ebx, OFFSET App1TaskTSS  ; offset of the TaskTSS for app1
   5209	    08AD  66| 65: 67| 8B 43 24			 mov	 eax, dword ptr	gs:[ebx].TREFlag ; load	eflags
   5210	    08B3  66| BB 00000460			 mov	 ebx, 1120
   5211							 ;int	 0fdh	 ; Prints the EFlags
   5212	    08B9  0F 00	C8				 str	 ax
   5213	    08BC  66| BB 00000474			 mov	 ebx, 1140
   5214							 ;int	 0fdh
   5215																    +
   5216					 ;-----------------------------------------------------------------------------
   5217
   5218	    08C2  E9 0091				 jmp	 GoBackToMenu
   5219	    08C5			 RunNext:
   5220	    08C5  B8 0108				 mov	 ax,App2TSSRW_Sel
   5221	    08C8  8E E8					 mov	 gs,ax
   5222	    08CA  66| 64: A1 01D2r			 mov	 eax,fs:[RunFlag]
   5223	    08CF  24 02					 and	 al,02h
   5224	    08D1  3C 02					 cmp	 al,2
   5225	    08D3  0F 85	007F				 jne	 GoBackToMenu
   5226	    08D7  66| BB 00000000r			 mov	 ebx, OFFSET App2TaskTSS
   5227	    08DD  66| B8 00000000			 mov	 eax,0h
   5228	    08E3  66| 64: A1 0000e			 mov	 eax, fs:[LoadOffset2]
   5229	    08E8  64: 03 06 0000e			 add	 ax,fs:[JumpOffset2]
   5230
   5231	    08ED  66| 65: 67| 89 43 20			 mov	 DWORD PTR gs:[ebx].TREIP,eax
   5232	    08F3  66| B8 00000D00			 mov	 eax, 0d00h
   5233	    08F9  66| 65: 67| 89 43 38			 mov	 dword ptr gs:[ebx].TRESP, eax
   5234	    08FF  66| B8 00000000			 mov	 eax, 0
   5235	    0905  66| 65: 67| 89 43 3C			 mov	 dword ptr gs:[ebx].TREBP, eax
   5236	    090B  66| B8 00004202			 mov	 eax, 4202h
   5237	    0911  66| 65: 67| 89 43 24			 mov	 dword ptr gs:[ebx].TREFlag, eax
   5238
   5239	    0917  66| 50				 push	 eax
   5240	    0919  66| 53				 push	 ebx
   5241	    091B  B0 5A					 mov	 al,'Z'
   5242	    091D  66| BB 000007BC			 mov	 ebx,1980
   5243	    0923  CD F7					 int	 0f7h
   5244	    0925  66| 5B				 pop	 ebx
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 93
prcycle.ASM



   5245	    0927  66| 58				 pop	 eax
   5246							 ;---------------------------new
   5247	    0929  66| 50				 push	 eax
   5248	    092B  66| 53				 push	 ebx
   5249	    092D  0F A0					 push	 fs
   5250	    092F  66| BB 02000000			 mov	 ebx, 02000000h	   ; user application memory address
   5251	    0935  B8 00C0				 mov	 ax,MEMData_Sel	   ; 0 base selector for protected mode
   5252	    0938  8E E0					 mov	 fs,ax		   ; use 0 base	selector
   5253	    093A  66| B8 000025AB			 mov	 eax,0000025ABh	   ; Change the	EIP for	application 2
   5254	    0940  66| 83 C3 20				 add	 ebx,32
   5255							 ;mov	 DWORD PTR fs:[ebx],eax
   5256	    0944  0F A1					 pop	 fs
   5257	    0946  66| 5B				 pop	 ebx
   5258	    0948  66| 58				 pop	 eax
   5259							 ;---------------------------new
   5260
   5261
   5262	    094A  CD F9					 int	 0f9h
   5263	    094C  66| 64: 81 26	01D2r +			 and	 fs:[RunFlag],0fdh
   5264		  000000FD
   5265	    0956			 GoBackToMenu:
   5266	    0956  07					 pop	 es
   5267	    0957  0F A9					 pop	 gs
   5268	    0959  0F A1					 pop	 fs
1  5269	    095B  C3				 RET	 0000h
   5270	    095C			 RunAppl  ENDP
   5271					 ;***************************************************************************
   5272					 ; Once	the exception occurs, this call	will print the stack values so that
   5273					 ; the user can	see the	address	and EIP, CS values that	caused the exception
   5274					 ;  Other_Sel, RCodeSeg, it is in 16 bit segment while in error
   5275					 ;  It is still	using the TSS for the task which caused	error
   5276					 ;  The	contents of the	stack printed represent
   5277					 ;  - error code
   5278					 ;  - address where it failed
   5279					 ;  - selector for that	address
   5280					 ;  - flag register
   5281					 ;***************************************************************************
   5282	    095C			 PrintStackException	 PROC	 FAR
   5283	    095C  66| 55			 push	 ebp		 ;save the base	pointer
   5284	    095E  66| 8B EC			 mov	 ebp, esp	 ; load	current	SP into	BP
   5285	    0961  66| B9 00000020		 mov	 ecx, 32	 ; print ten entries in	the stack
   5286	    0967  66| BB 00000460		 mov	 ebx, 1120	 ; start location of print
   5287	    096D			 label210:
   5288	    096D  66| 67| 8B 45	00		 mov	 eax, ss:[ebp +	0]   ; do not print the	top 2 entries (push ebp, and the    +
   5289					 return	address	of this	call)
   5290	    0972  66| 83 C5 04			 add	 ebp, 4		 ; print next entry
   5291	    0976  66| 83 C3 02			 add	 ebx, 2		 ; space between printing hex values
   5292	    097A  CD FD				 int	 0fdh		 ; print 4 bytes
   5293	    097C  E2 EF				 LOOP	 label210	 ; loop	to print ten entries
   5294	    097E  FB				 sti
   5295	    097F  CD F5				 int	 0f5h		 ; wait	for a character
   5296	    0981  66| 5D			 pop	 ebp		 ; restore the base pointer
   5297
   5298	    0983  CB				 ret			 ; return back to error	rtn
   5299	    0984			 PrintStackException	 ENDP
   5300					 ;***************************************************************************
   5301					 ; Set error flag and error code in the	global memory
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 94
prcycle.ASM



   5302					 ;***************************************************************************
   5303	    0984			 SetErrorFlag	 PROC	 FAR
   5304	    0984  66| 50			 push eax ; save registers
   5305	    0986  66| 53			 push ebx
   5306	    0988  66| 51			 push ecx
   5307	    098A  06				 push es
   5308
   5309	    098B  66| BB 00000190		 mov	 ebx,400
   5310	    0991  CD F7				 int	 0f7h
   5311						 ;------------------------------------
   5312	    0993  B8 00B0			 mov	 ax, G4Data_Sel
   5313						 ;This is a zero base selector to access shared	memory between aoa and application
   5314	    0996  8E C0				 mov	 es, ax
   5315	    0998  66| BB 00008600		 mov	 ebx, S_Base
   5316	    099E  66| 83 C3 18			 add	 ebx, S_Error_Flag
   5317	    09A2  66| B8 00000001		 mov	 eax, 1	       ; set the error flag in global memory
   5318	    09A8  66| 26: 67| 89 03		 mov	 DWORD PTR es:[ebx], eax
   5319	    09AD  66| BB 00008600		 mov	 ebx, S_Base
   5320	    09B3  66| 83 C3 1C			 add	 ebx, S_Error_Code
   5321	    09B7  66| 8B C1			 mov	 eax, ecx	 ; set the error code in global	memory
   5322	    09BA  66| 26: 67| 89 03		 mov	 DWORD PTR es:[ebx], eax
   5323						 ;---------------------------------------------------------------------------------
   5324						 ;changed this code on 7-7-2004
   5325	    09BF  FA					 cli
   5326	    09C0  66| 52				 push	 edx
   5327	    09C2  66| 9C				 pushfd	; turn off NT flag in the CPU not in the TSS
   5328							 ; so that CPU will return to its application during IRETD not to
   5329							 ;  exit from the task using link field	in the TSS
   5330	    09C4  66| 5A				 pop	 edx;
   5331	    09C6  66| 81 E2 FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   5332	    09CD  66| 52				 push	 edx
   5333	    09CF  66| 9D				 popfd
   5334	    09D1  66| 5A				 pop	 edx
   5335	    09D3  FB					 sti
   5336						 ;--------------------------------------------------------------------------------
   5337
   5338	    09D4  07				 pop es	; restore registers
   5339	    09D5  66| 59			 pop ecx
   5340	    09D7  66| 5B			 pop ebx
   5341	    09D9  66| 58			 pop eax
   5342	    09DB  CB				 ret
   5343	    09DC			 SetErrorFlag	 ENDP
   5344					 ;***************************************************************************
   5345					 ;OtherBegin0 Procedure, 0 interrupt
   5346					 ;***************************************************************************
   5347	    09DC			 OtherBegin0	  PROC	  FAR
   5348	    09DC  0E E8	FF7C			 call	 PrintStackException ; print stack entries
   5349	    09E0  FA				 cli
   5350	    09E1  66| B9 00000000		 mov	 ecx, 00h
   5351	    09E7  B0 41				 mov	 al, 'A'
   5352	    09E9  0E E8	FF97			 CALL	 SetErrorFlag	 ; call	the routine
   5353	    09ED  CD 08				 int 08h
   5354	    09EF  66| CF			 iretd
   5355	    09F1			 OtherBegin0	  ENDP
   5356					 ;***************************************************************************
   5357					 ;OtherBegin1 Procedure, 1 interrupt
   5358					 ;***************************************************************************
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 95
prcycle.ASM



   5359	    09F1			 OtherBegin1	  PROC	  FAR
   5360	    09F1  0E E8	FF67			 call	 PrintStackException ; print stack entries
   5361	    09F5  FA				 cli
   5362	    09F6  66| B9 00000001		 mov	 ecx, 01h
   5363	    09FC  B0 42				 mov	 al, 'B'
   5364	    09FE  0E E8	FF82			 CALL	 SetErrorFlag	 ; call	the routine
   5365	    0A02  CD 08				 int 08h
   5366	    0A04  66| CF			 iretd
   5367	    0A06			 OtherBegin1	  ENDP
   5368					 ;***************************************************************************
   5369					 ;OtherBegin2 Procedure, 2 interrupt
   5370					 ;***************************************************************************
   5371	    0A06			 OtherBegin2	  PROC	  FAR
   5372	    0A06  0E E8	FF52			 call	 PrintStackException ; print stack entries
   5373	    0A0A  FA				 cli
   5374	    0A0B  66| B9 00000002		 mov	 ecx, 02h
   5375	    0A11  B0 43				 mov	 al, 'C'
   5376	    0A13  0E E8	FF6D			 CALL	 SetErrorFlag	 ; call	the routine
   5377	    0A17  CD 08				 int 08h
   5378	    0A19  66| CF			 iretd
   5379	    0A1B			 OtherBegin2	  ENDP
   5380					 ;***************************************************************************
   5381					 ;OtherBegin3 Procedure, 3 interrupt
   5382					 ;***************************************************************************
   5383	    0A1B			 OtherBegin3	  PROC	  FAR
   5384	    0A1B  0E E8	FF3D			 call	 PrintStackException ; print stack entries
   5385	    0A1F  FA				 cli
   5386	    0A20  66| B9 00000003		 mov	 ecx, 03h
   5387	    0A26  B0 44				 mov	 al, 'D'
   5388	    0A28  0E E8	FF58			 CALL	 SetErrorFlag	 ; call	the routine
   5389	    0A2C  CD 08				 int 08h
   5390	    0A2E  66| CF			 iretd
   5391
   5392	    0A30			 OtherBegin3	  ENDP
   5393					 ;***************************************************************************
   5394					 ;OtherBegin4 Procedure, 4 interrupt
   5395					 ;***************************************************************************
   5396	    0A30			 OtherBegin4	  PROC	  FAR
   5397	    0A30  0E E8	FF28			 call	 PrintStackException ; print stack entries
   5398	    0A34  FA				 cli
   5399	    0A35  66| B9 00000004		 mov	 ecx, 04h
   5400	    0A3B  B0 45				 mov	 al, 'E'
   5401	    0A3D  0E E8	FF43			 CALL	 SetErrorFlag	 ; call	the routine
   5402	    0A41  CD 08				 int 08h
   5403	    0A43  66| CF			 iretd
   5404	    0A45			 OtherBegin4	  ENDP
   5405					 ;***************************************************************************
   5406					 ;OtherBegin5 Procedure, 5 interrupt
   5407					 ;***************************************************************************
   5408	    0A45			 OtherBegin5	  PROC	  FAR
   5409	    0A45  0E E8	FF13			 call	 PrintStackException ; print stack entries
   5410	    0A49  FA				 cli
   5411	    0A4A  66| B9 00000005		 mov	 ecx, 05h
   5412	    0A50  B0 46				 mov	 al, 'F'
   5413	    0A52  0E E8	FF2E			 CALL	 SetErrorFlag	 ; call	the routine
   5414	    0A56  CD 08				 int 08h
   5415	    0A58  66| CF			 iretd
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 96
prcycle.ASM



   5416	    0A5A			 OtherBegin5	  ENDP
   5417					 ;***************************************************************************
   5418					 ;OtherBegin6 Procedure, 6 interrupt
   5419					 ;***************************************************************************
   5420	    0A5A			 OtherBegin6	  PROC	  FAR
   5421	    0A5A  0E E8	FEFE			 call	 PrintStackException ; print stack entries
   5422	    0A5E  FA				 cli
   5423	    0A5F  66| B9 00000006		 mov	 ecx, 06h
   5424	    0A65  B0 47				 mov	 al, 'G'
   5425	    0A67  0E E8	FF19			 CALL	 SetErrorFlag	 ; call	the routine
   5426	    0A6B  CD 08				 int 08h
   5427	    0A6D  66| CF			 iretd
   5428	    0A6F			 OtherBegin6	  ENDP
   5429					 ;***************************************************************************
   5430					 ;OtherBegin7 Procedure, 7 interrupt
   5431					 ;***************************************************************************
   5432	    0A6F			 OtherBegin7	  PROC	  FAR
   5433	    0A6F  0E E8	FEE9			 call	 PrintStackException ; print stack entries
   5434	    0A73  FA				 cli
   5435	    0A74  66| B9 00000007		 mov	 ecx, 07h
   5436	    0A7A  B0 48				 mov	 al, 'H'
   5437	    0A7C  0E E8	FF04			 CALL	 SetErrorFlag	 ; call	the routine
   5438	    0A80  CD 08				 int 08h
   5439	    0A82  66| CF			 iretd
   5440	    0A84			 OtherBegin7	  ENDP
   5441					 ;***************************************************************************
   5442					 ;OtherBegin10 Procedure, 10 interrupt
   5443					 ;This exception will be generated when	the TSS	is invalid
   5444					 ;***************************************************************************
   5445	    0A84			 OtherBegin10	   PROC	   FAR
   5446	    0A84  0E E8	FED4			 call	 PrintStackException ; print stack entries
   5447	    0A88  FA				 cli
   5448	    0A89  66| B9 0000000A		 mov	 ecx, 10
   5449	    0A8F  B0 49				 mov	 al, 'I'
   5450	    0A91  0E E8	FEEF			 CALL	 SetErrorFlag	 ; call	the routine
   5451	    0A95  CD 08				 int 08h
   5452	    0A97  66| CF			 iretd
   5453	    0A99			 OtherBegin10	   ENDP
   5454					 ;***************************************************************************
   5455					 ;OtherBegina11	Procedure, 11 interrupt
   5456					 ;***************************************************************************
   5457	    0A99			 OtherBegin11	   PROC	   FAR
   5458	    0A99  0E E8	FEBF			 call	 PrintStackException ; print stack entries
   5459	    0A9D  FA				 cli
   5460	    0A9E  66| B9 0000000B		 mov	 ecx, 11
   5461	    0AA4  B0 4A				 mov	 al, 'J'
   5462	    0AA6  0E E8	FEDA			 CALL	 SetErrorFlag	 ; call	the routine
   5463	    0AAA  CD 08				 int 08h
   5464	    0AAC  66| CF			 iretd
   5465
   5466	    0AAE			 OtherBegin11	   ENDP
   5467					 ;***************************************************************************
   5468					 ;OtherBegina12	Procedure, 12 interrupt
   5469					 ;***************************************************************************
   5470	    0AAE			 OtherBegin12	   PROC	   FAR
   5471	    0AAE  0E E8	FEAA			 call	 PrintStackException ; print stack entries
   5472	    0AB2  FA				 cli
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 97
prcycle.ASM



   5473	    0AB3  66| B9 0000000C		 mov	 ecx, 12
   5474	    0AB9  B0 4B				 mov	 al, 'K'
   5475	    0ABB  0E E8	FEC5			 CALL	 SetErrorFlag	 ; call	the routine
   5476	    0ABF  CD 08				 int 08h
   5477	    0AC1  66| CF			 iretd
   5478	    0AC3			 OtherBegin12	   ENDP
   5479					 ;***************************************************************************
   5480					 ;OtherBegina13	Procedure, 13 interrupt
   5481					 ;***************************************************************************
   5482	    0AC3			 OtherBegin13	   PROC	   FAR
   5483					 ; cli and sti is needed to prevent timer interrupts
   5484
   5485	    0AC3  FA				 cli
   5486	    0AC4  66| 50			 push	 eax
   5487	    0AC6  66| 53			 push	 ebx
   5488	    0AC8  0F A0				 push	 fs
   5489	    0ACA  0E E8	FE8E			 call	 PrintStackException ; print stack entries
   5490						 ;cli
   5491						 ;mov	 ecx, 13	 ; pass	Interrupt code
   5492						 ;mov	 al, 'L'	 ; pass	print character
   5493						 ;CALL	 SetErrorFlag	 ; set the error flag and controls
   5494						 ;int 08h		  ; call interrrupt to give control to error handler
   5495	    0ACE  B0 4C				 mov al, 'L'
   5496	    0AD0  66| BB 00000F8C		 mov ebx, 3980
   5497	    0AD6  CD F7				 int 0f7h
   5498	    0AD8  66| B8 00000000		 mov eax, 0
   5499	    0ADE  8C C8				 mov ax, cs
   5500	    0AE0  66| BB 00000334		 mov ebx, 820
   5501	    0AE6  CD FD				 int 0fdh
   5502	    0AE8  8C D0				 mov ax, ss
   5503	    0AEA  66| BB 00000348		 mov ebx, 840
   5504	    0AF0  CD FD				 int 0fdh
   5505	    0AF2  66| 8B C4			 mov eax, esp
   5506	    0AF5  66| BB 0000035C		 mov ebx, 860
   5507	    0AFB  CD FD				 int 0fdh
   5508	    0AFD  66| 8B C5			 mov eax, ebp
   5509	    0B00  66| BB 00000370		 mov ebx, 880
   5510	    0B06  CD FD				 int 0fdh
   5511	    0B08  66| B8 00000000		 mov eax, 0
   5512	    0B0E  0F 00	C0			 sldt ax
   5513	    0B11  66| BB 00000384		 mov ebx, 900
   5514	    0B17  CD FD				 int 0fdh
   5515	    0B19  66| B8 00000000		 mov eax, 0
   5516	    0B1F  0F 00	C8			 str ax
   5517	    0B22  66| BB 00000398		 mov ebx, 920
   5518	    0B28  CD FD				 int 0fdh
   5519	    0B2A  B8 0018			 mov ax, RData_Sel
   5520	    0B2D  8E E0				 mov fs, ax
   5521	    0B2F  66| B8 00000000		 mov eax, 0
   5522	    0B35  64: 0F 01 06 0168		 sgdt fs:[168h]
   5523	    0B3B  66| 64: A1 016A		 mov  eax,  fs:[16ah]
   5524	    0B40  66| BB 000003AC		 mov  ebx, 940
   5525	    0B46  CD FD				 int 0fdh
   5526	    0B48  66| B8 00000000		 mov eax, 0
   5527	    0B4E  66| 64: A1 0168		 mov  eax,  fs:[168h]
   5528	    0B53  66| BB 000003C0		 mov  ebx, 960
   5529	    0B59  CD FD				 int 0fdh
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 98
prcycle.ASM



   5530
   5531	    0B5B  CD F5				 int 0f5h
   5532	    0B5D  CD F5				 int 0f5h
   5533	    0B5F  CD F5				 int 0f5h
   5534	    0B61  CD F5				 int 0f5h
   5535
   5536
   5537
   5538
   5539							 ;-----------------------------------------------------------------
   5540							 ;changed this code on 7-7-2004
   5541	    0B63  66| 52				 push	 edx
   5542	    0B65  66| 9C				 pushfd	; turn off NT flag in the CPU not in the TSS
   5543							 ; so that CPU will return to its application during IRETD not to
   5544							 ;  exit from the task using link field	in the TSS
   5545	    0B67  66| 5A				 pop	 edx
   5546	    0B69  66| 81 E2 FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   5547	    0B70  66| 52				 push	 edx
   5548	    0B72  66| 9D				 popfd
   5549	    0B74  66| 5A				 pop	 edx
   5550							 ;-----------------------------------------------------------------
   5551	    0B76  1F				 pop	 ds
   5552	    0B77  66| 5B			 pop	 ebx
   5553	    0B79  66| 58			 pop	 eax
   5554
   5555	    0B7B  FB				 sti
   5556	    0B7C  66| CF			 iretd		 ; after sti, no more instructions before iretd
   5557	    0B7E			 OtherBegin13	   ENDP
   5558
   5559					 ;***************************************************************************
   5560					 ;OtherBegina219 Procedure  , 219 interrupt
   5561					 ;***************************************************************************
   5562	    0B7E			 OtherBegin219	    PROC    FAR
   5563						 ;call	 PrintStackException ; print stack entries
   5564	    0B7E  FA				 cli
   5565					 ;	 mov	 ecx, 219
   5566					 ;	 mov	 al, 'M'
   5567					 ;	 CALL	 SetErrorFlag	 ; call	the routine
   5568					 ;	 int 08h
   5569	    0B7F  FB				 sti
   5570	    0B80  66| CF			 iretd
   5571	    0B82			 OtherBegin219	    ENDP
   5572
   5573					 ;***************************************************************************
   5574					 ; OtherBegin73	interrupt routine for NIC
   5575					 ;***************************************************************************
   5576	    0B82			 OtherBegin73	   PROC	   FAR
   5577	    0B82  FA				 cli	     ; no more interrupts
   5578	    0B83  66| 50		  push eax
   5579	    0B85  66| 52		  push edx
   5580	    0B87  66| 51		  push ecx
   5581	    0B89  66| 53		  push ebx
   5582	    0B8B  66| 57		  push edi
   5583	    0B8D  66| 56		  push esi
   5584	    0B8F  0F A0			  push fs
   5585					 ;------------------------------------------------------------------------
   5586					 ; this	code only for NIC interrupt and	TxComplete interrupt
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 99
prcycle.ASM



   5587					 ;  every transmit results in an interrupt
   5588					 ; we save txstatus in DPD location 24
   5589					 ;  we write some thing	into the txstatus to advance to	next level
   5590					 ;------------------------------------------------------------------------
   5591	    0B91  66| 33 C0			 xor  eax, eax
   5592	    0B94  66| 33 D2			 xor  edx, edx
   5593
   5594						 ; first check if TxComplete bit is set
   5595						 ;  because IRQ11 is shared by many interrupts
   5596	    0B97  B8 00C0			 mov	 ax, MEMData_Sel; This is a zero base selector to access shared	memory	    +
   5597					 between aoa and application
   5598	    0B9A  8E E0				 mov	 fs, ax
   5599	    0B9C  66| BB 00008600		 mov ebx, S_Base
   5600	    0BA2  66| 81 C3 0000009C		 add ebx, S_IOBASE
   5601	    0BA9  66| 64: 67| 8B 33		 mov esi, DWORD	PTR fs:[ebx]  ;	get IOBASE
   5602
   5603					 ;-------------------------------------------------------------------
   5604						 ;mov	 eax, esi   ; stall the	transmitter
   5605						 ;mov	 dx, ax
   5606						 ;add	 dx, 0eh
   5607						 ;mov	 ax, 3002h
   5608						 ;out	 dx, ax
   5609					 ;W_End1:
   5610						 ;in	  ax, dx
   5611						 ;and	  ax, 1000h			  ;Check status
   5612						 ;jnz	  W_End1
   5613					 ;-------------------------------------------------------------------
   5614	    0BAE  66| 8B D6			 mov  edx, esi		 ;check	TxStatus if TxComplete
   5615	    0BB1  66| 83 C2 1B			 add  edx, 1bh
   5616	    0BB5  EC				 in   al, dx
   5617
   5618	    0BB6  66| 8B F8			 mov	 edi, eax ; save the status
   5619
   5620
   5621	    0BB9  24 80				 and  al, 80h  ; check for bit 7
   5622	    0BBB  0F 84	01D2			 jz   not_NIC  ; if not	set then this is not our interrupt
   5623
   5624
   5625	    0BBF  EC				 in   al, dx   ; dx is still same
   5626	    0BC0  EE				 out  dx, al   ;write to status	register to advance xmitter
   5627
   5628	    0BC1  66| 8B D6			 mov  edx, esi
   5629	    0BC4  66| 83 C2 0E			 add  edx, 0eh		 ;Command window
   5630	    0BC8  B8 68FF			 mov  ax, 68ffh		 ; acknowledge all interrupts
   5631	    0BCB  EF				 out  dx, ax
   5632
   5633	    0BCC  66| BB 00008600		 mov	 ebx, S_Base
   5634	    0BD2  66| 81 C3 000000A8		 add	 ebx, S_DPD_Count  ; counter
   5635	    0BD9  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5636	    0BDE  66| B9 00000020		 mov	 ecx, 32	 ; results are in edx:eax
   5637	    0BE4  66| F7 E1			 mul	 ecx		 ; 32 byte for each DPD	entry
   5638	    0BE7  66| BA 0230BF40		 mov	 edx, 0230bf40h	 ; DPD start address hard coded
   5639	    0BED  66| 03 D0			 add	 edx, eax
   5640	    0BF0  66| 83 C2 18			 add	 edx, 18h	 ; TxStatus location in	the DPD
   5641
   5642	    0BF4  66| 8B C7			 mov	 eax, edi	 ; get the txstatus stored in the regiser
   5643
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 100
prcycle.ASM



   5644						 ;-----------------------------------------------------------------------
   5645						 ; this	change allows to add other control bits	in the DPD slot	location 24
   5646	    0BF7  66| 25 000000FF		 and	 eax, 0ffh	; mask all other 12 bits, status is in last 4 bits
   5647	    0BFD  66| 64: 67| 8B 0A		 mov	 ecx, DWORD PTR	fs:[edx] ; get current contents
   5648	    0C02  66| 0B C1			 or	 eax, ecx	 ; only	store the status in 4 bits
   5649						 ;-----------------------------------------------------------------------
   5650	    0C05  66| 64: 67| 89 02		 mov	 DWORD PTR fs:[edx], eax   ; store it in the DPD
   5651						 ; TxStatus is stored in DPD at	24 for future reference
   5652	    0C0A  66| 50			 push	 eax		  ; save the DPD status	word
   5653
   5654						 ;-----------------------------------------------------------------------
   5655	    0C0C  66| 25 FFFF00FF		 and	 eax, 0ffff00ffh   ; reset the send type byte to 0
   5656	    0C12  66| 64: 67| 89 02		 mov	 DWORD PTR fs:[edx], eax   ; store it in the DPD, next time no recount of   +
   5657					 this field
   5658						 ;-----------------------------------------------------------------------
   5659
   5660	    0C17  66| BB 00008600		 mov	 ebx, S_Base
   5661	    0C1D  66| 81 C3 000000A8		 add	 ebx, S_DPD_Count  ; counter
   5662	    0C24  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5663	    0C29  66| 40			 inc	 eax   ; increment the count
   5664	    0C2B  66| 3D 00002710		 cmp	 eax, 10000	 ; hardcoded DPD size value
   5665	    0C31  75 06				 jnz	 skipreset	 ; no need to reset the	counter
   5666	    0C33  66| B8 00000000		 mov	 eax, 0		 ; loop	back again circular list
   5667	    0C39				 skipreset:
   5668	    0C39  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store value
   5669
   5670	    0C3E  66| BB 00008600		 mov	 ebx, S_Base
   5671	    0C44  66| 81 C3 000000A4		 add	 ebx, S_Total_Tx_Count	; counts no of interrupts received for Txt
   5672	    0C4B  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5673	    0C50  66| 40			 inc	 eax   ; increment the count
   5674	    0C52  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5675						 ;-----------------------------------------------------------------
   5676						 ; we also update specific counters for	header,	data, and ack packets
   5677						 ;  to keep track of how many of these were served by NIC card which
   5678						 ;  is indicated by received interrupts
   5679						 ; so that packets transmitted in the application can be checked
   5680						 ;  against the	packets	transmitted by NIC using interrupt count
   5681
   5682	    0C57  66| 58			 pop	 eax	 ; this	is the DPD status
   5683	    0C59  66| 8B C8			 mov	 ecx, eax    ; save eax	in ecx
   5684
   5685						 ; count synack	 code 01
   5686	    0C5C  66| 25 0000FF00		 and	 eax, 0000ff00h
   5687	    0C62  66| 3D 00000100		 cmp	 eax, 00000100h
   5688	    0C68  75 19				 jnz	 skipsynack
   5689	    0C6A  66| BB 00008600		 mov	 ebx, S_Base
   5690	    0C70  66| 81 C3 00000100		 add	 ebx, S_ITCP_SACK_Count
   5691	    0C77  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5692	    0C7C  66| 40			 inc	 eax   ; increment the count
   5693	    0C7E  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5694	    0C83				 skipsynack:
   5695
   5696						 ; count getack	code 02
   5697	    0C83  66| 8B C1			 mov	 eax, ecx
   5698	    0C86  66| 25 0000FF00		 and	 eax, 0000ff00h
   5699	    0C8C  66| 3D 00000200		 cmp	 eax, 00000200h
   5700	    0C92  75 19				 jnz	 skipgetack
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 101
prcycle.ASM



   5701	    0C94  66| BB 00008600		 mov	 ebx, S_Base
   5702	    0C9A  66| 81 C3 00000104		 add	 ebx, S_ITCP_GACK_Count
   5703	    0CA1  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5704	    0CA6  66| 40			 inc	 eax   ; increment the count
   5705	    0CA8  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5706	    0CAD				 skipgetack:
   5707
   5708						 ; count header	code 03
   5709	    0CAD  66| 8B C1			 mov	 eax, ecx
   5710	    0CB0  66| 25 0000FF00		 and	 eax, 0000ff00h
   5711	    0CB6  66| 3D 00000300		 cmp	 eax, 00000300h
   5712	    0CBC  75 19				 jnz	 skipheader
   5713	    0CBE  66| BB 00008600		 mov	 ebx, S_Base
   5714	    0CC4  66| 81 C3 00000108		 add	 ebx, S_ITCP_HDR_Count
   5715	    0CCB  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5716	    0CD0  66| 40			 inc	 eax   ; increment the count
   5717	    0CD2  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5718	    0CD7				 skipheader:
   5719
   5720						 ; count data packets code 04
   5721	    0CD7  66| 8B C1			 mov	 eax, ecx    ; restore TxStatus
   5722	    0CDA  66| 25 0000FF00		 and	 eax, 0000ff00h
   5723	    0CE0  66| 3D 00000400		 cmp	 eax, 00000400h
   5724	    0CE6  75 19				 jnz	 skipdata
   5725	    0CE8  66| BB 00008600		 mov	 ebx, S_Base
   5726	    0CEE  66| 81 C3 0000010C		 add	 ebx, S_ITCP_DAT_Count
   5727	    0CF5  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5728	    0CFA  66| 40			 inc	 eax   ; increment the count
   5729	    0CFC  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5730	    0D01				 skipdata:
   5731
   5732						 ; count finack	code 05
   5733	    0D01  66| 8B C1			 mov	 eax, ecx
   5734	    0D04  66| 25 0000FF00		 and	 eax, 0000ff00h
   5735	    0D0A  66| 3D 00000500		 cmp	 eax, 00000500h
   5736	    0D10  75 19				 jnz	 skipfinack
   5737	    0D12  66| BB 00008600		 mov	 ebx, S_Base
   5738	    0D18  66| 81 C3 00000110		 add	 ebx, S_ITCP_FACK_Count
   5739	    0D1F  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5740	    0D24  66| 40			 inc	 eax   ; increment the count
   5741	    0D26  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5742	    0D2B				 skipfinack:
   5743
   5744						 ; count resets	code 06
   5745	    0D2B  66| 8B C1			 mov	 eax, ecx
   5746	    0D2E  66| 25 0000FF00		 and	 eax, 0000ff00h
   5747	    0D34  66| 3D 00000600		 cmp	 eax, 00000600h
   5748	    0D3A  75 19				 jnz	 skipresets
   5749	    0D3C  66| BB 00008600		 mov	 ebx, S_Base
   5750	    0D42  66| 81 C3 00000114		 add	 ebx, S_ITCP_RESET_Count
   5751	    0D49  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5752	    0D4E  66| 40			 inc	 eax   ; increment the count
   5753	    0D50  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5754	    0D55				 skipresets:
   5755
   5756						 ; count ARP code 07
   5757	    0D55  66| 8B C1			 mov	 eax, ecx
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 102
prcycle.ASM



   5758	    0D58  66| 25 0000FF00		 and	 eax, 0000ff00h
   5759	    0D5E  66| 3D 00000700		 cmp	 eax, 00000700h
   5760	    0D64  75 19				 jnz	 skiparps
   5761	    0D66  66| BB 00008600		 mov	 ebx, S_Base
   5762	    0D6C  66| 81 C3 00000118		 add	 ebx, S_ITCP_ARP_Count
   5763	    0D73  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5764	    0D78  66| 40			 inc	 eax   ; increment the count
   5765	    0D7A  66| 64: 67| 89 03		 mov	 DWORD PTR fs:[ebx],eax	 ; store new value
   5766	    0D7F				 skiparps:
   5767						 ;-----------------------------------------------------------------
   5768
   5769						 ;mov	 ebx, 3200
   5770						 ;int	 0fdh
   5771
   5772	    0D7F  66| BB 00008600		 mov	 ebx, S_Base
   5773	    0D85  66| 81 C3 000000A8		 add	 ebx, S_DPD_Count  ; counter
   5774	    0D8C  66| 64: 67| 8B 03		 mov	 eax, DWORD PTR	fs:[ebx]  ; get	the counter value
   5775						 ;mov	 ebx, 3220
   5776						 ;int	 0fdh
   5777
   5778	    0D91			 not_NIC:
   5779					 ;-------------------------------------------------------------------
   5780						 ;mov	 eax, esi   ; unstall the transmitter
   5781						 ;mov	 dx, ax
   5782						 ;add	 dx, 0eh
   5783						 ;mov	 ax, 3003h
   5784						 ;out	 dx, ax
   5785					 ;W_End2:
   5786						 ;in	  ax, dx
   5787						 ;and	  ax, 1000h			  ;Check status
   5788						 ;jnz	  W_End2
   5789					 ;-------------------------------------------------------------------
   5790	    0D91  B8 00A0			 mov	 ax, 0a0h  ;ack	PIC 2
   5791	    0D94  8B D0				 mov	 dx, ax
   5792	    0D96  B0 20				 mov	 al, 020h
   5793	    0D98  EE				 out	 dx, al
   5794	    0D99  B8 0020			 mov	 ax, 020h  ;ack	PIC 1
   5795	    0D9C  8B D0				 mov	 dx, ax
   5796	    0D9E  B0 20				 mov	 al, 020h
   5797	    0DA0  EE				 out	 dx, al
   5798
   5799	    0DA1  0F A1			 pop fs
   5800	    0DA3  66| 5E		 pop esi
   5801	    0DA5  66| 5F		 pop edi
   5802	    0DA7  66| 5B		 pop ebx
   5803	    0DA9  66| 59		 pop ecx
   5804	    0DAB  66| 5A		 pop edx
   5805	    0DAD  66| 58		 pop eax
   5806							 ;-----------------------------------------------------------------
   5807							 ;changed this code on 7-7-2004
   5808	    0DAF  66| 52				 push	 edx
   5809	    0DB1  66| 9C				 pushfd	; turn off NT flag in the CPU not in the TSS
   5810							 ; so that CPU will return to its application during IRETD not to
   5811							 ;  exit from the task using link field	in the TSS
   5812	    0DB3  66| 5A				 pop	 edx
   5813	    0DB5  66| 81 E2 FFFFBFFF			 AND	 edx, 0FFFFBFFFh
   5814	    0DBC  66| 52				 push	 edx
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 103
prcycle.ASM



   5815	    0DBE  66| 9D				 popfd
   5816	    0DC0  66| 5A				 pop	 edx
   5817							 ;-----------------------------------------------------------------
   5818
   5819	    0DC2  FB					 sti	 ; enable interrupts
   5820	    0DC3  66| CF				 iretd
   5821
   5822	    0DC5			 OtherBegin73	   ENDP
   5823
   5824		  = RCODESEG:0DC5	 RCodeLen     =	      $
   5825					 ;-----------------------------------------------------------------
   5826	    0DC5			 RCodeSeg	 ENDS
   5827							 END	 Start
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 104
Symbol Table




Symbol Name		Type   Value			   Cref	(defined at #)

??0000			Near   PCODESEG:00AF		   3142	 #3144
??0001			Near   PCODESEG:00B9		   3147	 #3149
??0002			Near   PCODESEG:00BC		   #3151  3154
??0003			Near   PCODESEG:00CA		   #3161  3164
??0004			Near   PCODESEG:00D8		   #3171  3174
??0005			Near   PCODESEG:0102		   3188	 #3190
??0006			Near   PCODESEG:010C		   3193	 #3195
??0007			Near   PCODESEG:010F		   #3197  3200
??0008			Near   PCODESEG:011D		   #3207  3210
??0009			Near   PCODESEG:012B		   #3217  3220
??DATE			Text   "08/29/16"
??FILENAME		Text   "prcycle	"
??TIME			Text   "14:48:15"
??VERSION		Number 0205
@CPU			Text   0D8FH			   #19
@CURSEG			Text   RCODESEG			   #577	 #1130	#1150  #1169  #1192  #1210  #1228  #1244  #1327	 #1354	  +
							   #1391  #1429	 #1468	#1507  #1546  #1591  #1647  #1686  #1775  #1814	  +
							   #1823  #1843	 #1853	#1863  #1874  #1883  #1892  #1902  #1912  #1931	  +
							   #1949  #1964	 #2099	#3067  #3624  #3648  #3934
@FILENAME		Text   PRCYCLE
@WORDSIZE		Text   2			   #19	#577  #1130  #1150  #1169  #1192  #1210	 #1228	#1244  #1327	  +
							   #1354  #1391	 #1429	#1468  #1507  #1546  #1591  #1647  #1686  #1775	  +
							   #1814  #1823	 #1843	#1853  #1863  #1874  #1883  #1892  #1902  #1912	  +
							   #1931  #1949	 #1964	#2099  #3067  #3624  #3648  #3934
A2LDT			Byte   APP2LDTSEG:0000		   #1329  1333	1338  1342  1344
ABDTEMP			Dword  RDATASEG:01DB		   #3879
ALDT			Byte   APP1LDTSEG:0000		   #1246  1274	1292  1297  1300  1311	1315  1319  1321  4052
ALTSTAT			Byte   RDATASEG:0302		   3099	 3115  #3905
ANYCOUNTER		Dword  RDATASEG:01CD		   #3872  4929	4942  4944  4957
AOADISP			Near   ----:---- Extern		   #549	 4600
AOAMINIL1		Near   ----:---- Extern		   #551	 4687
AOAMINIW1		Near   ----:---- Extern		   #552	 4786
APP1CODE		Struct APP1LDTSEG:0010 DESC	   #1293  1297
APP1CODE_SEL		Number 0014			   #1297  1298	1630
APP1DATA		Struct APP1LDTSEG:0008 DESC	   #1290  1292
APP1DATA_SEL		Number 000C			   #1292  1629	1632
APP1LDNUM		Number 0007			   #1321  4051
APP1LDT			Struct RDATASEG:00D8 DESC	   #3749  3830
APP1LDTLEN		Number APP1LDTSEG:0038		   #1322  3749	3764  3770
APP1LDT_SEL		Number 00D8			   1635	 #3830
APP1STACK		Struct APP1LDTSEG:0000 DESC	   #1272  1274
APP1STACK0		Struct APP1LDTSEG:0020 DESC	   #1309  1311
APP1STACK0_SEL		Number 0024			   #1311  1596
APP1STACK1		Struct APP1LDTSEG:0028 DESC	   #1313  1315
APP1STACK1_SEL		Number 002C			   #1315  1598
APP1STACK2		Struct APP1LDTSEG:0030 DESC	   #1317  1319
APP1STACK2_SEL		Number 0034			   #1319  1600
APP1STACKLEN		Number 0200			   #1903  1904
APP1STACK_SEL		Number 0004			   #1274  1631
APP1TASKTSS		Byte   APP1TSSSEG:0000		   #1593  5019	5087  5144  5208
APP1TSS			Struct RDATASEG:00C8 DESC	   #3745  3822
APP1TSSADDR		Dword  RDATASEG:0413		   #3919  4020
APP1TSSC		Struct RDATASEG:00E0 DESC	   #3751  3823
APP1TSSC_SEL		Number 00E0			   1089	 #3823
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 105
Symbol Table



APP1TSSE		Struct RDATASEG:00F8 DESC	   #3757  3825
APP1TSSE_SEL		Number 00F8			   #3825
APP1TSSLEN		Number APP1TSSSEG:0070		   #1641  3745	3747  3751  3753  3841
APP1TSSRW		Struct RDATASEG:00D0 DESC	   #3747  3828
APP1TSSRW_SEL		Number 00D0			   #3828  5010	5085  5142
APP1TSSS		Struct RDATASEG:00E8 DESC	   #3753  3824
APP1TSSS_SEL		Number 00E8			   1075	 #3824
APP1TSST		Struct RDATASEG:00F0 DESC	   #3755  3826
APP1TSST_SEL		Number 00F0			   #3826
APP1TSS_SEL		Number 00C8			   1119	 #3822
APP1_SCH_GATE		Struct APP1LDTSEG:0018 GATE	   #1298  1300
APP1_SCH_SEL		Number 001C			   #1300
APP2CODE		Struct APP2LDTSEG:0010 DESC	   #1339  1342
APP2CODE_SEL		Number 0014			   #1342  1668
APP2DATA		Struct APP2LDTSEG:0008 DESC	   #1334  1338
APP2DATA_SEL		Number 000C			   #1338  1667	1670
APP2LDNUM		Number 0003			   #1344
APP2LDT			Struct RDATASEG:0110 DESC	   #3764  3831
APP2LDTC		Struct RDATASEG:0128 DESC	   #3770
APP2LDTLEN		Number APP2LDTSEG:0018		   #1345
APP2LDT_SEL		Number 0110			   1673	 #3831
APP2STACK		Struct APP2LDTSEG:0000 DESC	   #1331  1333
APP2STACK_SEL		Number 0004			   #1333  1669
APP2TASKTSS		Byte   APP2TSSSEG:0000		   #1648  5048	5226
APP2TSS			Struct RDATASEG:0100 DESC	   #3760  3827
APP2TSSC		Struct RDATASEG:0118 DESC	   #3766
APP2TSSLEN		Number APP2TSSSEG:0400		   #1678  3760	3762  3766  3768
APP2TSSRW		Struct RDATASEG:0108 DESC	   #3762  3829
APP2TSSRWC		Struct RDATASEG:0120 DESC	   #3768
APP2TSSRW_SEL		Number 0108			   #3829  5043	5205  5220
APP2TSS_SEL		Number 0100			   1109	 #3827
APPGDTPTR		Dword  RDATASEG:01DF		   #3880  4029
APPL1RELOCATE		Number 0000			   #563	 1272  1290  1293  1309	 1313  1317  1331  1334	 1339  1720
APPLNUM			Byte   ----:---- Extern		   #546	 4972
APPSCHEDULE		Far    DEMOCODESEG:008C		   1745	 #2235
APP_SCHEDULER_GATE	Struct DEMOLDTSEG:0078 GATE	   #1745  1761
APP_SCHEDULER_SEL	Number 007C			   #1761
ASCII			Byte   RDATASEG:0307		   3241	 3242  3247  3270  3273	 3279  3283  3287  3291	 3295  3299  3303 +
							   3307	 3311  3315  3319  3323	 3327  3331  3335  3339	 3343  3347  3351 +
							   3355	 3359  3363  3367  3434	 #3910
AT386CGATE		Number 008C			   #380	 1298  1739  1741  1743	 1745  1747  1749  1751	 1754
AT386IGATE		Number 008E			   #381	 835
AT386TGATE		Number 008F			   #382	 583  585  587	589  591  593  595  597	 599  601  603	605  607  +
							   609	611  614  621  623  625	 627  629  631	633  635  637  639  641	  +
							   643	645  647  649  651  653	 655  657  659	661  663  665  667  669	  +
							   671	673  675  677  679  681	 683  685  687	689  691  693  695  697	  +
							   699	701  703  705  707  709	 711  713  715	717  719  721  723  725	  +
							   727	729  731  733  735  737	 739  741  743	745  747  749  751  753	  +
							   755	757  759  761  763  765	 767  769  771	773  775  777  779  781	  +
							   783	785  787  789  791  793	 795  797  799	801  803  805  807  809	  +
							   811	813  815  817  819  826	 828  830  844	846  848  850  852  854	  +
							   856	858  860  862  864  866	 868  870  872	874  876  878  880  882	  +
							   884	886  888  890  892  894	 896  898  900	902  904  906  908  910	  +
							   912	914  916  918  920  922	 924  926  928	930  932  934  936  938	  +
							   940	942  944  946  948  950	 952  954  956	958  960  962  964  966	  +
							   968	970  972  974  976  978	 980  982  984	986  988  990  992  994	  +
							   996	998  1000  1002	 1004  1006  1008
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 106
Symbol Table



AT386TSS		Number 0089			   #379	 3688  3696  3698  3700	 3702  3704  3722  3745	 3751  3753  3760 +
							   3766
ATCCO			Number 009C			   #372
ATCCOR			Number 009E			   #373
ATCE			Number 0098			   #370	 1134  1154  1173  1196	 1214  1232  1293  1339	 1695  1697  1699 +
							   1720	 3692  3694  3718  3775	 3777  3781
ATCER			Number 009A			   #371
ATDR			Number 0090			   #366
ATDW			Number 0092			   #367	 1176  1290  1334  1689	 1691  1693  1701  1706	 1708  1710  1718 +
							   3677	 3679  3686  3716  3727	 3730  3747  3762  3768	 3773  3779
ATDWA			Number 0093			   #368	 1137  1157  1182  1199	 1217  1235
ATLDT			Number 0082			   #377	 3690  3706  3708  3710	 3712  3714  3720  3749	 3764  3770
ATSWA			Number 0096			   #369	 1331
ATTASKGATE		Number 0085			   #378	 1075  1089  1099  1107	 1109  1111  1113  1115	 1119  1121
BASEOFCODE		Number 0000			   #564	 1293  1339
BUFFER			Struct DEMOLDTSEG:0048 DESC	   #1710  1735
BUFFER_SEL		Number 004C			   #1735  2410
BXP1S			Dword  RDATASEG:041B		   #3923  4305	4858
BXPOINTER1		Dword  ----:---- Extern		   #548	 2400  2414  4304  4859	 4940  4948  4981  4992
CAPLOCK			Byte   RDATASEG:0304		   3132	 3133  3136  3140  3186	 3255  3261  #3907
CARRY1			Near   RCODESEG:0023		   3964	 #3967
CHAROUT			Near   DEMOCODESEG:0344		   2765	 #2769
CHAROUT1		Near   DEMOCODESEG:03CF		   2830	 2856  #2860
CLDT			Byte   GETCHARLDTSEG:0000	   #1152  1156	1159  1161  4072
CLEARNEXT		Near   DEMOCODESEG:0279		   #2642  2645
CLEARSCREEN		Near   ----:---- Extern		   #433
CLOCK_TICK_RATE		Number 001234DC			   #426	 427
CLSCREEN		Far    DEMOCODESEG:029E		   1093	 #2673
CMPEQUAL		Near   PCODESEG:03C4		   3424	 #3427
CMPEQUAL2		Near   PCODESEG:03E7		   3441	 #3444
CONTINUEREAD		Near   RCODESEG:0638		   4915	 #4935
CPY0200			Near   RCODESEG:0816		   5074	 #5138
CPY0200SKP		Near   RCODESEG:0888		   5133	 #5189
CTRLSTAT		Byte   RDATASEG:0301		   3095	 3111  #3904
CURSOROK		Near   DEMOCODESEG:033F		   2763	 #2766
CURSOROK1		Near   DEMOCODESEG:03CA		   2854	 #2857
D32			Number 0040			   #407	 1334  1689  1691  1695	 1697  1699  1701  1720	 3716  3718  3777 +
							   3781
DEMOBEGIN		Far    DEMOCODESEG:0000		   #2108  2139
DEMOCODE		Struct DEMOLDTSEG:0018 DESC	   #1695  1728
DEMOCODELEN		Number DEMOCODESEG:0465		   1695	 1697  1699  #3059  3718
DEMOCODE_SEL		Number 001F			   #1728  2138
DEMOLDNUM		Number 000C			   #1723  4096
DEMOLDT			Byte   DEMOLDTSEG:0000		   #1688  1723	1725  1726  1727  1728	1729  1730  1731  1732	1733  1734+
							   1735	 1737  1756  1758  1759	 1760  1761  1762  1763	 1764  1766  4095
DEMOLDTD		Struct RDATASEG:0028 DESC	   #3690  3795
DEMOLDTLEN		Number 00A0			   #1756  3690
DEMOLDT_SEL		Number 0028			   1800	 #3795	4250
DEMOSTACK0		Struct DEMOLDTSEG:0000 DESC	   #1689  1725
DEMOSTACK0LEN		Number 0200			   1689	 1777  #1815  1816  2135
DEMOSTACK0_SEL		Number 0004			   #1725  1778	2133
DEMOSTACK1		Struct DEMOLDTSEG:0008 DESC	   #1691  1726
DEMOSTACK1LEN		Number 01F6			   1691	 1779  #1824  1835
DEMOSTACK1_SEL		Number 000D			   #1726  1780
DEMOSTACK3		Struct DEMOLDTSEG:0010 DESC	   #1693  1727
DEMOSTACK3LEN		Number 0200			   1137	 1369  1693  #1844  1845  2137
DEMOSTACK3_SEL		Number 0017			   #1727  2136
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 107
Symbol Table



DEMOTSS			Struct RDATASEG:0020 DESC	   #3688  3793
DEMOTSSLEN		Number DEMOTSSSEG:006A		   #1805  3688	3779
DEMOTSSRW		Struct RDATASEG:0148 DESC	   #3779  3794
DEMOTSSRW_SEL		Number 0148			   #3794  5112	5168
DEMOTSS_SEL		Number 0020			   #3793  4248
DISPLAYBEGIN		Far    DEMOCODESEG:0444		   614	1105  #3025
DLDT			Byte   GETDECLDTSEG:0000	   #1194  1198	1201  1203  4080
DMADATA			Struct RDATASEG:0130 DESC	   #3773  3832
DMADATA_SEL		Number 0130			   #3832
DPL0			Number 0000			   #386	 1689
DPL1			Number 0020			   #387	 1691
DPL2			Number 0040			   #388
DPL3			Number 0060			   #389	 1298  1693  1695  1739	 1741  1743  1745  1747	 1749  1751  1754 +
							   3679
DUMMY			Struct RDATASEG:0000 DESC	   #3673
DUMMYDATA		Byte   GLOBALDATASEG:0000	   #1933
D_ADDROFFSET		Number 0011			   #536
EFFGDT			Byte   RDATASEG:0018		   #3681  3788	4152
EOICOM			Number 0020			   #559
ETHERDESC		Struct RDATASEG:0140 DESC	   #3777  3811
ETHERNETRECEIVECODELEN	Number ETHERNETRECEIVE:00E2	   #2089  3777
ETHERNETRECEIVE_SEL	Number 0140			   835	#3811
EXIT_GETINT32		Near   RCODESEG:0375		   4492	 #4511
FDC_INT			Far    DEMOCODESEG:03E4		   611	#2890
FINDIT			Near   PCODESEG:0517		   3562	 #3580
FLOPPYREADY		Byte   RDATASEG:01E3		   2900	 #3884
G4DATA			Struct RDATASEG:00B0 DESC	   #3724  3820
G4DATA_SEL		Number 00B0			   #3820  5312
GDNUM			Number 0028			   #3788  4151
GDT			Byte   RDATASEG:0000		   #3672  3787	3790  3791  3793  3794	3795  3796  3797  3798	3799  3800+
							   3801	 3802  3803  3804  3805	 3806  3807  3808  3809	 3810  3811  3813 +
							   3815	 3818  3819  3820  3822	 3823  3824  3825  3826	 3827  3828  3829 +
							   3830	 3831  3832  3833  3834	 4027
GDTLEN			Number 0158			   #3787  3848
GETC			Near   DEMOCODESEG:0396		   2827	 #2832
GETCHAR			Near   RCODESEG:02B1		   4385	 4386  #4388
GETCHAR1		Near   RCODESEG:02CF		   #4403
GETCHAR32		Far    DEMOCODESEG:02D4		   1101	 #2713
GETCHAR32BUFF		Far    DEMOCODESEG:0358		   1103	 #2800
GETCHARBEGIN		Far    RCODESEG:0299		   1438	 #4371	4437
GETCHARCODE		Struct GETCHARLDTSEG:0000 DESC	   #1154  1156
GETCHARCODE_SEL		Number 0004			   #1156  1449	4425
GETCHARLDNUM		Number 0002			   #1161  4071
GETCHARLDT		Struct RDATASEG:0070 DESC	   #3708  3805
GETCHARLDTLEN		Number GETCHARLDTSEG:0010	   #1162  3708
GETCHARLDT_SEL		Number 0070			   1454	 #3805
GETCHARSTACK		Struct GETCHARLDTSEG:0008 DESC	   #1157  1159
GETCHARSTACKLEN		Number 0200			   1157	 1444  #1854  1855
GETCHARSTACK_SEL	Number 000C			   #1159  1450	4428
GETCHARTSS		Struct RDATASEG:0040 DESC	   #3696  3800
GETCHARTSSLEN		Number GETCHARTSSSEG:0069	   #1458  3696
GETCHARTSS_SEL		Number 0040			   1115	 #3800
GETCHARV		Near   RCODESEG:02ED		   4424	 #4427
GETCURSOR		Far    DEMOCODESEG:01E6		   1095	 #2536
GETDEC			Near   RCODESEG:0317		   4455	 4456  #4457
GETDEC1			Near   RCODESEG:0335		   #4472
GETDECBEGIN		Far    RCODESEG:02FF		   1477	 #4442	4535
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 108
Symbol Table



GETDECCODE		Struct GETDECLDTSEG:0000 DESC	   #1196  1198
GETDECCODE_SEL		Number 0004			   #1198  1488	4524
GETDECLDNUM		Number 0002			   #1203  4079
GETDECLDT		Struct RDATASEG:0078 DESC	   #3710  3806
GETDECLDTLEN		Number GETDECLDTSEG:0010	   #1204  3710
GETDECLDT_SEL		Number 0078			   1493	 #3806
GETDECSTACK		Struct GETDECLDTSEG:0008 DESC	   #1199  1201
GETDECSTACKLEN		Number 0200			   1199	 1217  1483  #1875  1876
GETDECSTACK_SEL		Number 000C			   #1201  1489	4527
GETDECTSS		Struct RDATASEG:0048 DESC	   #3698  3801
GETDECTSSLEN		Number GETDECTSSSEG:0069	   #1497  3698
GETDECTSS_SEL		Number 0048			   1113	 #3801
GETDECV			Near   RCODESEG:038B		   4523	 #4526
GETKEY			Near   RCODESEG:03D2		   4578	 4581  #4584
GETKEY1			Near   RCODESEG:03E0		   #4593
GETKEYFORMENU		Near   ----:---- Extern		   #434
GETKEYV			Near   RCODESEG:0402		   4609	 #4611
GETNEXTDIGIT_GETINT	Near   RCODESEG:0342		   #4477  4504
GETSEC			Near   RCODESEG:045A		   4672	 4673  #4674
GETSEC1			Near   RCODESEG:0470		   #4685
GETSECBEGIN		Far    RCODESEG:0414		   1516	 #4631	4728
GETSECCODE		Struct GETSECLDTSEG:0000 DESC	   #1214  1216
GETSECCODE_SEL		Number 0004			   #1216  1527	1566  4697
GETSECLDNUM		Number 0002			   #1221  4087
GETSECLDT		Struct RDATASEG:0080 DESC	   #3712  3807
GETSECLDTLEN		Number GETSECLDTSEG:0010	   #1222  3712
GETSECLDT_SEL		Number 0080			   1532	 1571  #3807
GETSECSTACK		Struct GETSECLDTSEG:0008 DESC	   #1217  1219
GETSECSTACKLEN		Number 0200			   1522	 1561  #1884  1885
GETSECSTACK_SEL		Number 000C			   #1219  1528	1567  4699
GETSECTSS		Struct RDATASEG:0050 DESC	   #3700  3802
GETSECTSSLEN		Number GETSECTSSSEG:0069	   #1536  3700
GETSECTSS_SEL		Number 0050			   1111	 #3802
GETSECV			Near   RCODESEG:0485		   4696	 #4698
GETTASKPTR		Far    DEMOCODESEG:0412		   #2944
GET_PARAMETER		Near   ----:---- Extern		   #436
GKEYBEGIN		Far    RCODESEG:039E		   1363	 #4540	4621
GKEYCODE		Struct GKEYLDTSEG:0000 DESC	   #1134  1136
GKEYCODE_SEL		Number 0004			   #1136  1374	4610
GKEYLDNUM		Number 0002			   #1141  4063
GKEYLDT			Struct RDATASEG:0068 DESC	   #3706  3804
GKEYLDTLEN		Number GKEYLDTSEG:0010		   #1142  3706
GKEYLDT_SEL		Number 0068			   1379	 #3804
GKEYSTACK		Struct GKEYLDTSEG:0008 DESC	   #1137  1139
GKEYSTACK_SEL		Number 000C			   #1139  1375	4611
GKEYTSS			Struct RDATASEG:0060 DESC	   #3704  3799
GKEYTSSLEN		Number GKEYTSSSEG:0069		   #1383  3704
GKEYTSS_SEL		Number 0060			   1121	 #3799
GL			Number 0080			   #408
GLDT			Byte   GKEYLDTSEG:0000		   #1132  1136	1139  1141  4064
GLOBALDATA		Struct RDATASEG:00B8 DESC	   #3727  3813
GLOBALDATALEN		Number GLOBALDATASEG:0112	   1176	 #1941	3727
GLOBALDATA_SEL		Number 00B8			   #3813
GOBACKTOLOOP		Near   RCODESEG:027A		   4321	 #4335
GOBACKTOMENU		Near   RCODESEG:0956		   5218	 5225  #5265
GOSEARCH		Near   RCODESEG:025A		   4281	 #4322
GOTOPCODE		Struct DEMOLDTSEG:0058 DESC	   #1720  1737
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 109
Symbol Table



GOTOPCODE_SEL		Number 005C			   #1737  1754
GOTOPGATE		Struct DEMOLDTSEG:0098 GATE	   #1754  1766
GOTOPGATE_SEL		Number 009C			   #1766
GTCHAR			Near   PCODESEG:0495		   #3521  3531
HEXTABLE		Byte   RDATASEG:0158		   539	#3836
HEXTABLEP		Byte   PROTMODEPROCDATASEG:0000	   #1914  2200
HTIMERBEGIN		Far    DEMOCODESEG:0167		   599	#2438
HZ			Number 0064			   #425	 427  427
ICREGP			Number 0020			   #560
IDT			Byte   IDTSEG:0000		   #578	 1124
IDTLEN			Number 0800			   #1124  3849
IFL			Number 0200			   #412
ILDT			Near   RCODESEG:019A		   #4193  4204
IMASKREGV		Byte   RDATASEG:0198		   #3851  4046
IMREGP			Number 0021			   #561	 4045
INDEXCNT		Dword  RDATASEG:0168		   539	#3839
INDEXCNTP		Dword  PROTMODEPROCDATASEG:0010	   #1917  2198	2199
INITG			Near   RCODESEG:015C		   #4156  4171
INITGDT			Near   RCODESEG:0156		   4039	 #4150
INITIDT			Near   RCODESEG:01B5		   4040	 #4211
INITLDT			Near   RCODESEG:019A		   4054	 4066  4074  4082  4090	 4097  4104  #4192
INITLOAD		Near   RCODESEG:0683		   4290	 #4967
INTEXCEPTION		Far    INTEXCEPTIONSEG:0000	   583	585  587  589  591  593	 595  597  603	605  607  621  623  625	  +
							   627	629  631  633  635  637	 639  641  643	645  647  649  651  653	  +
							   655	657  659  661  663  665	 667  669  671	673  675  677  679  681	  +
							   683	685  687  689  691  693	 695  697  699	701  703  705  707  709	  +
							   711	713  715  717  719  721	 723  725  727	729  731  733  735  737	  +
							   739	741  743  745  747  749	 751  753  755	757  759  761  763  765	  +
							   767	769  771  773  775  777	 779  781  783	785  787  789  791  793	  +
							   795	797  799  801  803  805	 807  809  811	813  815  817  826  828	  +
							   830	844  846  848  850  852	 854  856  858	860  862  864  866  868	  +
							   870	872  874  876  878  880	 882  884  886	888  890  892  894  896	  +
							   898	900  902  904  906  908	 910  912  914	916  918  920  922  924	  +
							   926	928  930  932  934  936	 938  940  942	944  946  948  950  952	  +
							   954	956  958  960  962  964	 966  968  970	972  974  976  978  980	  +
							   982	984  986  988  990  992	 994  996  998	1000  1002  1004  1006	  +
							   1008	 1010  1012  1014  1016	 1018  1020
INTEXCEPTIONCODELEN	Number INTEXCEPTIONSEG:0001	   #1954  3781
INTEXCEPTIONDESC	Struct RDATASEG:0150 DESC	   #3781  3834
INTEXCEPTION_SEL	Number 0150			   583	585  587  589  591  593	 595  597  603	605  607  621  623  625	  +
							   627	629  631  633  635  637	 639  641  643	645  647  649  651  653	  +
							   655	657  659  661  663  665	 667  669  671	673  675  677  679  681	  +
							   683	685  687  689  691  693	 695  697  699	701  703  705  707  709	  +
							   711	713  715  717  719  721	 723  725  727	729  731  733  735  737	  +
							   739	741  743  745  747  749	 751  753  755	757  759  761  763  765	  +
							   767	769  771  773  775  777	 779  781  783	785  787  789  791  793	  +
							   795	797  799  801  803  805	 807  809  811	813  815  817  826  828	  +
							   830	844  846  848  850  852	 854  856  858	860  862  864  866  868	  +
							   870	872  874  876  878  880	 882  884  886	888  890  892  894  896	  +
							   898	900  902  904  906  908	 910  912  914	916  918  920  922  924	  +
							   926	928  930  932  934  936	 938  940  942	944  946  948  950  952	  +
							   954	956  958  960  962  964	 966  968  970	972  974  976  978  980	  +
							   982	984  986  988  990  992	 994  996  998	1000  1002  1004  1006	  +
							   1008	 1010  1012  1014  1016	 1018  1020
IOPL0			Number 0000			   #400
IOPL1			Number 1000			   #401
IOPL2			Number 2000			   #402
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 110
Symbol Table



IOPL3			Number 3000			   #403
JUMPOFFSET1		Word   ----:---- Extern		   #546	 5024  5051
JUMPOFFSET2		Word   ----:---- Extern		   #546	 5229
KEYBOARD_INT		Far    PCODESEG:0000		   601	#3073
KEYTABLE1		Byte   RDATASEG:01E4		   3236	 #3887
KHEAD			Byte   RDATASEG:0407		   2736	 2824  3418  3432  3445	 #3913
KKQ			Byte   RDATASEG:0308		   2723	 2811  3416  #3912
KLDT			Byte   GETSECLDTSEG:0000	   #1212  1216	1219  1221  4088
KTAIL			Byte   RDATASEG:0408		   2737	 2742  2753  2825  2833	 2844  3419  #3914
LABEL210		Near   RCODESEG:096D		   #5287  5293
LATCH			Number 2E9C			   #427
LOADAPP			Near   RCODESEG:06DC		   4984	 #4995
LOADAPP2		Near   RCODESEG:06B5		   4973	 #4985
LOADAPPLICATIONS	Near   RCODESEG:0226		   #4289
LOADARRAY		Byte   RDATASEG:0176		   #3846
LOADCOUNTER		Byte   RDATASEG:01D1		   #3873
LOADERSIZE1		Word   ----:---- Extern		   #544	 4975
LOADERSIZE1M		Word   ----:---- Extern		   #548	 4301  4856  4878  4976	 4987
LOADERSIZE2		Word   ----:---- Extern		   #544	 4986
LOADFLAG		Byte   ----:---- Extern		   #548	 4286  4996
LOADOFFSET1		Dword  ----:---- Extern		   #546	 4979  5050
LOADOFFSET2		Dword  ----:---- Extern		   #546	 4991  5228
LOADONESECFORAPPRESTOR	Near   RCODESEG:04B3		   4712	 #4720
E
LOADONESECFORMENU	Near   RCODESEG:0448		   4648	 #4660
LOOP1			Near   RCODESEG:01FC		   #4269  4312	4325
LOOPSTACK1		Near   DEMOCODESEG:00EB		   #2341  2369
LSIZE1MS		Word   RDATASEG:0419		   #3922  4302	4855
L_KEYBD1		Near   PCODESEG:0451		   3096	 3100  3104  3108  3112	 3116  3123  3130  3176	 3222  3230  3429 +
							   3447	 #3472
L_KEYBD10		Near   PCODESEG:0076		   #3124  3456
L_KEYBD11		Near   PCODESEG:008D		   #3131  3454
L_KEYBD12		Near   PCODESEG:00E0		   #3177  3452
L_KEYBD13		Near   PCODESEG:0133		   #3224  3450
L_KEYBD14		Near   PCODESEG:014C		   #3231  3471
L_KEYBD15		Near   PCODESEG:03EC		   3235	 #3446
L_KEYBD18		Near   PCODESEG:01B4		   3254	 #3259
L_KEYBD2		Near   PCODESEG:03EE		   3092	 #3448
L_KEYBD20		Near   PCODESEG:01CF		   3246	 3251  3260  3263  #3268
L_KEYBD21		Near   PCODESEG:01E6		   3269	 #3275
L_KEYBD23		Near   PCODESEG:03A6		   3278	 #3414
L_KEYBD24		Near   PCODESEG:03A6		   3274	 3284  3288  3292  3296	 3300  3304  3308  3312	 3316  3320  3324 +
							   3328	 3332  3336  3340  3344	 3348  3352  3356  3360	 3364  3368  #3415
L_KEYBD25		Near   PCODESEG:0304		   3280	 #3369
L_KEYBD26		Near   PCODESEG:01FC		   #3281  3413
L_KEYBD27		Near   PCODESEG:0208		   #3285  3411
L_KEYBD28		Near   PCODESEG:0214		   #3289  3409
L_KEYBD29		Near   PCODESEG:0220		   #3293  3407
L_KEYBD3		Near   PCODESEG:0025		   #3093  3470
L_KEYBD30		Near   PCODESEG:022C		   #3297  3405
L_KEYBD31		Near   PCODESEG:0238		   #3301  3403
L_KEYBD32		Near   PCODESEG:0244		   #3305  3401
L_KEYBD33		Near   PCODESEG:0250		   #3309  3399
L_KEYBD34		Near   PCODESEG:025C		   #3313  3397
L_KEYBD35		Near   PCODESEG:0268		   #3317  3395
L_KEYBD36		Near   PCODESEG:0274		   #3321  3393
L_KEYBD37		Near   PCODESEG:0280		   #3325  3391
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 111
Symbol Table



L_KEYBD38		Near   PCODESEG:028C		   #3329  3389
L_KEYBD39		Near   PCODESEG:0298		   #3333  3387
L_KEYBD4		Near   PCODESEG:002E		   #3097  3468
L_KEYBD40		Near   PCODESEG:02A4		   #3337  3385
L_KEYBD41		Near   PCODESEG:02B0		   #3341  3383
L_KEYBD42		Near   PCODESEG:02BC		   #3345  3381
L_KEYBD43		Near   PCODESEG:02C8		   #3349  3379
L_KEYBD44		Near   PCODESEG:02D4		   #3353  3377
L_KEYBD45		Near   PCODESEG:02E0		   #3357  3375
L_KEYBD46		Near   PCODESEG:02EC		   #3361  3373
L_KEYBD47		Near   PCODESEG:02F8		   #3365  3371
L_KEYBD5		Near   PCODESEG:0037		   #3101  3466
L_KEYBD6		Near   PCODESEG:003F		   #3105  3464
L_KEYBD7		Near   PCODESEG:0047		   #3109  3462
L_KEYBD8		Near   PCODESEG:0053		   #3113  3460
L_KEYBD9		Near   PCODESEG:005F		   #3117  3458
MEMBASE			Dword  RDATASEG:040D		   2986	 #3917
MEMCX			Word   RDATASEG:0411		   #3918
MEMDATA			Struct RDATASEG:00C0 DESC	   #3730  3815
MEMDATA_SEL		Number 00C0			   1973	 2449  2500  #3815  4642  4706	4747  4805  4862  4892	4904  4918+
							   5090	 5117  5147  5173  5251	 5596
MEMFETCH		Far    DEMOCODESEG:0412		   #2963
MEMFLAG			Byte   RDATASEG:01D6		   540	#3875  4280  4283  4324	 4334
MEMFREE			Far    DEMOCODESEG:0443		   1085	 #3018
MEMINTERFACE		Far    DEMOCODESEG:0411		   #2934
MEMLIMIT		Dword  RDATASEG:0409		   2987	 #3916
MEMLOOP			Near   DEMOCODESEG:00BB		   #2272  2278
MEMMALLOC		Far    DEMOCODESEG:0413		   1087	 #2975
MEMORYOFFSET		Dword  RDATASEG:01D7		   540	#3876  4329
MEMPRINTOFFSET		Dword  RDATASEG:01C9		   #3871  4931	4941  4950  4955
MOVENEXT		Near   DEMOCODESEG:025B		   #2632  2637
MOVTSSUSERAPP1		Near   RCODESEG:07CD		   #5100  5105
MOVTSSUSERAPP2		Near   RCODESEG:0841		   #5156  5162
MOVTSSUSERAPP3		Near   RCODESEG:0802		   #5124  5129
MOVTSSUSERAPP4		Near   RCODESEG:0876		   #5180  5185
NDISP			Near   DEMOCODESEG:0332		   2757	 #2760
NDISP1			Near   DEMOCODESEG:03BD		   2848	 #2851
NEWLINE			Near   ----:---- Extern		   #435
NEXT			Near   DEMOCODESEG:02B5		   #2684  2686
NEXT100			Near   RCODESEG:0025		   3966	 #3969
NOMORESECTORS		Near   RCODESEG:066B		   4880	 #4954
NONEWLINEP		Near   DEMOCODESEG:011C		   2363	 #2366
NORMAL			Struct RDATASEG:0008 DESC	   #3677  3790
NORMAL_SEL		Number 0008			   1373	 1376  1377  1378  1415	 1448  1451  1452  1453	 1487  1490  1491 +
							   1492	 1526  1529  1530  1531	 1565  1568  1569  1570	 #3790	4351  4378+
							   4447	 4555  4662  4761
NORVIDTR		Struct RDATASEG:0192 PDESC	   #3850  4044	4141  4394  4464  4588	4680  4779
NOTDIGIT_GETINT		Near   RCODESEG:036D		   4499	 #4505
NOTTAIL			Near   PCODESEG:03C2		   3422	 #3425
NOTTAIL2		Near   PCODESEG:03E5		   3438	 #3442
NOT_NIC			Near   RCODESEG:0D91		   5622	 #5778
NTL			Number 4000			   #415
NUMLOCK			Byte   RDATASEG:0303		   3145	 3178  3179  3182  3191	 #3906
OTHER			Struct RDATASEG:0038 DESC	   #3694  3797
OTHERBEGIN0		Far    RCODESEG:09DC		   #5347
OTHERBEGIN1		Far    RCODESEG:09F1		   #5359
OTHERBEGIN10		Far    RCODESEG:0A84		   #5445
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 112
Symbol Table



OTHERBEGIN11		Far    RCODESEG:0A99		   #5457
OTHERBEGIN12		Far    RCODESEG:0AAE		   #5470
OTHERBEGIN13		Far    RCODESEG:0AC3		   609	#5482
OTHERBEGIN2		Far    RCODESEG:0A06		   #5371
OTHERBEGIN219		Far    RCODESEG:0B7E		   #5562
OTHERBEGIN3		Far    RCODESEG:0A1B		   #5383
OTHERBEGIN4		Far    RCODESEG:0A30		   #5396
OTHERBEGIN5		Far    RCODESEG:0A45		   #5408
OTHERBEGIN6		Far    RCODESEG:0A5A		   #5420
OTHERBEGIN7		Far    RCODESEG:0A6F		   #5432
OTHERBEGIN73		Far    RCODESEG:0B82		   819	#5576
OTHER_BEGIN0		Near   ----:---- Extern		   #553
OTHER_BEGIN1		Near   ----:---- Extern		   #553
OTHER_BEGIN10		Near   ----:---- Extern		   #555
OTHER_BEGIN11		Dword  ----:---- Extern		   #555
OTHER_BEGIN12		Dword  ----:---- Extern		   #555
OTHER_BEGIN13		Dword  ----:---- Extern		   #555
OTHER_BEGIN2		Near   ----:---- Extern		   #553
OTHER_BEGIN219		Near   ----:---- Extern		   #557
OTHER_BEGIN246		Near   ----:---- Extern		   #557
OTHER_BEGIN3		Dword  ----:---- Extern		   #553
OTHER_BEGIN4		Dword  ----:---- Extern		   #553
OTHER_BEGIN5		Dword  ----:---- Extern		   #553
OTHER_BEGIN6		Near   ----:---- Extern		   #555
OTHER_BEGIN7		Near   ----:---- Extern		   #555
OTHER_SEL		Number 0038			   609	819  #3797
PCODE			Struct RDATASEG:0138 DESC	   #3775  3833
PCODELEN		Number PCODESEG:055F		   #3617  3775
PCODE_SEL		Number 0138			   601	#3833
PL			Number 0001			   #419
PRINTDATA		Dword  RDATASEG:016C		   539	#3840
PRINTDATAP		Dword  PROTMODEPROCDATASEG:0014	   #1918  2192	2195  2205  2207
PRINTMEMORY		Near   RCODESEG:0264		   4284	 #4327
PRINTMEMP		Far    DEMOCODESEG:0099		   1747	 #2250
PRINTMEMPGATE_SEL	Number 0084			   #1762  4333
PRINTMEMPROCDATA	Struct DEMOLDTSEG:0038 DESC	   #1706  1732
PRINTMEMPROCDATA_SEL	Number 003C			   #1732  2264
PRINTMEMR		Near   ----:---- Extern		   #438
PRINTSTACKEXCEPTION	Far    RCODESEG:095C		   #5282  5348	5360  5372  5384  5397	5409  5421  5433  5446	5458  5471+
							   5489
PRINTSTACKPGATE_SEL	Number 008C			   #1763
PRINTSTP		Far    DEMOCODESEG:00CF		   1749	 #2318
PROMPT1			Byte   RDATASEG:019F		   #3858  4595
PROTCODE		Struct DEMOLDTSEG:0028 DESC	   #1699  1730
PROTCODE_SEL		Number 002C			   #1730  1743	1745  1747  1749  1751
PROTMODEPROCDATA	Struct DEMOLDTSEG:0030 DESC	   #1701  1731
PROTMODEPROCDATALEN	Number PROTMODEPROCDATASEG:0018	   1701	 #1920	3716
PROTMODEPROCDATA_SEL	Number 0034			   #1731  2259	2333
PROTMODEPROCGATE1	Struct DEMOLDTSEG:0070 GATE	   #1743  1760
PROTMODEPROCGATE2	Struct DEMOLDTSEG:0080 GATE	   #1747  1762
PROTMODEPROCGATE3	Struct DEMOLDTSEG:0088 GATE	   #1749  1763
PUTHEX32DATA		Struct RDATASEG:0090 DESC	   #3716  3809
PUTHEX32DATA_SEL	Number 0090			   2186	 #3809
PUTHEX32I		Struct RDATASEG:0098 DESC	   #3718  3810
PUTHEX32I_SEL		Number 0098			   599	611  614  1080	1085  1087  1091  1093	1095  1097  1101  1103	  +
							   1105	 1117  #3810
PUTHEX32P		Far    DEMOCODESEG:0031		   1117	 1743  #2177
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 113
Symbol Table



PUTHEX32PGATE_SEL	Number 0074			   #1760  2357
PUTHEX32R		Near   ----:---- Extern		   #431
PUTHEXLOOPP		Near   DEMOCODESEG:0049		   #2194  2208
RCODELEN		Number RCODESEG:0DC5		   3694	 #5824
RDATA			Struct RDATASEG:0018 DESC	   #3686  3798
RDATA_SEL		Number 0018			   2720	 2808  2896  2983  3082	 #3798	4650  4713  4751  4809	4848  4875+
							   5070	 5094  5151  5519
RDWTMEM			Far    DEMOCODESEG:012A		   1751	 #2394
RDWTMEMGATE		Struct DEMOLDTSEG:0090 GATE	   #1751  1764
RDWTMEMPGATE_SEL	Number 0094			   #1764  4939
READAGAIN		Near   RCODESEG:0569		   #4846  4933
READSECTORS		Near   RCODESEG:05B6		   #4877  4952
READSECTORSALL		Near   RCODESEG:0556		   4310	 #4830
READWRITE1		Near   DEMOCODESEG:0158		   #2417  2424
REAL			Near   RCODESEG:0143		   #4137  4364	4365
REALDATA		Struct DEMOLDTSEG:0050 DESC	   #1718  1733
REALDATA_SEL		Number 0054			   #1733  2396	4277  4294  4969  5013	5046
REALJUMPADDR		Word   RDATASEG:0172		   #3844  4582	4583
RELOCATE1		Number 0080			   #562	 1134  1137  1154  1157	 1173  1176  1182  1196	 1199  1214  1217 +
							   1232	 1235  1689  1691  1693	 1695  1697  1699  1701	 1718  3686  3688 +
							   3690	 3692  3694  3696  3698	 3700  3702  3704  3706	 3708  3710  3712 +
							   3714	 3716  3718  3720  3722	 3727  3745  3747  3749	 3751  3753  3760 +
							   3762	 3764  3768  3770  3773	 3775  3777  3779  3781	 3944  4017  4049 +
							   4061	 4069  4077  4085  4093	 4100  4138  4214  4365	 4386  4390  4401 +
							   4456	 4460  4470  4570  4673	 4675  4772  4774
RERUNFLAG		Word   RDATASEG:019D		   #3854  5072	5077
RESETPOINTER		Near   ----:---- Extern		   #437
RETN1			Near   PCODESEG:0543		   3566	 #3599
RETN2			Near   PCODESEG:0547		   3555	 3576  3596  #3602
RFL			Number 00010000			   #413
RFLW			Number 0001			   #414
ROUNDCHAR		Near   DEMOCODESEG:0321		   2747	 #2750
ROUNDCHAR1		Near   DEMOCODESEG:03AC		   2838	 #2841
RPL0			Number 0000			   #393	 1725
RPL1			Number 0001			   #394	 1726
RPL2			Number 0002			   #395
RPL3			Number 0003			   #396	 1727  1728
RUNAPPL			Near   RCODESEG:06E5		   4320	 #5005
RUNAPPLICATIONS		Near   RCODESEG:0255		   4287	 #4313
RUNFLAG			Dword  RDATASEG:01D2		   539	#3874  4982  4993  5015	 5200  5222  5263
RUNNEXT			Near   RCODESEG:08C5		   5018	 #5219
RWR			Number 0000			   #420
RWW			Number 0002			   #421
SCAN			Byte   RDATASEG:0306		   3090	 3091  3232  3238  #3909
SCRLOCK			Byte   RDATASEG:0305		   3225	 3226  3229  #3908
SCROLL			Far    DEMOCODESEG:0248		   1091	 #2620
SEARCH			Near   PCODESEG:04A7		   3526	 #3533
SEARCH1			Near   PCODESEG:04CC		   #3546  3554	3578  3597
SEARCH2			Near   PCODESEG:04E3		   3550	 #3557
SEARCH3			Near   PCODESEG:04E7		   #3560  3569
SEARCHBEGIN		Far    PCODESEG:0486		   1400	 #3515	3615
SEARCHCODE		Struct SEARCHLDTSEG:0000 DESC	   #1173  1175
SEARCHCODE_SEL		Number 0004			   #1175  1411
SEARCHDATA		Struct SEARCHLDTSEG:0008 DESC	   #1176  1178
SEARCHDATA_SEL		Number 000C			   #1178  1413	1414
SEARCHFORDATA		Struct SEARCHLDTSEG:0010 DESC	   #1179  1181
SEARCHFORDATA_SEL	Number 0014			   #1181  1410
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 114
Symbol Table



SEARCHKEY		Byte   GLOBALDATASEG:0010	   #1938  3517	3542
SEARCHLDNUM		Number 0004			   #1186  4103
SEARCHLDT		Struct RDATASEG:00A0 DESC	   #3720  3818
SEARCHLDTLEN		Number SEARCHLDTSEG:0020	   #1187  3720
SEARCHLDTS		Byte   SEARCHLDTSEG:0000	   #1171  1175	1178  1181  1184  1186	4102
SEARCHLDT_SEL		Number 00A0			   1416	 #3818
SEARCHLEN		Word   GLOBALDATASEG:0110	   #1939  3534	3544  3577  3586
SEARCHSTACK		Struct SEARCHLDTSEG:0018 DESC	   #1182  1184
SEARCHSTACKLEN		Number 0200			   1182	 1406  #1864  1865
SEARCHSTACK_SEL		Number 001C			   #1184  1412
SEARCHTSS		Struct RDATASEG:00A8 DESC	   #3722  3819
SEARCHTSSLEN		Number SEARCHTSSSEG:0069	   #1420  3722
SEARCHTSS_SEL		Number 00A8			   1107	 #3819
SETCURSOR		Far    DEMOCODESEG:0217		   1097	 #2579
SETERRORFLAG		Far    RCODESEG:0984		   #5303  5352	5364  5376  5388  5401	5413  5425  5437  5450	5462  5475
SHIFTSTAT		Byte   RDATASEG:0300		   3103	 3107  3118  3122  3125	 3129  3252  3264  3276	 #3903
SIZEOF_TSS1		Word   RDATASEG:0170		   #3841  5097	5154
SKIP			Near   DEMOCODESEG:0010		   #2131
SKIPARPS		Near   RCODESEG:0D7F		   5760	 #5766
SKIPCHANGE		Near   RCODESEG:0183		   4160	 #4170
SKIPDATA		Near   RCODESEG:0D01		   5724	 #5730
SKIPFINACK		Near   RCODESEG:0D2B		   5736	 #5742
SKIPGETACK		Near   RCODESEG:0CAD		   5700	 #5706
SKIPHEADER		Near   RCODESEG:0CD7		   5712	 #5718
SKIPRESET		Near   RCODESEG:0C39		   5665	 #5667
SKIPRESETS		Near   RCODESEG:0D55		   5748	 #5754
SKIPSYNACK		Near   RCODESEG:0C83		   5688	 #5694
SLSECNUM1MS		Word   RDATASEG:0417		   #3921  4299	4852
SPVAR			Word   RDATASEG:0199		   #3852  4043	4140  4393  4463  4587	4679  4778
SSVAR			Word   RDATASEG:019B		   #3853  4042
START			Near   RCODESEG:0000		   #3941  5827
STARTADDRESS		Struct DEMOLDTSEG:0040 DESC	   #1708  1734
STARTADDRESS_SEL	Number 0044			   #1734  2407
STARTLOGICALSECNUM1	Word   ----:---- Extern		   #544	 4977
STARTLOGICALSECNUM1M	Word   ----:---- Extern		   #548	 4298  4652  4655  4718	 4754  4758  4814  4853	 4978  4989
STARTLOGICALSECNUM2	Word   ----:---- Extern		   #544	 4988
STORECHAR		Byte   GLOBALDATASEG:000B	   #1936  3524	4414
STOREDEC		Dword  GLOBALDATASEG:000C	   #1937  4507
S_APP_STRING		Number 0024			   #461
S_BASE			Number 8600			   #530	 1975  2451  2502  4000	 4227  4644  4708  4749	 4807  4867  4894 +
							   4909	 4923  5315  5319  5599	 5633  5660  5670  5689	 5701  5713  5725 +
							   5737	 5749  5761  5772
S_CIRLISTSTATE		Number 0080			   #478
S_CLOCK_HZ		Number 0014			   #453
S_CYCLE_COUNT		Number 0010			   #450
S_DATE			Number 0124			   #518
S_DPD_COUNT		Number 00A8			   #490	 5634  5661  5773
S_DUMMY			Number 0094			   #485
S_EINIT_RET		Number 00A0			   #487
S_ERR			Number 0128			   #519
S_ERROR_CODE		Number 001C			   #457	 5320
S_ERROR_FLAG		Number 0018			   #455	 5316
S_IDTOFFSET		Number 000C			   #449	 4228
S_INCOUNT		Number 0070			   #473
S_INRECORD		Number 0084			   #479
S_IOBASE		Number 009C			   #486	 4001  5600
S_IO_FUNCTION_CODE	Number 0020			   #458
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 115
Symbol Table



S_ISRCOUNT		Number 008C			   #481
S_ISRSTIFLAG		Number 0090			   #483
S_ITCP_ARP_COUNT	Number 0118			   #513	 5762
S_ITCP_DAT_COUNT	Number 010C			   #510	 5726
S_ITCP_FACK_COUNT	Number 0110			   #511	 5738
S_ITCP_GACK_COUNT	Number 0104			   #508	 5702
S_ITCP_HDR_COUNT	Number 0108			   #509	 5714
S_ITCP_PRIOR_COUNT	Number 011C			   #514
S_ITCP_RESET_COUNT	Number 0114			   #512	 5750
S_ITCP_SACK_COUNT	Number 0100			   #507	 5690
S_LOCK1			Number 004C			   #465
S_LOCK2			Number 0050			   #466
S_LOCK3			Number 0054			   #467
S_LOCK4			Number 0058			   #468
S_LSERROR		Number 0140			   #522	 4868  4910  4924
S_NTFLAG		Number 007C			   #477
S_OUTCOUNT		Number 0074			   #475
S_OUTRECORD		Number 0088			   #480
S_PID			Number 0078			   #476
S_RTC			Number 0120			   #517
S_RTCFLAG		Number 0130			   #520
S_SECTORNO		Number 0004			   #445	 4645  4709  4750  4808	 4895
S_SUSPEND_COMMAND	Number 00AC			   #491
S_SUSPEND_DELAY		Number 00B0			   #492
S_TCP_ARP_COUNT		Number 00D0			   #505
S_TCP_DAT_COUNT		Number 00C4			   #501
S_TCP_FACK_COUNT	Number 00C8			   #502
S_TCP_GACK_COUNT	Number 00BC			   #497
S_TCP_HDR_COUNT		Number 00C0			   #499
S_TCP_RESET_COUNT	Number 00CC			   #504
S_TCP_SACK_COUNT	Number 00B8			   #495
S_TCP_TX_COUNT		Number 00B4			   #493
S_TID1			Number 005C			   #469
S_TID2			Number 0060			   #470
S_TID3			Number 0064			   #471
S_TID4			Number 0068			   #472
S_TIMER			Number 0000			   #443	 1976  2452  2503
S_TOTAL_TX_COUNT	Number 00A4			   #488	 5671
S_TRACE			Number 0160			   #524
T32BEGIN		Far    DEMOCODESEG:0007		   1739	 #2123
T32CODE			Struct DEMOLDTSEG:0020 DESC	   #1697  1729
T32CODE_SEL		Number 0024			   #1729  1739	1741
T32END			Far    DEMOCODESEG:002A		   1741	 #2155
TEMPCODE		Struct RDATASEG:0030 DESC	   #3692  3796
TEMPCODE_SEL		Number 0030			   2161	 #3796	4128
TEST1			Far    DEMOCODESEG:01AA		   1080	 #2489
TEST2			Far    ETHERNETRECEIVE:0000	   835	#1966
TIL			Number 0004			   #409	 1136  1139  1156  1159	 1175  1178  1181  1184	 1198  1201  1216 +
							   1219	 1234  1237  1274  1292	 1297  1300  1311  1315	 1319  1333  1338 +
							   1342	 1725  1726  1727  1728	 1729  1730  1731  1732	 1733  1734  1735 +
							   1737	 1758  1759  1760  1761	 1762  1763  1764  1766
TOREAL			Near   RCODESEG:01FC		   2159	 #4268
TOT32A_SEL		Number 0064			   #1758  4256	4340
TOT32B_SEL		Number 006C			   #1759  2114
TOT32GATEA		Struct DEMOLDTSEG:0060 GATE	   #1739  1758
TOT32GATEB		Struct DEMOLDTSEG:0068 GATE	   #1741  1759
UPDATECHAR		Near   DEMOCODESEG:0323		   2749	 #2752
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 116
Symbol Table



UPDATECHAR1		Near   DEMOCODESEG:03AE		   2840	 #2843
USS			Number 0000			   #422
USU			Number 0004			   #423
VGDTR			Struct RDATASEG:0186 PDESC	   #3848  4113	4177  4179
VIDEOBUF		Struct RDATASEG:0010 DESC	   #3679  3791
VIDEO_SEL		Number 0010			   2627	 2680  3031  #3791
VIDEO_SEL_LOC		Number 0010			   #537
VIDTR			Struct RDATASEG:018C PDESC	   #3849  4120	4216  4237  4417  4516	4603  4690  4789
VIRTUAL			Far    RCODESEG:01EB		   4127	 #4247
VMFL			Number 00020000			   #410
VMFLW			Number 0002			   #411
WAITCHAR		Near   DEMOCODESEG:02FB		   #2735  2739
WAITCHAR1		Near   DEMOCODESEG:037F		   #2823
WAIT_COMMAND_END	Near   ETHERNETRECEIVE:00A8	   #2041
WAIT_COMMAND_END1	Near   ETHERNETRECEIVE:0075	   #2020
WAIT_COMMAND_END2	Near   ETHERNETRECEIVE:0055	   #2004
WLDT			Byte   WRITESECLDTSEG:0000	   #1230  1234	1237  1239
WRITESEC		Near   RCODESEG:04FB		   4771	 4772  #4773
WRITESEC1		Near   RCODESEG:0511		   #4784
WRITESECBEGIN		Far    RCODESEG:04BE		   1555	 #4738	4822
WRITESECCODE		Struct WRITESECLDTSEG:0000 DESC	   #1232  1234
WRITESECCODE_SEL	Number 0004			   #1234  4796
WRITESECLDNUM		Number 0002			   #1239
WRITESECLDT		Struct RDATASEG:0088 DESC	   #3714  3808
WRITESECLDTLEN		Number WRITESECLDTSEG:0010	   #1240  3714
WRITESECLDT_SEL		Number 0088			   #3808
WRITESECSTACK		Struct WRITESECLDTSEG:0008 DESC	   #1235  1237
WRITESECSTACKLEN	Number 0200			   1235	 #1893	1894
WRITESECSTACK_SEL	Number 000C			   #1237  4798
WRITESECTSS		Struct RDATASEG:0058 DESC	   #3702  3803
WRITESECTSSLEN		Number WRITESECTSSSEG:0069	   #1575  3702
WRITESECTSS_SEL		Number 0058			   1099	 #3803
WRITESECV		Near   RCODESEG:0526		   4795	 #4797
WRITESTRING		Near   ----:---- Extern		   #432	 4596

Macro Name						   Cref	(defined at #)

CALL16							   #281	 4330  4936
CALL32							   #288	 2110  2353
DISABLEA20						   #255
ENABLEA20						   #245	 4031
FDCCYL							   #220
FDCHEAD							   #201
FDCSECTOR						   #181
FDC_AL							   #134
FDC_IN							   #116
FDC_OUT							   #95
FDC_WAIT						   #143
JUMP16							   #265	 4125  4253  4337  4362	 4383  4422  4453  4521	 4607  4670  4694 +
							   4769	 4793
JUMP32							   #272	 2157
KEYBOARDLED						   #51	3137  3183
MDELAY							   #164
NEWLINEM						   #232
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 117
Symbol Table




Structure Name		Type  Offset			   Cref	(defined at #)

DESC							   #295	 1134  1137  1141  1154	 1157  1161  1173  1176	 1179  1182  1186 +
							   1196	 1199  1203  1214  1217	 1221  1232  1235  1239	 1272  1290  1293 +
							   1309	 1313  1317  1321  1331	 1334  1339  1344  1689	 1691  1693  1695 +
							   1697	 1699  1701  1706  1708	 1710  1718  1720  1723	 3673  3677  3679 +
							   3686	 3688  3690  3692  3694	 3696  3698  3700  3702	 3704  3706  3708 +
							   3710	 3712  3714  3716  3718	 3720  3722  3724  3727	 3730  3745  3747 +
							   3749	 3751  3753  3755  3757	 3760  3762  3764  3766	 3768  3770  3773 +
							   3775	 3777  3779  3781  3788	 4170  4203
 LIMITL			Word   0000
 BASEL			Word   0002
 BASEM			Byte   0004
 ATTRIBUTES		Byte   0005
 LIMITH			Byte   0006
 BASEH			Byte   0007
GATE							   #306	 583  585  587	589  591  593  595  597	 599  601  603	605  607  +
							   609	611  614  621  623  625	 627  629  631	633  635  637  639  641	  +
							   643	645  647  649  651  653	 655  657  659	661  663  665  667  669	  +
							   671	673  675  677  679  681	 683  685  687	689  691  693  695  697	  +
							   699	701  703  705  707  709	 711  713  715	717  719  721  723  725	  +
							   727	729  731  733  735  737	 739  741  743	745  747  749  751  753	  +
							   755	757  759  761  763  765	 767  769  771	773  775  777  779  781	  +
							   783	785  787  789  791  793	 795  797  799	801  803  805  807  809	  +
							   811	813  815  817  819  826	 828  830  835	844  846  848  850  852	  +
							   854	856  858  860  862  864	 866  868  870	872  874  876  878  880	  +
							   882	884  886  888  890  892	 894  896  898	900  902  904  906  908	  +
							   910	912  914  916  918  920	 922  924  926	928  930  932  934  936	  +
							   938	940  942  944  946  948	 950  952  954	956  958  960  962  964	  +
							   966	968  970  972  974  976	 978  980  982	984  986  988  990  992	  +
							   994	996  998  1000	1002  1004  1006
 OFFSETL		Word   0000
 SELECTOR		Word   0002
 DCOUNT			Byte   0004
 GTYPE			Byte   0005
 OFFSETH		Word   0006
PDESC							   #316	 3848  3849  3850
 LIMIT			Word   0000
 BASE			Dword  0002
TSS							   #323
 TRLINK			Word   0000
 TRESP0			Dword  0004
 TRSS0			Word   0008
 TRESP1			Dword  000C
 TRSS1			Word   0010
 TRESP2			Dword  0014
 TRSS2			Word   0018
 TRCR3			Dword  001C
 TREIP			Dword  0020
 TREFLAG		Dword  0024
 TREAX			Dword  0028
 TRECX			Dword  002C
 TREDX			Dword  0030
 TREBX			Dword  0034
 TRESP			Dword  0038
 TREBP			Dword  003C
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 118
Symbol Table



 TRESI			Dword  0040
 TREDI			Dword  0044
 TRES			Word   0048
 TRCS			Word   004C
 TRSS			Word   0050
 TRDS			Word   0054
 TRFS			Word   0058
 TRGS			Word   005C
 TRLDTR			Word   0060
 TRTRIP			Word   0064
 TRIOMAP		Word   0066
TYPEAPPLICATION						   #23
 NOOFSECTORS		Word   0000
 STARTINGSECTOR		Word   0002
 NAMEAPPLICATION	Byte   0004
TYPECOMMAND						   #35
 COMMAND		Byte   0000
 APPNAME		Byte   0001
 APPINDEX		Byte   0009

Groups & Segments	Bit Size Align	Combine	Class	   Cref	(defined at #)

APP1LDTSEG		16  0038 Para	none		   #1244  3749	3764  3770  4048
APP1STACKSEG		32  0200 Dword	Stack		   #1902
APP1TSSSEG		32  0070 Para	none		   #1591  3745	3747  3751  3753  4016
APP2LDTSEG		16  0018 Para	none		   #1327
APP2TSSSEG		16  0400 Para	none		   #1647  3760	3762  3768
DEMOCODESEG		32  0465 Para	none		   1695	 1697  1699  #2099  2100  3718
DEMOLDTSEG		16  00A0 Para	none		   #1686  3690	4092
DEMOSTACK0SEG		32  0200 Dword	Stack		   1689	 #1814
DEMOSTACK1SEG		32  0200 Dword	Stack		   1691	 #1823
DEMOSTACK3SEG		16  0200 Para	none		   1137	 1693  #1843
DEMOTSSSEG		16  006A Para	none		   #1775  3688	3779  5114  5170
DMADATASEG		16  0200 Para	Public	DMADATA	   #3624  3773
ETHERNETRECEIVE		32  00E2 Para	none		   #1964  3777
GETCHARLDTSEG		16  0010 Para	none		   #1150  3708	4068
GETCHARSTACKSEG		16  0200 Para	none		   1157	 #1853
GETCHARTSSSEG		16  0069 Para	none		   #1429  3696
GETDECLDTSEG		16  0010 Para	none		   #1192  3710	4076
GETDECSTACKSEG		16  0200 Para	none		   1199	 1217  #1874
GETDECTSSSEG		16  0069 Para	none		   #1468  3698
GETSECLDTSEG		16  0010 Para	none		   #1210  3712	4084
GETSECSTACKSEG		16  0200 Para	none		   #1883
GETSECTSSSEG		16  0069 Para	none		   #1507  3700
GKEYLDTSEG		16  0010 Para	none		   #1130  3706	4060
GKEYTSSSEG		16  0069 Para	none		   #1354  3704
GLOBALDATASEG		16  0112 Para	Public		+  1176	 #1931	3727  4400  4469
			GLOBALDATA
IDTSEG			16  0800 Para	none		   #577	 4213
INTEXCEPTIONSEG		32  0001 Para	none		   #1949  3781
PCODESEG		16  055F Para	Public	CODE	   1173	 #3067	3068  3775
PROTMODEPROCDATASEG	32  0018 Para	Public		   1701	 #1912	2100  3716
RCODESEG		16  0DC5 Para	Public	CODE	   1134	 1154  1196  1214  1232	 3692  3694  #3934  3935
RDATASEG		16  041F Para	Public	REALDATA   1718	 3068  #3648  3686  3935  3943	4137  4389  4459  4569	4674  4773
SEARCHLDTSEG		16  0020 Para	none		   #1169  3720	4099
SEARCHSTACKSEG		16  0200 Para	none		   1182	 #1863
SEARCHTSSSEG		16  0069 Para	none		   #1391  3722
Turbo Assembler	 Version 2.5	    08/29/16 14:48:15	    Page 119
Symbol Table



WRITESECLDTSEG		16  0010 Para	none		   #1228  3714
WRITESECSTACKSEG	16  0200 Para	none		   1235	 #1892
WRITESECTSSSEG		16  0069 Para	none		   #1546  3702
