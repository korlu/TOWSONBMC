Microsoft (R) Macro Assembler Version 6.11		    03/25/16 11:30:03
asmfiles.asm						     Page 1 - 1



				;***************************************************
						;testasm32.asm  trace code x119
				;***************************************************
						
				;===============-=====================================================
				;this assembly function can be called from C 
				;32 bit model and C type call settings 
				;=====================================================================
					.386p	
					.387
					.MODEL	FLAT, c
				;=====================================================================
				; the following header definition is created 
				; by H2INC program and added here 
				; It can take a C header file and generate 
				; a .INC file which can be included in the 
				;  asm code as below 

					include ..\aoainc.inc
			      C 
			      C option expr32
			      C option casemap:none
			      C 
			      C ; Begin of file aoainc.h
			      C 
			      C ;---------------------------------------------------
			      C ;Shared Memory Constants between appilication and aoa
 = 00000000		      C S_Timer			EQU		000000000h 
 = 00000004		      C S_SectorNo		EQU		000000004h 
			      C 
			      C ;----------------------------------------------------
			      C 
			      C ; Base of Shared memory between aoa and application
			      C ;----------------------------------------------------
 = 00008600		      C S_Base			EQU		000008600h
			      C ;----------------------------------------------------
			      C 
			      C ;Processor Speed in MHZ. This is used by Short Delay Procedure
			      C ;-------------------------------------------------------------
 = 00000163		      C Processor_Speed		EQU		355
 = 00000005		      C NoOfCycles_Delay	EQU		5	
			      C ; No of cycles used to calculate the delay loop 
			      C ;-------------------------------------------------------------
			      C 
 = 000000B8		      C GlobalDataSel		EQU		000000b8h
 = 00000018		      C RDataSel		EQU		00000018h
 = 00000308		      C GKKQ			EQU		00000308h
 = 00000407		      C GKHead			EQU		00000407h
 = 00000408		      C GKTail			EQU		00000408h
 = 0000000C		      C StackSel		EQU		0000000Ch
 = 00000090		      C Puthex32DataSel 	EQU		00000090h
 = 000000C0		      C MEMDataSel         	EQU		000000C0h ; G4Data_Sel prcycle 
			      C ; This is the Zero selector in GDT for addressing Real mode memory such as 8600
			      C ; This is used to address Shared memory in protected mode
			      C 
			      C ; when PRCYCLE changes, the offset for Timer memory 
			      C ;  location will change. Make sure you keep the 
			      C ; following value upto date 
			      C ; RKK use prcycle.lst to get this offset 
 = 0000020D		      C Timer		EQU		00000020Dh
 = 000001BD		      C AppGDTPtr	EQU		0000001BDh	;Store the GDT starting address
			      C 
 = 0000000B		      C StoreCharOffset		EQU		11t
 = 0000000C		      C StoreDecOffset		EQU		12t
			      C 
			      C 
			      C 
			      C @proto_0		TYPEDEF		PROTO C :PTR BYTE, :DWORD, :DWORD
			      C printstrasm32		PROTO		@proto_0
			      C 
			      C @proto_1		TYPEDEF		PROTO C :PTR BYTE
			      C getstrasm32		PROTO		@proto_1
			      C 
			      C @proto_2		TYPEDEF		PROTO C :DWORD
			      C setcursorasm32		PROTO		@proto_2
			      C 
			      C @proto_3		TYPEDEF		PROTO C :BYTE, :DWORD
			      C printcharasm32		PROTO		@proto_3
			      C 
			      C @proto_4		TYPEDEF		PROTO C :DWORD, :DWORD
			      C printhexasm32		PROTO		@proto_4
			      C 
			      C @proto_5		TYPEDEF		PROTO C :PTR BYTE, :DWORD
			      C writefloppyasm32	PROTO		@proto_5
			      C 
			      C @proto_6		TYPEDEF		PROTO C 
			      C getcursorasm32		PROTO		@proto_6
			      C 
			      C @proto_7		TYPEDEF		PROTO C :DWORD 
			      C getcharasm32		PROTO		@proto_7
			      C 
			      C @proto_8		TYPEDEF		PROTO C 
			      C gettimerasm32		PROTO		@proto_8
			      C 
			      C @proto_9		TYPEDEF		PROTO C 
			      C getdecasm32		PROTO		@proto_9
			      C 
			      C @proto_10		TYPEDEF		PROTO C 
			      C cleanscreenasm32	PROTO		@proto_10
			      C 
			      C @proto_11		TYPEDEF		PROTO C 
			      C scrollasm32		PROTO		@proto_11
			      C 
			      C @proto_12		typedef		proto c :PTR DWORD
			      C mallocasm32		proto		@proto_12
			      C 
			      C 
			      C @proto_13		typedef		proto c :DWORD
			      C freeasm32		proto		@proto_13
			      C 
			      C @proto_14		typedef		proto c 
			      C getTaskPtrasm32		proto		@proto_14
			      C 
			      C @proto_15		typedef		proto c :PTR DWORD, :PTR BYTE, :DWORD
			      C fetchasm32		proto		@proto_15
			      C 
			      C @proto_16		typedef		proto c :PTR DWORD, :PTR DWORD, :WORD
			      C getGDTEntryasm32	proto		@proto_16
			      C 
			      C @proto_17		typedef		proto c :PTR DWORD, :PTR DWORD, :WORD
			      C setGDTEntryasm32	proto		@proto_17
			      C 
			      C @proto_18		typedef		proto c :PTR BYTE, :DWORD
			      C readfloppyasm32		proto		@proto_18
			      C 
			      C @proto_19		typedef		proto c :DWORD, :DWORD, :WORD 
			      C initschedulerasm32	proto		@proto_19
			      C @proto_20		typedef		proto c :DWORD 
			      C inittimerasm32	proto		@proto_20
			      C @proto_21		typedef proto c 
			      C stiasm32	proto		@proto_21
			      C @proto_22		typedef proto c
			      C ctiasm32	proto		@proto_22
			      C @proto_23		typedef		proto c :DWORD 
			      C printflagsasm32	proto		@proto_23
			      C @proto_24		typedef		proto c :DWORD 
			      C getsharedmemasm32	proto		@proto_24
			      C @proto_25		typedef		proto c :DWORD 
			      C getstackpopasm32	proto		@proto_25
			      C @proto_26		typedef		proto c :DWORD 
			      C printregsasm32		proto		@proto_26
			      C @proto_27		typedef		proto c :DWORD, :DWORD 
			      C getsharedmemcharasm32			proto		@proto_27
			      C @proto_28		typedef		proto c :DWORD, :BYTE, :DWORD
			      C setsharedmemcharasm32			proto		@proto_28
			      C @proto_29		typedef		proto c
			      C intttimerasm32			proto		@proto_29
			      C @proto_30		typedef		proto c :DWORD, :DWORD
			      C testandsetasm32			proto		@proto_30
			      C @proto_31		typedef		proto c :DWORD,  :DWORD
			      C resetlockasm32			proto		@proto_31
			      C @proto_32		typedef		proto c :DWORD, :DWORD 
			      C setsharedmemasm32	proto		@proto_32
			      C ; End of file aoainc.h
			      C 
					include ..\sharmem.inc
			      C ;Shared Memory Constants between appilication and aoa
 = 00000000		      C S_Timer			EQU		00000000h ; software timer value, incremented by timer interrupt 
 = 00000004		      C S_SectorNo		EQU		00000004h ; 4 byte sector number and another 4 byte spare 
			      C ; after this element, the GetSecBegin in prcycle stores another data value 
			      C ;  with +2 location, so keep another 4 bytes as spare here 
 = 0000000C		      C S_IDTOffset		EQU		0000000Ch ; used by Timer interrupt 
 = 00000010		      C S_Cycle_Count		EQU		00000010h 
			      C ; This is the count used by the Htimer to calculate the processor clock speed, which is stored in S_Clock_Hz
 = 00000014		      C S_Clock_Hz		EQU		00000014h ; This shared memory has the clock speed in Giga Hertz
 = 00000018		      C S_Error_Flag		EQU		00000018h ; error flag indicating that error occured in the machine 
 = 0000001C		      C S_Error_Code            EQU             0000001Ch ; error code showing the IDT value 
 = 00000020		      C S_IO_Function_Code      EQU             00000020h ; Function Code Indicating the type of function 4 bytes   
			      C ;each assembly interface call will put this code in memory 
 = 00000024		      C S_APP_String		EQU		00000024h ; 40 bytes Used for storing a string 
			      C ;all C++ programs and functions can store a string here to be used as a trace 
			      C ; the string here indicates the last C++ function trace which can help identify 
			      C ; the trace code ran before an error 
 = 0000004C		      C S_Lock1 		EQU		0000004Ch ; 4 byte lock 0 DISPLAY 
 = 00000050		      C S_Lock2 		EQU		00000050h ; 4 byte lock 1 KBD  
 = 00000054		      C S_Lock3 		EQU		00000054h ; 4 byte lock 2 
 = 00000058		      C S_Lock4 		EQU		00000058h ; 4 byte lock 3 
 = 0000005C		      C S_TID1			EQU		0000005ch ; Task ID 1     DISPLAY 
 = 00000060		      C S_TID2			EQU		00000060h ; Task ID 2     KBD 
 = 00000064		      C S_TID3			EQU		00000064h ; Task ID 3
 = 00000068		      C S_TID4			EQU		00000068h ; Task ID 4
 = 00000070		      C S_InCount		EQU		00000070h ; 4 byte the no of interrupt pkts received 
 = 00000074		      C S_OutCount		EQU		00000074h ; 4 byte the no of pkts processed 
 = 00000078		      C S_PID 			EQU		00000078h ; 4 byte task id of the process running 
 = 0000007C		      C S_NTFLAG		EQU		0000007ch ; 4 byte CPU NTFLAG 
 = 00000080		      C S_CIRLISTSTATE		EQU		00000080h ; 4 byte cirlist condition
 = 00000084		      C S_InRecord		EQU		00000084h ; 4 byte in record for cirlist 
 = 00000088		      C S_OutRecord		EQU		00000088h ; 4 byte out record for cirlist 
 = 0000008C		      C S_ISRCount		EQU		0000008Ch ; 4 byte counter used to communicate betn ISR Rtn and Poll Task
 = 00000090		      C S_ISRSTIFlag		EQU		00000090h ; 4 byte ISR STI flag indicating its execution, no sti now... 
 = 00000094		      C S_DUMMY			EQU		00000094h ; 8 byte dummy data  
 = 0000009C		      C S_IOBASE		EQU		0000009Ch ; 4 byte NIC device address
 = 000000A0		      C S_EINIT_RET		EQU		000000a0h ; 4 byte Ethernet Init Ret code 
 = 000000A4		      C S_Total_Tx_Count	EQU		000000a4h ; 4 byte counter counts total pkts xmitted 
 = 000000A8		      C S_DPD_Count		EQU		000000a8h ; 4 byte counter
 = 000000AC		      C S_Suspend_Command	EQU		000000ach ; 4 byte value
 = 000000B0		      C S_Suspend_Delay		EQU		000000b0h ; 4 byte value
 = 000000B4		      C S_TCP_Tx_Count		EQU		000000b4h ; total packets sent by application   
			      C 
 = 000000B8		      C S_TCP_SACK_Count	EQU		000000b8h ; total SYN ACK packets sent by application   
 = 000000BC		      C S_TCP_GACK_Count	EQU		000000bch ; total GET ACK packets sent by application   
 = 000000C0		      C S_TCP_HDR_Count		EQU		000000c0h ; total header packets sent by application   
 = 000000C4		      C S_TCP_DAT_Count		EQU		000000c4h ; total data packets sent by application   
 = 000000C8		      C S_TCP_FACK_Count	EQU		000000c8h ; total FIN ACK packets sent by application   
 = 000000CC		      C S_TCP_RESET_Count	EQU		000000cch ; total RESET packets sent by application   
 = 000000D0		      C S_TCP_ARP_Count		EQU		000000d0h ; total ARP packets sent by application   
			      C 
 = 00000100		      C S_ITCP_SACK_Count	EQU		00000100h ; total interrupts for SYN ACK packets   
 = 00000104		      C S_ITCP_GACK_Count	EQU		00000104h ; total interrupts for GET ACK packets   
 = 00000108		      C S_ITCP_HDR_Count	EQU		00000108h ; total interrupts for header packets  
 = 0000010C		      C S_ITCP_DAT_Count	EQU		0000010ch ; total interrrupts for data packets  
 = 00000110		      C S_ITCP_FACK_Count	EQU		00000110h ; total interrupts for FIN ACK packets   
 = 00000114		      C S_ITCP_RESET_Count	EQU		00000114h ; total interrupts for RESET packets   
 = 00000118		      C S_ITCP_ARP_Count	EQU		00000118h ; total interrupts for ARP packets   
 = 0000011C		      C S_ITCP_PRIOR_Count	EQU		0000011ch ; interrupt prior count before TCP transmissions    
			      C ;--------------------------------------------------------------------------------
 = 00000120		      C S_RTC	            EQU		00000120h ; real time clock     
 = 00000124		      C S_DATE	            EQU		00000124h ; date     
 = 00000128		      C S_ERR	            EQU		00000128h ; error      
 = 00000130		      C S_RTCFLAG	        EQU		00000130h ; flag     
			      C 
 = 00000140		      C S_LSError		EQU		00000140h ; Sector Error when reading floppy     
			      C ;----------------------------------------------------
 = 00000160		      C S_Trace			EQU		00000160h ; 128 byte trace data 
			      C 
			      C ;----------------------------------------------------
			      C 
			      C ; Base of Shared memory between aoa and application
			      C ;--------------------------------------------
 = 00008600		      C S_Base			EQU		00008600h ; base address of shared memory 
			      C 
			      C ;--------------------------------------------
			      C ; Some other constants
			      C ;change the following value if loading the program changes 
			      C ;  most significant 2 bytes 
 = 00000011		      C D_ADDROFFSET		EQU		0011h
 = 00000010		      C Video_Sel_Loc		EQU		10h 
			      C 

				;===================================================================

 00000000			.CODE
 00000000			testasm32 PROC C public uses es ebx, Delay:DWORD
 00000005  53				push	ebx
 00000006  50				push	eax
 00000007  52				push	edx
					
 00000008  B8 00000163			mov	eax, Processor_Speed
 0000000D  BB 00000460			mov	ebx, 1120
 00000012  CD FD			int	0fdh

 00000014  8B 55 08			mov	edx, Delay
 00000017  F7 E2			mul	edx
 00000019  BB 00000488			mov	ebx, 1160
 0000001E  CD FD			int 	0fdh

 00000020  B9 00000005			mov	ecx, NoOfCycles_Delay
 00000025  F7 F1			div	ecx; The result of div is in eax	
 00000027  BB 00000474			mov	ebx, 1140
 0000002C  CD FD			int	0fdh	
					
 0000002E  8B C8			mov	ecx, eax

 00000030			DELAYLOOP:
 00000030  E2 FE			loop	DELAYLOOP
 00000032  5A				pop	edx
 00000033  58				pop	eax
 00000034  5B				pop	ebx

				        ;--------trace Code----------------------
 00000035  06				push	es
 00000036  53				push	ebx
 00000037  50				push	eax

 00000038  66| B8 00C0			mov	ax, MEMDataSel
 0000003C  66| 8E C0			mov	es, ax
 0000003F  BB 00008600			mov	ebx, S_Base
 00000044  83 C3 18			add	ebx, S_Error_Flag
 00000047  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 0000004A  83 F8 00			cmp	eax, 0			; check if flag is zero 
 0000004D  75 10			jnz	skipupdate
 0000004F  B8 00000119			mov	eax, 0119h
 00000054  BB 00008600			mov	ebx, S_Base
 00000059  83 C3 20			add	ebx, S_IO_Function_Code
 0000005C  26: 89 03			mov	DWORD PTR es:[ebx], eax

 0000005F			        skipupdate:
 0000005F  58				pop	eax
 00000060  5B				pop	ebx
 00000061  07				pop	es
					;--------end trace code------------------
					ret

 00000066			testasm32 ENDP 	

 00000066			cliasm32 PROC C  
 00000066  FA				cli	;clear interrupts
 00000067  B8 00000000			mov eax,0

 0000006C  C3				ret
 0000006D			cliasm32 ENDP 	


				;to enable an interrupt you should have a 0 bit in the position 
				;  for example 1111 0111 will enable the 0th bit 
				; AND operation 
 0000006D			enableIRQCntlrasm32 PROC C public uses es ebx, port:WORD, msk:WORD
 00000072  53				push	ebx
 00000073  50				push	eax
 00000074  52				push	edx
 00000075  66| 8B 45 08			mov	ax, port
 00000079  66| 8B D0			mov	dx, ax
 0000007C  EC				in	al, dx
 0000007D  66| 23 45 0C			and	ax, msk
 00000081  EE				out	dx, al
 00000082  5A				pop	edx
 00000083  58				pop	eax
 00000084  5B				pop	ebx

				       ;--------trace Code----------------------
 00000085  06				push	es
 00000086  53				push	ebx
 00000087  50				push	eax

 00000088  66| B8 00C0			mov	ax, MEMDataSel
 0000008C  66| 8E C0			mov	es, ax
 0000008F  BB 00008600			mov	ebx, S_Base
 00000094  83 C3 18			add	ebx, S_Error_Flag
 00000097  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 0000009A  83 F8 00			cmp	eax, 0			; check if flag is zero 
 0000009D  75 10			jnz	skipupdate
 0000009F  B8 00000138			mov	eax, 0138h
 000000A4  BB 00008600			mov	ebx, S_Base
 000000A9  83 C3 20			add	ebx, S_IO_Function_Code
 000000AC  26: 89 03			mov	DWORD PTR es:[ebx], eax

 000000AF			        skipupdate:
 000000AF  58				pop	eax
 000000B0  5B				pop	ebx
 000000B1  07				pop	es
					;--------end trace code------------------

					ret
 000000B6			enableIRQCntlrasm32 ENDP 	

				;to disable an interrupt you should have a 1 bit in the position 
				;  for example 0000 1000 will disable the 1th bit 
				;  OR operatin 
 000000B6			disableIRQCntlrasm32 PROC C public uses es ebx, port:WORD, msk:WORD
 000000BB  53				push	ebx
 000000BC  50				push	eax
 000000BD  52				push	edx
 000000BE  66| 8B 45 08			mov	ax, port
 000000C2  66| 8B D0			mov	dx, ax
 000000C5  EC				in	al, dx
 000000C6  66| 0B 45 0C			or	ax, msk
 000000CA  EE				out	dx, al
 000000CB  5A				pop	edx
 000000CC  58				pop	eax
 000000CD  5B				pop	ebx
					
				       ;--------trace Code----------------------
 000000CE  06				push	es
 000000CF  53				push	ebx
 000000D0  50				push	eax

 000000D1  66| B8 00C0			mov	ax, MEMDataSel
 000000D5  66| 8E C0			mov	es, ax
 000000D8  BB 00008600			mov	ebx, S_Base
 000000DD  83 C3 18			add	ebx, S_Error_Flag
 000000E0  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 000000E3  83 F8 00			cmp	eax, 0			; check if flag is zero 
 000000E6  75 10			jnz	skipupdate
 000000E8  B8 00000139			mov	eax, 0139h
 000000ED  BB 00008600			mov	ebx, S_Base
 000000F2  83 C3 20			add	ebx, S_IO_Function_Code
 000000F5  26: 89 03			mov	DWORD PTR es:[ebx], eax

 000000F8			        skipupdate:
 000000F8  58				pop	eax
 000000F9  5B				pop	ebx
 000000FA  07				pop	es
					;--------end trace code------------------

					ret
 000000FF			disableIRQCntlrasm32 ENDP 	

 000000FF			ackPICCntlrasm32 PROC C public uses es ebx, port:WORD, msk:WORD
 00000104  53				push	ebx
 00000105  50				push	eax
 00000106  52				push	edx
 00000107  66| 8B 45 08			mov	ax, port
 0000010B  66| 8B D0			mov	dx, ax
 0000010E  EE				out	dx, al ;acknowledge all interrupts, msk is not used 
 0000010F  5A				pop	edx
 00000110  58				pop	eax
 00000111  5B				pop	ebx

					;--------trace Code----------------------
 00000112  06				push	es
 00000113  53				push	ebx
 00000114  50				push	eax

 00000115  66| B8 00C0			mov	ax, MEMDataSel
 00000119  66| 8E C0			mov	es, ax
 0000011C  BB 00008600			mov	ebx, S_Base
 00000121  83 C3 18			add	ebx, S_Error_Flag
 00000124  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 00000127  83 F8 00			cmp	eax, 0			; check if flag is zero 
 0000012A  75 10			jnz	skipupdate
 0000012C  B8 00000140			mov	eax, 0140h
 00000131  BB 00008600			mov	ebx, S_Base
 00000136  83 C3 20			add	ebx, S_IO_Function_Code
 00000139  26: 89 03			mov	DWORD PTR es:[ebx], eax

 0000013C			        skipupdate:
 0000013C  58				pop	eax
 0000013D  5B				pop	ebx
 0000013E  07				pop	es
					;--------end trace code------------------

					ret
 00000143			ackPICCntlrasm32 ENDP 	
				;--------------------------------------------------------------------
				;read interrupt chip status 
 00000143			readintstatusregisterasm32 PROC C public uses edx, port:WORD

 00000147  52			       push edx 

 00000148  B8 00000000			mov 	eax, 0
 0000014D  66| 8B 45 08			mov	ax, port
 00000151  66| 8B D0			mov	dx, ax
 00000154  EC				in	al, dx   ;read status from chip with port address 1, 2 

 00000155  5A			       pop	edx
				        ; return1 value in eax 
					ret

 00000159			readintstatusregisterasm32 ENDP 	
				;----------------------------------------------------------------
				; read real time clock 
				; uses the same mechanism as the read floppy one sector 
				; uses a S_RTCFLAG as a flag to indicate that it is a RTC command 
				;----------------------------------------------------------------
 00000159			readrtcasm32 PROC C public uses eax ebx ecx

 0000015C  CD FA			int	0fah        ; read real time clock 

 0000015E  06				push	es
 0000015F  53				push	ebx

 00000160  66| B8 00C0			mov	ax, MEMDataSel
 00000164  66| 8E C0			mov	es, ax
 00000167  BB 00008600			mov	ebx, S_Base
 0000016C  81 C3 00000120		add	ebx, S_RTC
 00000172  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get the value 

 00000175  5B			    pop ebx
 00000176  07			    pop es
				 
					ret
 0000017B			readrtcasm32 ENDP 	
				;----------------------------------------------------------------
				; read date
				; uses the same mechanism as the read floppy one sector 
				; uses a S_RTCFLAG as a flag to indicate that it is a date command 
				;----------------------------------------------------------------
 0000017B			readdateasm32 PROC C public uses eax ebx ecx

 0000017E  CD FA			int	0fah        ; read date 

 00000180  06				push	es
 00000181  53				push	ebx

 00000182  66| B8 00C0			mov	ax, MEMDataSel
 00000186  66| 8E C0			mov	es, ax
 00000189  BB 00008600			mov	ebx, S_Base
 0000018E  81 C3 00000124		add	ebx, S_DATE
 00000194  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get the value 

 00000197  5B			    pop ebx
 00000198  07			    pop es
				 
					ret
 0000019D			readdateasm32 ENDP 	
				;--------------------------------------------------------------------
				;read interrupt chip mask register 
 0000019D			readintmaskregisterasm32 PROC C public uses edx, port:WORD

 000001A1  52			       push edx 

 000001A2  B8 00000000			mov 	eax, 0
 000001A7  66| 8B 45 08			mov	ax, port
 000001AB  66| 8B D0			mov	dx, ax
 000001AE  EC				in	al, dx   ;read mask register 

 000001AF  5A			       pop	edx
				        ; return1 value in eax 
					ret

 000001B3			readintmaskregisterasm32 ENDP 	


				;--------------------------------------------------------------------

 000001B3			inttimerasm32 PROC C

				        ;--------trace Code----------------------
 000001B3  06				push	es
 000001B4  53				push	ebx
 000001B5  50				push	eax

 000001B6  66| B8 00C0			mov	ax, MEMDataSel
 000001BA  66| 8E C0			mov	es, ax
 000001BD  BB 00008600			mov	ebx, S_Base
 000001C2  83 C3 18			add	ebx, S_Error_Flag
 000001C5  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 000001C8  83 F8 00			cmp	eax, 0			; check if flag is zero 
 000001CB  75 10			jnz	skipupdate
 000001CD  B8 00000131			mov	eax, 0131h
 000001D2  BB 00008600			mov	ebx, S_Base
 000001D7  83 C3 20			add	ebx, S_IO_Function_Code
 000001DA  26: 89 03			mov	DWORD PTR es:[ebx], eax

 000001DD			        skipupdate:
 000001DD  58				pop	eax
 000001DE  5B				pop	ebx
 000001DF  07				pop	es
					;--------end trace code------------------

 000001E0  CD 08			int 08h 	; call timer interrupt 
 000001E2  C3				ret
 000001E3			inttimerasm32 ENDP 	

 000001E3			stiasm32 PROC C public uses ebx  

 000001E4  66| B8 00C0			mov	ax, MEMDataSel; This is a zero base selector to access shared memory between aoa and application
 000001E8  66| 8E C0			mov	es, ax
 000001EB  BB 00008600			mov	ebx, S_Base
 000001F0  81 C3 00000090		add	ebx, S_ISRSTIFlag  ; ISRFlag  
 000001F6  26: 8B 03			mov	eax, DWORD PTR es:[ebx]  ; get the flag value 
 000001F9  83 F8 01			cmp	eax, 1   ; is it set? 
 000001FC  74 01			jz	itisset 
					;yes it is not set, you can do sti   
 000001FE  FB				sti
 000001FF			        itisset:
					ret

 00000201			stiasm32 ENDP 	

 00000201			cliTimerasm32 PROC C public 
 00000201  52				push	edx
 00000202  50				push	eax
 00000203  66| BA 0021			mov	dx,21h ; disable timer interrupt 
 00000207  B0 01			mov	al,01h	
 00000209  EE				out	dx,al
 0000020A  58				pop	eax
 0000020B  5A				pop	edx
 0000020C  C3				ret
 0000020D			cliTimerasm32 ENDP 	

 0000020D			getstrasm32 PROC C public uses ecx ebx edi,buffer:ptr byte

 00000213  33 C9			xor	ecx, ecx
 00000215  8B 45 08			mov	eax, buffer
 00000218  8B F8			mov	edi, eax

 0000021A			GetChar:
 0000021A  CD F5			int	0f5h ; get a character from keyboard
					
 0000021C  3C 0D			cmp	al, 0dh
 0000021E  74 07			je	Exit

 00000220  36: 88 07			mov	byte ptr ss:[edi],al

 00000223  41				inc	ecx
 00000224  47				inc	edi

 00000225  EB F3			jmp	GetChar
 00000227			Exit:
 00000227  8B C1			mov	eax, ecx

				        ;--------trace Code----------------------
 00000229  06				push	es
 0000022A  53				push	ebx
 0000022B  50				push	eax

 0000022C  66| B8 00C0			mov	ax, MEMDataSel
 00000230  66| 8E C0			mov	es, ax
 00000233  BB 00008600			mov	ebx, S_Base
 00000238  83 C3 18			add	ebx, S_Error_Flag
 0000023B  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 0000023E  83 F8 00			cmp	eax, 0			; check if flag is zero 
 00000241  75 10			jnz	skipupdate
 00000243  B8 00000100			mov	eax, 0100h
 00000248  BB 00008600			mov	ebx, S_Base
 0000024D  83 C3 20			add	ebx, S_IO_Function_Code
 00000250  26: 89 03			mov	DWORD PTR es:[ebx], eax

 00000253			        skipupdate:
 00000253  58				pop	eax
 00000254  5B				pop	ebx
 00000255  07				pop	es
					;--------end trace code------------------

					ret
 0000025B			getstrasm32 ENDP 	

 0000025B			getcursorasm32 PROC C public

						;int	0f2h not used any more 
 0000025B  52					push	edx
 0000025C  53					push	ebx
						
 0000025D  33 C0				xor	eax, eax
 0000025F  66| BA 03D4				mov	dx, 3d4h
 00000263  B0 0F				mov	al, 0fh
 00000265  EE					out	dx, al
 00000266  66| BA 03D5				mov	dx, 3d5h
 0000026A  EC					in	al, dx	
 0000026B  8A D8				mov	bl, al

 0000026D  66| BA 03D4				mov	dx, 3d4h
 00000271  B0 0E				mov	al, 0eh
 00000273  EE					out	dx, al
 00000274  66| BA 03D5				mov	dx, 3d5h
 00000278  EC					in	al, dx
 00000279  8A E0				mov	ah, al
 0000027B  8A C3				mov	al, bl

 0000027D  5B					pop	ebx
 0000027E  5A					pop	edx

 0000027F  C3				ret
 00000280			getcursorasm32 ENDP 	

 00000280			gettimerasm32 PROC C public uses ebx es
 00000282  66| B8 00C0			mov	ax, MEMDataSel; This is a zero base selector to access shared memory between aoa and application
 00000286  66| 8E C0			mov	es, ax
 00000289  BB 00008600			mov	ebx, S_Base
 0000028E  83 C3 00			add	ebx, S_Timer
 00000291  26: 8B 03			mov	eax, DWORD PTR es:[ebx]
				        ;--------trace Code----------------------
 00000294  06				push	es
 00000295  53				push	ebx
 00000296  50				push	eax

 00000297  66| B8 00C0			mov	ax, MEMDataSel
 0000029B  66| 8E C0			mov	es, ax
 0000029E  BB 00008600			mov	ebx, S_Base
 000002A3  83 C3 18			add	ebx, S_Error_Flag
 000002A6  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 000002A9  83 F8 00			cmp	eax, 0			; check if flag is zero 
 000002AC  75 10			jnz	skipupdate
 000002AE  B8 00000106			mov	eax, 0106h
 000002B3  BB 00008600			mov	ebx, S_Base
 000002B8  83 C3 20			add	ebx, S_IO_Function_Code
 000002BB  26: 89 03			mov	DWORD PTR es:[ebx], eax

 000002BE			        skipupdate:
 000002BE  58				pop	eax
 000002BF  5B				pop	ebx
 000002C0  07				pop	es
					;--------end trace code------------------

					ret
 000002C4			gettimerasm32 ENDP 	

 000002C4			setcursorasm32 PROC C public uses edx , pos:dword

						;int	0f3h not used any more 
 000002C8  52					push	edx
 000002C9  53					push	ebx
						
 000002CA  8B 45 08				mov	eax, pos

 000002CD  8B D8				mov	ebx, eax
 000002CF  66| BA 03D4				mov	dx, 3d4h
 000002D3  B0 0F				mov	al, 0fh
 000002D5  EE					out	dx, al 
 000002D6  66| BA 03D5				mov	dx, 3d5h
 000002DA  8A C3				mov	al, bl
 000002DC  EE					out	dx, al
						
 000002DD  66| BA 03D4				mov	dx, 3d4h
 000002E1  B0 0E				mov	al, 0eh
 000002E3  EE					out	dx, al 
 000002E4  66| BA 03D5				mov	dx, 3d5h
 000002E8  8A C7				mov	al, bh
 000002EA  EE					out	dx, al

 000002EB  5B					pop	ebx
 000002EC  5A					pop	edx
						ret

 000002F0			setcursorasm32 ENDP 	

 000002F0			scrollasm32 PROC C public

 000002F0  CD F0			int	0f0h
				    ;--------trace Code----------------------
 000002F2  06				push	es
 000002F3  53				push	ebx
 000002F4  50				push	eax

 000002F5  66| B8 00C0			mov	ax, MEMDataSel
 000002F9  66| 8E C0			mov	es, ax
 000002FC  BB 00008600			mov	ebx, S_Base
 00000301  83 C3 18			add	ebx, S_Error_Flag
 00000304  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 00000307  83 F8 00			cmp	eax, 0			; check if flag is zero 
 0000030A  75 10			jnz	skipupdate
 0000030C  B8 00000109			mov	eax, 0109h
 00000311  BB 00008600			mov	ebx, S_Base
 00000316  83 C3 20			add	ebx, S_IO_Function_Code
 00000319  26: 89 03			mov	DWORD PTR es:[ebx], eax

 0000031C			        skipupdate:
 0000031C  58				pop	eax
 0000031D  5B				pop	ebx
 0000031E  07				pop	es
					;--------end trace code------------------

 0000031F  C3				ret
 00000320			scrollasm32 ENDP 	

 00000320			printcharasm32 PROC C public uses ebx, value: byte, pos: dword
 00000324  FA				cli
 00000325  53				push	ebx
 00000326  06				push	es

 00000327  8B 5D 0C			mov	ebx, pos
 0000032A  8A 45 08			mov	al, value
					;int	0f7h
					;-----------------------------------------
					; replace f7 interrupt in prcycle with this code 
					;  this is same code as in prcycle, however, it needs Video_Sel 
 0000032D  66| B8 0010				mov     ax, Video_Sel_Loc ; Video_Sel selector watch for changes in prcycle 
 00000331  66| 8E C0				mov     es, ax
 00000334  8A 45 08				mov	al, value 
						;mov     ah,17h
						;mov	ah, 7 
 00000337  B4 1F				mov	ah, 1fh 
 00000339  66| 26: 89 03	        mov     WORD PTR es:[ebx], ax
					;-----------------------------------------
 0000033D  07				pop	es
 0000033E  5B				pop	ebx
 0000033F  FB				sti
					ret
 00000343			printcharasm32 ENDP 	

 00000343			clearntflagasm32 PROC C public uses eax ebx
 00000345  52					push	edx
 00000346  9C					pushfd ; turn off NT flag in the CPU not in the TSS
						; so that CPU will return to its application during IRETD not to 
						;  exit from the task using link field in the TSS 
 00000347  5A					pop	edx;
 00000348  81 E2 FFFFBFFF			AND	edx, 0FFFFBFFFh
 0000034E  52					push	edx
 0000034F  9D					popfd
 00000350  5A					pop	edx

						ret
 00000354			clearntflagasm32 ENDP 	

 00000354			printflagsasm32 PROC C public uses eax ebx , base:dword
 00000359  8B 5D 08			mov	ebx, base
 0000035C  9C				pushfd      ; push 32 bit flags onto stack 
 0000035D  58				pop	eax
 0000035E  CD FD			int 	0fdh
				        ;--------trace Code----------------------
 00000360  06				push	es
 00000361  53				push	ebx
 00000362  50				push	eax

 00000363  66| B8 00C0			mov	ax, MEMDataSel
 00000367  66| 8E C0			mov	es, ax
 0000036A  BB 00008600			mov	ebx, S_Base
 0000036F  83 C3 18			add	ebx, S_Error_Flag
 00000372  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 00000375  83 F8 00			cmp	eax, 0			; check if flag is zero 
 00000378  75 10			jnz	skipupdate
 0000037A  B8 00000114			mov	eax, 0114h
 0000037F  BB 00008600			mov	ebx, S_Base
 00000384  83 C3 20			add	ebx, S_IO_Function_Code
 00000387  26: 89 03			mov	DWORD PTR es:[ebx], eax

 0000038A			        skipupdate:
 0000038A  58				pop	eax
 0000038B  5B				pop	ebx
 0000038C  07				pop	es
					;--------end trace code------------------
					ret
 00000391			printflagsasm32 ENDP 	

 00000391			resetlockasm32 PROC C public uses ebx edx es, shlock: dword, tid: dword 
 00000397  FA			        cli                   ; disable interrupts 
 00000398  06				push	es
 00000399  53				push	ebx
 0000039A  52				push	edx

 0000039B  66| B8 00C0			mov	ax, MEMDataSel; This is a zero base selector to access shared memory between aoa and application
 0000039F  66| 8E C0			mov	es, ax
 000003A2  BB 00008600			mov	ebx, S_Base
 000003A7  83 C3 4C			add	ebx, S_Lock1  ; base location of locks 
 000003AA  03 5D 08			add	ebx, shlock    ; lock number 
 000003AD  26: 8B 03			mov	eax, DWORD PTR es:[ebx]  ; get the lock value 
 000003B0  83 F8 01			cmp	eax, 1   ; is it locked? 
 000003B3  75 1E			jnz	itisnotlocked 
					; yes,it is locked  
 000003B5  8B D3			mov	edx, ebx ; save the pointer 
 000003B7  BB 00008600			mov	ebx, S_Base 
 000003BC  83 C3 5C			add	ebx, S_TID1   ; base of TID
 000003BF  03 5D 08			add	ebx, shlock   ; index of TID 
 000003C2  26: 8B 03			mov	eax, DWORD PTR es:[ebx]  ; get the TID stored during the set
 000003C5  3B 45 0C			cmp	eax, tid                 ; compare the TID 
 000003C8  75 09			jnz     itisnotlocked            ; locked by a wrong thread 
 000003CA  8B DA			mov	ebx, edx                 ; get the pointer 
 000003CC  26: C7 03			mov	DWORD PTR es:[ebx], 0 ; reset the lock 
	   00000000
 000003D3				itisnotlocked: 
					; it will return 1 if it is locked 
					; it will return 0 if it was not locked which is an error 

					; index is the index value in shared memory for a given variable 
					; eax has the data to be retunred 

 000003D3  5A				pop	edx
 000003D4  5B				pop	ebx
 000003D5  07				pop	es
 000003D6  FB			        sti   ; enable interrupts 
					ret
 000003DC			resetlockasm32 ENDP 	

 000003DC			testandsetasm32 PROC C public uses ebx es, shlock: dword, tid: dword 
 000003E1  FA				cli		
 000003E2  06				push	es
 000003E3  53				push	ebx

 000003E4  66| B8 00C0			mov	ax, MEMDataSel; This is a zero base selector to access shared memory between aoa and application
 000003E8  66| 8E C0			mov	es, ax
 000003EB  BB 00008600			mov	ebx, S_Base
 000003F0  83 C3 4C			add	ebx, S_Lock1  ; base location of locks 
 000003F3  03 5D 08			add	ebx, shlock    ; lock index 
 000003F6  26: 8B 03			mov	eax, DWORD PTR es:[ebx]  ; get the lock value 
 000003F9  83 F8 00			cmp	eax, 0   ; is it zero 
 000003FC  75 1E			jnz	itislocked 
 000003FE  B8 00000001			mov 	eax, 1   ; set lock 
 00000403  26: 89 03			mov	DWORD PTR es:[ebx], eax  ;save the lock 
 00000406  BB 00008600			mov     ebx, S_Base 
 0000040B  83 C3 5C			add 	ebx, S_TID1              ; base location of TID
 0000040E  03 5D 08			add 	ebx, shlock              ; lock index  
 00000411  8B 45 0C			mov	eax, tid
 00000414  26: 89 03			mov	DWORD PTR es:[ebx], eax  ;save the TID 
 00000417  B8 00000000			mov	eax, 0              ; return code is success 
 0000041C				itislocked: 
				        ; eax has 1
 0000041C  5B				pop	ebx
 0000041D  07				pop	es
					;-----------------------------------------
 0000041E  FB				sti
					ret
 00000423			testandsetasm32 ENDP 	

 00000423			setsharedmemcharasm32 PROC C public uses ebx es, index: dword, char1:BYTE, base1: dword 
 00000428  53				push	ebx
 00000429  06				push	es

 0000042A  66| B8 00C0			mov	ax, MEMDataSel; This is a zero base selector to access shared memory between aoa and application
 0000042E  66| 8E C0			mov	es, ax
 00000431  BB 00008600			mov	ebx, S_Base
 00000436  03 5D 10			add	ebx, base1; add the storage location
 00000439  03 5D 08			add	ebx, index 
 0000043C  8A 45 0C			mov	al, char1
 0000043F  26: 88 03			mov	BYTE PTR es:[ebx], al
					; al is stored in shared memory 
 00000442  07				pop	es
 00000443  5B				pop	ebx
					ret
 00000448			setsharedmemcharasm32 ENDP 	

 00000448			getsharedmemcharasm32 PROC C public uses ebx, index: dword, base1: dword 
 0000044C  53				push	ebx
 0000044D  06				push	es

 0000044E  66| B8 00C0			mov	ax, MEMDataSel; This is a zero base selector to access shared memory between aoa and application
 00000452  66| 8E C0			mov	es, ax
 00000455  BB 00008600			mov	ebx, S_Base
 0000045A  03 5D 0C			add	ebx, base1 ; add storage location address 
 0000045D  03 5D 08			add	ebx, index 
 00000460  26: 8A 03			mov	al, BYTE PTR es:[ebx]
					;al has the character to be returned  
 00000463  07				pop	es
 00000464  5B				pop	ebx
					ret
 00000468			getsharedmemcharasm32 ENDP 	

 00000468			getmemasm32 PROC C public uses ebx es, address: dword
 0000046D  53				push	ebx
 0000046E  06				push	es

 0000046F  66| B8 00C0			mov	ax, MEMDataSel; This is a zero base selector to access shared memory between aoa and application
 00000473  66| 8E C0			mov	es, ax
 00000476  BB 00000000			mov	ebx, 0 
 0000047B  03 5D 08			add	ebx, address 
 0000047E  26: 8B 03			mov	eax, DWORD PTR es:[ebx]
					; addr is the absolute address in memory 
					; eax has the data to be retunred 
 00000481  07				pop 	es
 00000482  5B				pop	ebx
				        ;--------trace Code----------------------
				;	push	es
				;	push	ebx
				;	push	eax

				;	mov	ax, MEMDataSel
				;	mov	es, ax
				;	mov	ebx, S_Base
				;	add	ebx, S_Error_Flag
				;	mov	eax, DWORD PTR es:[ebx] ;get error flag
				;	cmp	eax, 0			; check if flag is zero 
				;	jnz	skipupdate
				;	mov	eax, 0126h
				;	mov	ebx, S_Base
				;	add	ebx, S_IO_Function_Code
				;	mov	DWORD PTR es:[ebx], eax

				;       skipupdate:
				;	pop	eax
				;	pop	ebx
				;	pop	es
					;--------end trace code------------------

					ret
 00000487			getmemasm32 ENDP 	
				;------------------------------------------------------------------
				; set memory protected 
				;------------------------------------------------------------------
 00000487			setmemasm32 PROC C public uses ebx es, address: dword, data:dword
 0000048C  53				push	ebx
 0000048D  06				push	es

 0000048E  66| B8 00C0			mov	ax, MEMDataSel; This is a zero base selector to access shared memory between aoa and application
 00000492  66| 8E C0			mov	es, ax
 00000495  BB 00000000			mov	ebx, 0 
 0000049A  03 5D 08			add	ebx, address 
 0000049D  8B 45 0C			mov 	eax, data
 000004A0  26: 89 03			mov	DWORD PTR es:[ebx], eax
					; addr is the absolute address in memory 
					; eax has the data to be retunred 

 000004A3  07				pop	es
 000004A4  5B				pop	ebx

					ret
 000004A9			setmemasm32 ENDP 	
				;-----------------------------------------------------------------
				;  get real memory 
				;-----------------------------------------------------------------
 000004A9			getrealmemory PROC C public uses ebx es, address:dword
 000004AE  53				push	ebx
 000004AF  06				push	es

 000004B0  66| B8 00C0			mov	ax, MEMDataSel
				        ; This is a zero base selector to access shared memory between aoa and application
 000004B4  66| 8E C0			mov	es, ax
 000004B7  BB 00000000			mov	ebx, 0 
 000004BC  03 5D 08			add	ebx, address 
 000004BF  26: 8B 03			mov	eax, DWORD PTR es:[ebx]
					; addr is the absolute address in memory 
					; eax has the data to be retunred 
 000004C2  07				pop 	es
 000004C3  5B				pop	ebx
					ret
 000004C8			getrealmemory ENDP 	

 000004C8			getstackpopasm32 PROC C public uses edx esi, index:DWORD 
					; return the top of the stack value 4 bytes 
					; ESP - index address is used to address stack 
					; eax has the return value 

 000004CD  8B F5			mov esi, ebp 
 000004CF  03 75 08			add esi, index 
 000004D2  36: 8B 06			mov eax, DWORD PTR ss:[esi] ;get the stack value 

					ret
 000004D9			getstackpopasm32 ENDP 	

				; gets a character using interrupts 
 000004D9			getcharintasm32 PROC C public uses ebx es  
 000004DB  CD F5				int	0f5h  ; 
						ret

 000004E0			getcharintasm32 ENDP 	

 000004E0			getcharbuffasm32 PROC C public 

 000004E0  CD F6			int	0f6h
				        ;--------trace Code----------------------
 000004E2  06				push	es
 000004E3  53				push	ebx
 000004E4  50				push	eax

 000004E5  66| B8 00C0			mov	ax, MEMDataSel
 000004E9  66| 8E C0			mov	es, ax
 000004EC  BB 00008600			mov	ebx, S_Base
 000004F1  83 C3 18			add	ebx, S_Error_Flag
 000004F4  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 000004F7  83 F8 00			cmp	eax, 0			; check if flag is zero 
 000004FA  75 10			jnz	skipupdate
 000004FC  B8 00000104			mov	eax, 0104h
 00000501  BB 00008600			mov	ebx, S_Base
 00000506  83 C3 20			add	ebx, S_IO_Function_Code
 00000509  26: 89 03			mov	DWORD PTR es:[ebx], eax

 0000050C			        skipupdate:
 0000050C  58				pop	eax
 0000050D  5B				pop	ebx
 0000050E  07				pop	es
					;--------end trace code------------------
 0000050F  C3				ret
 00000510			getcharbuffasm32 ENDP 	

 00000510			readfloppyasm32 PROC C public uses eax ebx ecx, buffer1:ptr byte, sectorno: dword

 00000516  53			        push ebx 
 00000517  06				push es 
 00000518  0F A0			push fs 

				        ; setup the sector number in shared memory 
 0000051A  66| B8 00C0			mov ax, MEMDataSel ; 0 base in protected mode 
 0000051E  66| 8E C0			mov es, ax 
 00000521  BB 00008600			mov ebx, S_Base     ; base value of shared memory 
 00000526  83 C3 04			add ebx, S_SectorNo ; offset of the sector number in shared mem 
 00000529  8B 45 0C			mov eax, sectorno
 0000052C  26: 89 03			mov DWORD PTR es:[ebx], eax ;store the sector no in shared memory 

 0000052F  0F A1		        pop fs
 00000531  07			        pop es
 00000532  5B			        pop ebx 

 00000533  CD FA			int	0fah        ; read one sector into 8400h 

					;copy the data in 8400h to user memory specified by the ptr 
					 
 00000535  66| B8 00C0			mov ax, MEMDataSel ; 0 base in protected mode 
 00000539  66| 8E C0			mov es, ax 
 0000053C  BB 00008400			mov ebx, 8400h     ; base value of data 
 00000541  8B 75 08			mov esi, buffer1 
 00000544  B9 00000011			mov ecx, D_ADDROFFSET ; D_ADDROFFSET is upper 2 bytes 
					; all EQU all 2 bytes in limit 
 00000549  C1 E1 10			shl ecx, 16           ; to top 2 bytes 
 0000054C  03 F1			add esi, ecx          ; add the offset  

 0000054E  51			        push ecx           ; save registers  
 0000054F  53				push ebx 
 00000550  0F A0			push fs 
 00000552  06				push es 

 00000553  B9 00000080			mov ecx, 128 		   ; one sector or 512 bytes 
 00000558			movonesector1: 
 00000558  26: 8B 03		        mov eax, DWORD PTR es:[ebx]  ; 4 bytes at a time, source 
 0000055B  26: 89 06			mov DWORD PTR es:[esi], eax  ; destination 
 0000055E  83 C3 04			add ebx, 4
 00000561  83 C6 04			add esi, 4
 00000564  E2 F2			LOOP movonesector1         ; loop 

 00000566  07				pop es 		; restore registers 
 00000567  0F A9			pop gs 
 00000569  5B				pop ebx 
 0000056A  59				pop ecx 
				        ;--------trace Code----------------------
 0000056B  06				push	es
 0000056C  53				push	ebx
 0000056D  50				push	eax

 0000056E  66| B8 00C0			mov	ax, MEMDataSel
 00000572  66| 8E C0			mov	es, ax
 00000575  BB 00008600			mov	ebx, S_Base
 0000057A  83 C3 18			add	ebx, S_Error_Flag
 0000057D  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 00000580  83 F8 00			cmp	eax, 0			; check if flag is zero 
 00000583  75 10			jnz	skipupdate
 00000585  B8 00000116			mov	eax, 0116h
 0000058A  BB 00008600			mov	ebx, S_Base
 0000058F  83 C3 20			add	ebx, S_IO_Function_Code
 00000592  26: 89 03			mov	DWORD PTR es:[ebx], eax

 00000595			        skipupdate:
 00000595  58				pop	eax
 00000596  5B				pop	ebx
 00000597  07				pop	es
					;--------end trace code------------------
					ret
 0000059D			readfloppyasm32 ENDP 	

 0000059D			writefloppyasm32 PROC C public uses eax ebx ecx, buffer1:ptr byte, sectorno: dword

 000005A3  53			        push ebx 
 000005A4  06				push es 
 000005A5  0F A0			push fs 
 000005A7  51				push ecx 
 000005A8  56				push esi 

				        ; setup the sector number in shared memory 
 000005A9  66| B8 00C0			mov ax, MEMDataSel ; 0 base in protected mode 
 000005AD  66| 8E C0			mov es, ax 
 000005B0  BB 00008600			mov ebx, S_Base     ; base value of shared memory 
 000005B5  83 C3 04			add ebx, S_SectorNo ; offset of the sector number in shared mem 
 000005B8  8B 45 0C			mov eax, sectorno
 000005BB  26: 89 03			mov DWORD PTR es:[ebx], eax ;store the sector no in shared memory 

					;copy the data from user memory to 8400h  
 000005BE  66| B8 00C0			mov ax, MEMDataSel ; 0 base in protected mode 
 000005C2  66| 8E C0			mov es, ax 
 000005C5  BB 00008400			mov ebx, 8400h     ; base value of data 
 000005CA  8B 75 08			mov esi, buffer1 
 000005CD  B9 00000011			mov ecx, D_ADDROFFSET ; EQU is limited to 2 bytes 
 000005D2  C1 E1 10			shl ecx,16            ; store only the top 2 bytes in EQU
 000005D5  03 F1			add esi, ecx; add data segment offset address to user memory 

 000005D7  B9 00000080			mov ecx, 128 
 000005DC			movuserto8400: 
 000005DC  26: 8B 06		        mov eax, DWORD PTR es:[esi] ; get 4 bytes from user memory 
 000005DF  26: 89 03			mov DWORD PTR es:[ebx],eax     ; move the 4 bytes to 8400 block  
 000005E2  83 C3 04			add ebx, 4 
 000005E5  83 C6 04			add esi, 4 
 000005E8  E2 F2		  	LOOP movuserto8400        ; move all 128 dwords or 512 bytes         

 000005EA  5E			        pop esi  
 000005EB  59			        pop ecx  
 000005EC  0F A1		        pop fs
 000005EE  07			        pop es
 000005EF  5B			        pop ebx 

 000005F0  CD F4			int	0f4h        ; write one sector from 8400h to disk  
				        ;--------trace Code----------------------
 000005F2  06				push	es
 000005F3  53				push	ebx
 000005F4  50				push	eax

 000005F5  66| B8 00C0			mov	ax, MEMDataSel
 000005F9  66| 8E C0			mov	es, ax
 000005FC  BB 00008600			mov	ebx, S_Base
 00000601  83 C3 18			add	ebx, S_Error_Flag
 00000604  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 00000607  83 F8 00			cmp	eax, 0			; check if flag is zero 
 0000060A  75 10			jnz	skipupdate
 0000060C  B8 00000117			mov	eax, 0117h
 00000611  BB 00008600			mov	ebx, S_Base
 00000616  83 C3 20			add	ebx, S_IO_Function_Code
 00000619  26: 89 03			mov	DWORD PTR es:[ebx], eax

 0000061C			        skipupdate:
 0000061C  58				pop	eax
 0000061D  5B				pop	ebx
 0000061E  07				pop	es
					;--------end trace code------------------
					ret
 00000624			writefloppyasm32 ENDP 	

				;------------------------------------------------------------------
				; This procedure sets two long values given by C++ programmer in GDT Entry
				;   given one appno which is the GDTIndex value 
				; Application programmer must keep track of the GDTIndex to get the given descriptor 
				; The two long values will be used to set a total of 8 byte descriptor 
				;------------------------------------------------------------------
 00000624			setGDTEntryasm32 PROC C public uses edi es, descriptorh:PTR DWORD, descriptorl:PTR DWORD,appno:WORD
 00000629  66| B8 0018			mov	ax, RDataSel
 0000062D  66| 8E C0			mov	es, ax
 00000630  8B 75 08			mov 	esi, descriptorh    ; offset of the high ptr
 00000633  BF 00000000			mov	edi, 0		    ; offset of GDT from the base of RDataSeg
 00000638  B8 00000000			mov	eax,0
 0000063D  66| 8B 45 10			mov	ax,appno            ; GDTInex value 
 00000641  BB 00000008			mov	ebx,08h ; 8 byte for each index value 
 00000646  66| F7 E3			mul	bx
 00000649  03 F8			add	edi,eax             ; actual index for a given entry
 0000064B  8B 06			mov	eax, DWORD PTR [esi]; the data value for App1TSS 4 bytes 
 0000064D  26: 89 07		        mov	DWORD PTR es:[edi], eax ; set higher 4 bytes in value by reference 
 00000650  8B 75 0C			mov 	esi, descriptorl    ; next 4 bytes 	
 00000653  8B 06			mov	eax,DWORD PTR [esi]
 00000655  26: 89 47 04			mov	DWORD PTR es:[edi+4], eax ; store the lower 4 bytes in value by reference 
 00000659  B8 00000000			mov	eax,0               ; return code 0 if successful

					       ;--------trace Code----------------------
 0000065E  06				push	es
 0000065F  53				push	ebx
 00000660  50				push	eax

 00000661  66| B8 00C0			mov	ax, MEMDataSel
 00000665  66| 8E C0			mov	es, ax
 00000668  BB 00008600			mov	ebx, S_Base
 0000066D  83 C3 18			add	ebx, S_Error_Flag
 00000670  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 00000673  83 F8 00			cmp	eax, 0			; check if flag is zero 
 00000676  75 10			jnz	skipupdate
 00000678  B8 00000135			mov	eax, 0135h
 0000067D  BB 00008600			mov	ebx, S_Base
 00000682  83 C3 20			add	ebx, S_IO_Function_Code
 00000685  26: 89 03			mov	DWORD PTR es:[ebx], eax

 00000688			        skipupdate:
 00000688  58				pop	eax
 00000689  5B				pop	ebx
 0000068A  07				pop	es
					;--------end trace code------------------

					ret
 0000068F			setGDTEntryasm32 ENDP 	

				;------------------------------------------------------------------
				; This procedure returns two long values to C++ programmer 
				;   given one appno which is the GDTIndex value 
				; Application programmer must keep track of the GDTIndex to get the given descriptor 
				; The two long values will return a total of 8 byte descriptor 
				;------------------------------------------------------------------
 0000068F			getGDTEntryasm32 PROC C public uses edi es, descriptorh:PTR DWORD, descriptorl:PTR DWORD,appno:WORD
 00000694  B8 00000018			mov	eax, RDataSel
 00000699  66| 8E C0			mov	es, ax
 0000069C  8B 75 08			mov 	esi, descriptorh    ; offset of the high ptr
 0000069F  BF 00000000			mov	edi,0		    ; offset of GDT from the base of RDataSeg	
 000006A4  B8 00000000			mov	eax,0
 000006A9  66| 8B 45 10			mov	ax,appno            ; GDTInex value 
 000006AD  BB 00000008			mov	ebx,08h ; 8 byte for each index value 
 000006B2  66| F7 E3			mul	bx
 000006B5  03 F8			add	edi,eax             ; actual index for a given entry
 000006B7  26: 8B 07			mov	eax, es:[edi]       ; the data value for App1TSS 4 bytes 
 000006BA  89 06		        mov	DWORD PTR [esi], eax ; store higher 4 bytes in value by reference 
 000006BC  8B 75 0C			mov 	esi, descriptorl    ; next 4 bytes 	
 000006BF  26: 8B 47 04			mov	eax, es:[edi+4]
 000006C3  89 06			mov	DWORD PTR [esi], eax ; store the lower 4 bytes in value by reference 
 000006C5  B8 00000000			mov	eax,0               ; return code 0 if successful!

				       ;--------trace Code----------------------
 000006CA  06				push	es
 000006CB  53				push	ebx
 000006CC  50				push	eax

 000006CD  66| B8 00C0			mov	ax, MEMDataSel
 000006D1  66| 8E C0			mov	es, ax
 000006D4  BB 00008600			mov	ebx, S_Base
 000006D9  83 C3 18			add	ebx, S_Error_Flag
 000006DC  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 000006DF  83 F8 00			cmp	eax, 0			; check if flag is zero 
 000006E2  75 10			jnz	skipupdate
 000006E4  B8 00000134			mov	eax, 0134h
 000006E9  BB 00008600			mov	ebx, S_Base
 000006EE  83 C3 20			add	ebx, S_IO_Function_Code
 000006F1  26: 89 03			mov	DWORD PTR es:[ebx], eax

 000006F4			        skipupdate:
 000006F4  58				pop	eax
 000006F5  5B				pop	ebx
 000006F6  07				pop	es
					;--------end trace code------------------

					ret
 000006FB			getGDTEntryasm32 ENDP 	


				;------------------------------------------------------------------
				; This procedure returns two long values to C++ programmer 
				;   given one appno which is the GDTIndex value 
				; We assume that AppGDTPtr in RDataSeg has the address for the 
				;  starting point of App1TSS in GDT 
				; Application programmer must keep track of the GDTIndex to get the given descriptor 
				; The two long values will return a total of 8 byte descriptor 
				;------------------------------------------------------------------
 000006FB			getIDTEntryasm32 PROC C public uses edi es ebx, descriptorh:PTR DWORD, descriptorl:PTR DWORD,appno:WORD

 00000701  56				push	esi
 00000702  57				push	edi
 00000703  53				push	ebx
 00000704  66| B8 00C0			mov	ax, MEMDataSel
 00000708  66| 8E C0			mov	es, ax
 0000070B  BB 00008600			mov	ebx, S_Base
 00000710  83 C3 0C			add	ebx, S_IDTOffset
 00000713  BF 00000000			mov	edi, 0
 00000718  66| 26: 8B 3B		mov	di, WORD PTR es:[ebx] ; get the base of IDT from shared memory
						
 0000071C  8B 75 08			mov 	esi, descriptorh    ; offset of the high ptr

 0000071F  B8 00000000			mov	eax,0
 00000724  66| 8B 45 10			mov	ax,appno            ; IDTInex value 
 00000728  BB 00000008			mov	ebx,08h ; 8 byte for each index value 
 0000072D  66| F7 E3			mul	bx
 00000730  03 F8			add	edi,eax             ; actual index for a given entry
					
 00000732  26: 8B 07			mov	eax, es:[edi]       ; the data value for IDTEntry 4 bytes 
 00000735  89 06		        mov	DWORD PTR [esi], eax ; store higher 4 bytes in value by reference 
 00000737  8B 75 0C			mov 	esi, descriptorl    ; next 4 bytes 	
 0000073A  26: 8B 47 04			mov	eax, es:[edi+4]
 0000073E  89 06			mov	DWORD PTR [esi], eax ; store the lower 4 bytes in value by reference 
 00000740  B8 00000000			mov	eax,0               ; return code 0 if successful!
 00000745  5B				pop	ebx
 00000746  5F				pop	edi
 00000747  5E				pop	esi

				       ;--------trace Code----------------------
 00000748  06				push	es
 00000749  53				push	ebx
 0000074A  50				push	eax

 0000074B  66| B8 00C0			mov	ax, MEMDataSel
 0000074F  66| 8E C0			mov	es, ax
 00000752  BB 00008600			mov	ebx, S_Base
 00000757  83 C3 18			add	ebx, S_Error_Flag
 0000075A  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 0000075D  83 F8 00			cmp	eax, 0			; check if flag is zero 
 00000760  75 10			jnz	skipupdate
 00000762  B8 00000136			mov	eax, 0136h
 00000767  BB 00008600			mov	ebx, S_Base
 0000076C  83 C3 20			add	ebx, S_IO_Function_Code
 0000076F  26: 89 03			mov	DWORD PTR es:[ebx], eax

 00000772			        skipupdate:
 00000772  58				pop	eax
 00000773  5B				pop	ebx
 00000774  07				pop	es
					;--------end trace code------------------

					ret
 0000077A			getIDTEntryasm32 ENDP 	


 0000077A			setIDTEntryasm32 PROC C public uses edi es ebx, descriptorh:PTR DWORD, descriptorl:PTR DWORD,appno:WORD

					
					;mov	eax, 0ABCDh
					;mov	ebx, 1480h
					;int 	0fdh
					
 00000780  FA				cli
 00000781  66| B8 00C0			mov	ax, MEMDataSel
 00000785  66| 8E C0			mov	es, ax
 00000788  BB 00008600			mov	ebx, S_Base
 0000078D  83 C3 0C			add	ebx, S_IDTOffset
 00000790  BF 00000000			mov	edi, 0

					
 00000795  66| 26: 8B 3B		mov	di, WORD PTR es:[ebx] ; get the base of IDT from shared memory

 00000799  8B 75 08			mov 	esi, descriptorh    ; offset of the high ptr
					
 0000079C  B8 00000000			mov	eax,0
 000007A1  66| 8B 45 10			mov	ax,appno            ; IDTInex value 
 000007A5  BB 00000008			mov	ebx,08h ; 8 byte for each index value 
 000007AA  66| F7 E3			mul	bx
 000007AD  03 F8			add	edi,eax             ; actual index for a given entry
 000007AF  8B 06			mov	eax, DWORD PTR [esi]; the data value for App1TSS 4 bytes 
 000007B1  26: 89 07		        mov	DWORD PTR es:[edi], eax ; set higher 4 bytes in value by reference 
 000007B4  8B 75 0C			mov 	esi, descriptorl    ; next 4 bytes 	
 000007B7  8B 06			mov	eax,DWORD PTR [esi]
 000007B9  26: 89 47 04			mov	DWORD PTR es:[edi+4], eax ; store the lower 4 bytes in value by reference 
 000007BD  B8 00000000			mov	eax,0               ; return code 0 if successful
 000007C2  FB				sti

				       ;--------trace Code----------------------
 000007C3  06				push	es
 000007C4  53				push	ebx
 000007C5  50				push	eax

 000007C6  66| B8 00C0			mov	ax, MEMDataSel
 000007CA  66| 8E C0			mov	es, ax
 000007CD  BB 00008600			mov	ebx, S_Base
 000007D2  83 C3 18			add	ebx, S_Error_Flag
 000007D5  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 000007D8  83 F8 00			cmp	eax, 0			; check if flag is zero 
 000007DB  75 10			jnz	skipupdate
 000007DD  B8 00000137			mov	eax, 0137h
 000007E2  BB 00008600			mov	ebx, S_Base
 000007E7  83 C3 20			add	ebx, S_IO_Function_Code
 000007EA  26: 89 03			mov	DWORD PTR es:[ebx], eax

 000007ED			        skipupdate:
 000007ED  58				pop	eax
 000007EE  5B				pop	ebx
 000007EF  07				pop	es
					;--------end trace code------------------

					ret
 000007F5			setIDTEntryasm32 ENDP 	

 000007F5			ShortDelay PROC C public uses ebx, Delay:dword
 000007F9  53				push	ebx
 000007FA  52				push	edx
					
 000007FB  B8 00000163			mov	eax, Processor_Speed		; Get the speed of the processor
 00000800  8B 55 08			mov	edx, Delay			; Get the delay in micro seconds
 00000803  F7 E2			mul	edx				; multiply the processor speed with the delay
 00000805  B9 00000005			mov	ecx, NoOfCycles_Delay		; Get the no of cycles for the loop instruction
 0000080A  F7 F1			div	ecx; The result of div is in eax; divide the multiplied result with the No of cycles	
 0000080C  8B C8			mov	ecx, eax
 0000080E			DELAYLOOP:
 0000080E  E2 FE			loop	DELAYLOOP			; Wait in a loop untill the time is done
 00000810  B8 00000000			mov	eax, 0
 00000815  5A				pop	edx
 00000816  5B				pop	ebx

				        ;--------trace Code----------------------
 00000817  06				push	es
 00000818  53				push	ebx
 00000819  50				push	eax

 0000081A  66| B8 00C0			mov	ax, MEMDataSel
 0000081E  66| 8E C0			mov	es, ax
 00000821  BB 00008600			mov	ebx, S_Base
 00000826  83 C3 18			add	ebx, S_Error_Flag
 00000829  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 0000082C  83 F8 00			cmp	eax, 0			; check if flag is zero 
 0000082F  75 10			jnz	skipupdate
 00000831  B8 00000120			mov	eax, 0120h
 00000836  BB 00008600			mov	ebx, S_Base
 0000083B  83 C3 20			add	ebx, S_IO_Function_Code
 0000083E  26: 89 03			mov	DWORD PTR es:[ebx], eax

 00000841			        skipupdate:
 00000841  58				pop	eax
 00000842  5B				pop	ebx
 00000843  07				pop	es
					;--------end trace code------------------

					ret
 00000847			ShortDelay ENDP 	


 00000847			printregsasm32 PROC C public uses edx esi, pos:DWORD 
				 ; print all general purpose registers on the screen 
				 ; starting position at pos 
 0000084C  50			 	push	eax
 0000084D  52			 	push	edx
 0000084E  56				push	esi
 0000084F  53				push	ebx
 00000850  06				push	es

 00000851  8B 55 08		 	mov 	edx, pos ; store the start line 

 00000854  B0 43		  	mov 	al, 'C'
 00000856  8B DA			mov	ebx, edx 
 00000858  83 C3 02			add	ebx, 2
 0000085B  CD F7			int	0f7h
 0000085D  B0 53		  	mov 	al, 'S'
 0000085F  83 C3 02			add	ebx, 2 
 00000862  E8 00000204			call	printchar32  
					;int	0f7h

 00000867  83 C3 12			add	ebx, 18 
 0000086A  B0 44			mov 	al, 'D'
 0000086C  CD F7			int	0f7h
 0000086E  B0 53			mov	al, 'S'
 00000870  83 C3 02			add	ebx, 2
 00000873  E8 000001F3			call	printchar32  
					;int	0f7h

 00000878  83 C3 12			add	ebx, 18 
 0000087B  B0 53			mov 	al, 'S'
 0000087D  CD F7			int	0f7h
 0000087F  B0 53			mov	al, 'S'
 00000881  83 C3 02			add	ebx, 2
 00000884  E8 000001E2			call	printchar32  
					;int	0f7h

 00000889  83 C3 12			add	ebx, 18 
 0000088C  B0 45			mov 	al, 'E'
 0000088E  CD F7			int	0f7h
 00000890  B0 53			mov	al, 'S'
 00000892  83 C3 02			add	ebx, 2
 00000895  E8 000001D1			call	printchar32  
					;int	0f7h

 0000089A  83 C3 12			add	ebx, 18 
 0000089D  B0 46			mov 	al, 'F'
 0000089F  CD F7			int	0f7h
 000008A1  B0 53			mov	al, 'S'
 000008A3  83 C3 02			add	ebx, 2
 000008A6  E8 000001C0			call	printchar32  
					;int	0f7h

 000008AB  83 C3 12			add	ebx, 18 
 000008AE  B0 47			mov 	al, 'G'
 000008B0  CD F7			int	0f7h
 000008B2  B0 53			mov	al, 'S'
 000008B4  83 C3 02			add	ebx, 2
 000008B7  E8 000001AF			call	printchar32  
					;int	0f7h

 000008BC  81 C2 000000A0		add	edx, 160 
 000008C2  8B DA			mov	ebx, edx 

 000008C4  B8 00000000		 	mov 	eax, 0
 000008C9  66| 8C C8		 	mov	ax, cs 	; CS register 
 000008CC  CD FD			int	0fdh
					
 000008CE  B8 00000000			mov 	eax, 0
 000008D3  66| 8C D8		 	mov	ax, ds 	; DS register 
 000008D6  83 C3 04			add	ebx, 4
 000008D9  CD FD			int	0fdh

 000008DB  B8 00000000			mov 	eax, 0
 000008E0  66| 8C D0		 	mov	ax, ss 	; SS register 
 000008E3  83 C3 04			add	ebx, 4
 000008E6  CD FD			int	0fdh
					
 000008E8  B8 00000000			mov 	eax, 0
 000008ED  66| 8C C0		 	mov	ax, es 	; ES register 
 000008F0  83 C3 04			add	ebx, 4
 000008F3  CD FD			int	0fdh

 000008F5  B8 00000000			mov 	eax, 0
 000008FA  66| 8C E0		 	mov	ax, fs 	; FS register 
 000008FD  83 C3 04			add	ebx, 4
 00000900  CD FD			int	0fdh

 00000902  B8 00000000			mov 	eax, 0
 00000907  66| 8C E8		 	mov	ax, gs 	; GS register 
 0000090A  83 C3 04			add	ebx, 4
 0000090D  CD FD			int	0fdh

					;----next line 
 0000090F  81 C2 000000A0		add	edx, 160 
 00000915  8B DA			mov	ebx, edx 

 00000917  B0 45			mov 	al, 'E'
 00000919  8B DA			mov	ebx, edx 
 0000091B  83 C3 02			add	ebx, 2
 0000091E  E8 00000148			call	printchar32  
					;int	0f7h
 00000923  B0 53		  	mov 	al, 'S'
 00000925  83 C3 02			add	ebx, 2 
 00000928  CD F7			int	0f7h
 0000092A  B0 50		  	mov 	al, 'P'
 0000092C  83 C3 02			add	ebx, 2 
 0000092F  E8 00000137			call	printchar32  
					;int	0f7h

 00000934  83 C3 10			add	ebx, 16 
 00000937  B0 45			mov 	al, 'E'
 00000939  E8 0000012D			call	printchar32  
					;int	0f7h
 0000093E  B0 42			mov	al, 'B'
 00000940  83 C3 02			add	ebx, 2
 00000943  E8 00000123			call	printchar32  
					;int	0f7h
 00000948  B0 50			mov	al, 'P'
 0000094A  83 C3 02			add	ebx, 2
 0000094D  E8 00000119			call	printchar32  
					;int	0f7h

 00000952  83 C3 10			add	ebx, 16 
 00000955  B0 47			mov 	al, 'G'
 00000957  E8 0000010F			call	printchar32  
					;int	0f7h
 0000095C  B0 44			mov	al, 'D'
 0000095E  83 C3 02			add	ebx, 2
 00000961  E8 00000105			call	printchar32  
					;int	0f7h
 00000966  B0 54			mov	al, 'T'
 00000968  83 C3 02			add	ebx, 2
 0000096B  CD F7			int	0f7h

 0000096D  83 C3 10			add	ebx, 16 
 00000970  B0 4C			mov 	al, 'L'
 00000972  E8 000000F4			call	printchar32  
					;int	0f7h
 00000977  B0 44			mov	al, 'D'
 00000979  83 C3 02			add	ebx, 2
 0000097C  E8 000000EA			call	printchar32  
					;int	0f7h
 00000981  B0 54			mov	al, 'T'
 00000983  83 C3 02			add	ebx, 2
 00000986  E8 000000E0			call	printchar32  
					;int	0f7h

 0000098B  83 C3 10			add	ebx, 16 
 0000098E  B0 54			mov 	al, 'T'
 00000990  E8 000000D6			call	printchar32  
					;int	0f7h
 00000995  B0 52			mov	al, 'R'
 00000997  83 C3 02			add	ebx, 2
 0000099A  E8 000000CC			call	printchar32  
					;int	0f7h

 0000099F  83 C3 10			add	ebx, 16 
 000009A2  B0 46			mov 	al, 'F'
 000009A4  E8 000000C2			call	printchar32  
					;int	0f7h
 000009A9  B0 4C			mov	al, 'L'
 000009AB  83 C3 02			add	ebx, 2
 000009AE  E8 000000B8			call	printchar32  
					;int	0f7h
 000009B3  B0 41			mov	al, 'A'
 000009B5  83 C3 02			add	ebx, 2
 000009B8  E8 000000AE			call	printchar32  
					;int	0f7h
 000009BD  B0 47			mov	al, 'G'
 000009BF  83 C3 02			add	ebx, 2
 000009C2  E8 000000A4			call	printchar32  
					;int	0f7h
 000009C7  B0 53			mov	al, 'S'
 000009C9  83 C3 02			add	ebx, 2
 000009CC  E8 0000009A			call	printchar32  
					;int	0f7h
					;----next line 
 000009D1  81 C2 000000A0	        add	edx, 160
 000009D7  8B DA			mov	ebx, edx  
 000009D9  8B C4		 	mov	eax, esp ; ESP register 
 000009DB  CD FD			int	0fdh

 000009DD  8B C5		 	mov	eax, ebp ; EBP register 
 000009DF  83 C3 04			add	ebx, 4
 000009E2  CD FD			int	0fdh

 000009E4  66| B8 00C0			mov	ax, MEMDataSel; This is a zero base selector to access shared memory between aoa and application
 000009E8  66| 8E C0			mov	es, ax
 000009EB  BB 00008600			mov	ebx, S_Base
 000009F0  81 C3 00000094		add	ebx, S_DUMMY  ; dummy location for store  
 000009F6  B8 00000000			mov	eax, 0
 000009FB  26: 0F 01 05			sgdt	es:[0]
	   00000000
 00000A03  26: A1			mov	eax, es:[2] ;GDT Register base address  
	   00000002
 00000A09  83 C3 04			add	ebx, 4
 00000A0C  CD FD			int	0fdh

 00000A0E  B8 00000000			mov	eax, 0 
 00000A13  0F 00 C0			sldt	ax       ;LDT Register 
 00000A16  83 C3 04			add	ebx, 4
 00000A19  CD FD			int	0fdh

 00000A1B  B8 00000000			mov	eax, 0
 00000A20  0F 00 C8			str	ax       ; TR Task Register
 00000A23  83 C3 04			add	ebx, 4
 00000A26  CD FD			int	0fdh

 00000A28  9C				pushfd            ; FLAGS
 00000A29  58				pop 	eax      ; flags in eax 
 00000A2A  83 C3 04			add 	ebx, 4 
 00000A2D  CD FD			int 	0fdh

 00000A2F  B8 00000000		        mov 	eax, 0
 00000A34  26: A1			mov	eax, es:[0] ;GDT Register offset  
	   00000000
 00000A3A  83 C3 04			add	ebx, 4
 00000A3D  CD FD			int	0fdh

 00000A3F  07				pop	es
 00000A40  5B				pop	ebx
 00000A41  5E				pop	esi
 00000A42  5A				pop	edx
 00000A43  58				pop	eax

					ret
 00000A48			printregsasm32 ENDP 	

 00000A48			printstackregsasm32 PROC C public uses edx esi, pos:DWORD 
				   ; print ESP and EBP 
 00000A4D  50			 	push	eax
 00000A4E  52			 	push	edx
 00000A4F  56				push	esi
 00000A50  53				push	ebx
 00000A51  06				push	es

 00000A52  8B 55 08		 	mov 	edx, pos ; store the start line 
 00000A55  8B DA			mov	    ebx, edx  
 00000A57  8B C4		 	mov	    eax, esp ; ESP register 
 00000A59  CD FD			int	    0fdh

 00000A5B  83 C3 14		    add     ebx, 20
 00000A5E  8B C5		 	mov	    eax, ebp ; EBP register 
 00000A60  CD FD			int	    0fdh

 00000A62  07				pop	es
 00000A63  5B				pop	ebx
 00000A64  5E				pop	esi
 00000A65  5A				pop	edx
 00000A66  58				pop	eax

					ret
 00000A6B			printstackregsasm32 ENDP 	
				;--------------------------------------
				; al has the char and edx has the position 
				;---------------------------------------
 00000A6B			printchar32 PROC C public uses eax ebx
 00000A6D  50				push	eax
 00000A6E  53				push	ebx

					;-----------------------------------------
					; replace f7 interrupt in prcycle with this code 
					;  this is same code as in prcycle, however, it needs Video_Sel 
 00000A6F  06					push	es

 00000A70  50			                push    eax      ;save eax
 00000A71  66| B8 0010				mov     ax,Video_Sel_Loc ; Video_Sel selector watch for changes in prcycle 
 00000A75  66| 8E C0				mov     es,ax
 00000A78  58					pop	eax
						;mov     ah,17h
 00000A79  B4 07				mov	ah, 7 
 00000A7B  66| 26: 89 03	                mov     WORD PTR es:[ebx],ax

 00000A7F  07					pop	es
					;-----------------------------------------

 00000A80  5B				pop	ebx
 00000A81  58				pop	eax

					ret
 00000A85			printchar32 ENDP 	

				;--------------------------------------
				; eax has the data and ebx has the pointer 
				;---------------------------------------
 00000A85			printhex    PROC    FAR
 00000A85  51				PUSH    ECX
 00000A86  57				PUSH    EDI
 00000A87  1E				PUSH	DS
 00000A88  50				push	eax

 00000A89  53				push 	ebx
 00000A8A  50				push    eax

					;mov     ax,Puthex32DataSel
 00000A8B  66| 8E D8			mov     ds,ax

 00000A8E  58				pop     eax
 00000A8F  5B				pop	ebx

					;MOV     PrintDataP, eax         ; save data in memory
 00000A90  B9 00000008			MOV     ecx, 8                  ; eight characters
 00000A95			PutHexLoopP:
					;MOV     eax, PrintDataP         ; data in eax
 00000A95  25 F0000000			AND     eax, 0F0000000h         ; select first nibble
 00000A9A  C1 C0 04			ROL     eax,4                   ; get the count on right
					;MOV     IndexCntP, eax          ; store the index 
					;MOV     edi, IndexCntP 
					;MOV     al, BYTE PTR HexTableP[edi]  ; get hex character

 00000A9D  83 C3 02			add     ebx,2                   ; Next character
 00000AA0  CD F7			int     0f7h			

					;MOV     eax, PrintDataP         ; get the stored data
 00000AA2  C1 E0 04			SHL     eax, 4                  ; shift to next nibble
					;MOV     PrintDataP, eax         ; store remaining data 
					;LOOP    PutHexLoopP             ; print all 8 hex characters

 00000AA5  58				pop	eax
 00000AA6  1F				POP     DS
 00000AA7  5F				POP     EDI
 00000AA8  59				POP     ECX

 00000AA9  CB				ret

 00000AAA			printhex       ENDP



 00000AAA			getsharedmemasm32 PROC C public uses ebx es, index: dword
 00000AAF  53				push    ebx
 00000AB0  06				push    es
					
 00000AB1  66| B8 00C0			mov	ax, MEMDataSel; This is a zero base selector to access shared memory between aoa and application
 00000AB5  66| 8E C0			mov	es, ax
 00000AB8  BB 00008600			mov	ebx, S_Base
 00000ABD  03 5D 08			add	ebx, index 
 00000AC0  26: 8B 03			mov	eax, DWORD PTR es:[ebx]
					; index is the index value in shared memory for a given variable 
					; eax has the data to be retunred 

 00000AC3  07				pop 	es
 00000AC4  5B				pop	ebx

					ret
 00000AC9			getsharedmemasm32 ENDP 	

 00000AC9			setsharedmemasm32 PROC C public uses ebx es, index: dword, val:dword
 00000ACE  53				push	ebx
 00000ACF  06				push	es 

 00000AD0  66| B8 00C0			mov	ax, MEMDataSel; This is a zero base selector to access shared memory between aoa and application
 00000AD4  66| 8E C0			mov	es, ax
 00000AD7  BB 00008600			mov	ebx, S_Base
 00000ADC  03 5D 08			add	ebx, index 
 00000ADF  8B 45 0C			mov	eax, val 
 00000AE2  26: 89 03			mov	DWORD PTR es:[ebx], eax
					; index is the index value in shared memory for a given variable 
					; eax has the data to be retunred 
					
 00000AE5  07				pop	es
 00000AE6  5B				pop	ebx

					ret
 00000AEB			setsharedmemasm32 ENDP 	


 00000AEB			stiTimerasm32 PROC C public 
 00000AEB  52				push	edx
 00000AEC  50				push	eax
 00000AED  66| BA 0021			mov	dx,21h ;enable timer interrupt 
 00000AF1  B0 00			mov	al,0h
 00000AF3  EE				out	dx,al
 00000AF4  66| BA 0020			mov	dx,20h
 00000AF8  B0 20			mov	al,20h
 00000AFA  EE				out	dx,al
 00000AFB  58				pop	eax	
 00000AFC  5A				pop	edx
 00000AFD  C3				ret
 00000AFE			stiTimerasm32 ENDP 	

 00000AFE			cleanscreenasm32 PROC C public

 00000AFE  CD F1			int	0f1h
				        ;--------trace Code----------------------
 00000B00  06				push	es
 00000B01  53				push	ebx
 00000B02  50				push	eax

 00000B03  66| B8 00C0			mov	ax, MEMDataSel
 00000B07  66| 8E C0			mov	es, ax
 00000B0A  BB 00008600			mov	ebx, S_Base
 00000B0F  83 C3 18			add	ebx, S_Error_Flag
 00000B12  26: 8B 03			mov	eax, DWORD PTR es:[ebx] ;get error flag
 00000B15  83 F8 00			cmp	eax, 0			; check if flag is zero 
 00000B18  75 10			jnz	skipupdate
 00000B1A  B8 00000108			mov	eax, 0108h
 00000B1F  BB 00008600			mov	ebx, S_Base
 00000B24  83 C3 20			add	ebx, S_IO_Function_Code
 00000B27  26: 89 03			mov	DWORD PTR es:[ebx], eax

 00000B2A			        skipupdate:
 00000B2A  58				pop	eax
 00000B2B  5B				pop	ebx
 00000B2C  07				pop	es
					;--------end trace code------------------

 00000B2D  C3				ret
 00000B2E			cleanscreenasm32 ENDP 	

 00000B2E			getcharasm32 PROC C public uses ebx, cursorp: dword  

						;int	0f5h  old, not used 
 00000B32  53					push	ebx
 00000B33  51					push	ecx
 00000B34  52					push	edx
 00000B35  56					push	esi
 00000B36  06					push	es
						
 00000B37  66| B8 0018				mov	ax, RDataSel  ;real data segment 
 00000B3B  66| 8E C0				mov	es, ax

 00000B3E  B8 00000308				mov	eax, GKKQ     ;char buffer 
 00000B43  8B F0				mov	esi, eax

 00000B45  33 C0				xor	eax, eax
						;int	0f2h get cursor is not used 
 00000B47  8B 45 08				mov	eax, cursorp  ; cursor position read before 
 00000B4A  66| 8B D0				mov	dx, ax
 00000B4D  66| 52				push	dx
 00000B4F  66| BB 0002				mov	bx, 2
 00000B53  66| F7 E3				mul	bx	
 00000B56  66| 5A				pop	dx
 00000B58  8B C8				mov	ecx, eax

 00000B5A			WaitChar:
 00000B5A  26: 8A 1D				mov	bl, BYTE PTR es:[GKHead]
	   00000407
 00000B61  26: 8A 3D				mov	bh, BYTE PTR es:[GKTail]
	   00000408
 00000B68  38 FB				cmp	bl, bh
 00000B6A  74 EE				je	WaitChar

 00000B6C  33 DB				xor	ebx, ebx
 00000B6E  26: 8A 1D				mov	bl, BYTE PTR es:[GKTail]
	   00000408
 00000B75  03 F3				add	esi, ebx 
 00000B77  26: 8A 06				mov	al, byte ptr es:[esi]

 00000B7A  80 FB FE				cmp	bl, 254 
 00000B7D  74 04				jz	RoundChar
 00000B7F  FE C3				inc	bl
 00000B81  EB 02				jmp	UpdateChar
 00000B83			RoundChar:
 00000B83  B3 00				mov	bl, 0
 00000B85			UpdateChar:
 00000B85  26: 88 1D				mov	BYTE PTR es:[GKTail], bl
	   00000408

 00000B8C  50					push	eax
 00000B8D  3C 0D				cmp 	al, 13
 00000B8F  74 02				jz	NDisp
 00000B91  8B D9				mov	ebx, ecx 
						;int	0f7h  ; echo the character in C code  
 00000B93			NDisp:
 00000B93  66| 42				inc	dx
 00000B95  66| 81 FA 07D0			cmp	dx, 2000   ; cursor check 
 00000B9A  7C 02				jl	CursorOK
						; int	0f0h       ; scroll is not done if cursor is not ok 
 00000B9C  EB 03				jmp	Charout
 00000B9E			CursorOK:
 00000B9E  66| 8B C2				mov	ax, dx
						; int	0f3h       ; incrementing is done in C code 
 00000BA1			Charout:

 00000BA1  58					pop	eax
						
 00000BA2  07					pop	es
 00000BA3  5E					pop 	esi
 00000BA4  5A					pop	edx
 00000BA5  59					pop	ecx
 00000BA6  5B					pop	ebx
					
					ret
 00000BAA			getcharasm32 ENDP 	

 00000BAA			printstrasm32 PROC C public uses ebx edi ecx, buffer:ptr byte, len:dword, base:dword
 00000BB0  53				push	ebx
 00000BB1  51				push	ecx
 00000BB2  57				push	edi
 00000BB3  16				push	ss
					
 00000BB4  8B 4D 0C			mov	ecx, len
 00000BB7  66| 0B C9			or	cx,cx
 00000BBA  74 1B			jz	exit
					
 00000BBC  8B 5D 10			mov	ebx, base
 00000BBF  8B 7D 08			mov	edi, buffer
					
 00000BC2  8B 5D 10			mov	ebx, base
 00000BC5  33 C0			xor	eax,eax
 00000BC7			PrintChar:
 00000BC7  36: 8A 07			mov	al, ss:[edi]	
 00000BCA  FA				cli
 00000BCB  CD F7			int	0f7h
 00000BCD  FB				sti
 00000BCE  83 C3 02			add	ebx,2
 00000BD1  49				dec	ecx
 00000BD2  47				inc	edi

 00000BD3  E3 02			jecxz	exit
 00000BD5  EB F0			jmp	PrintChar
 00000BD7			exit:	
 00000BD7  17				pop	ss
 00000BD8  5F				pop	edi
 00000BD9  59				pop	ecx
 00000BDA  5B				pop	ebx

					ret
 00000BE0			printstrasm32 ENDP 	

				;=========================================================================
				END
Microsoft (R) Macro Assembler Version 6.11		    03/25/16 11:30:03
asmfiles.asm						     Symbols 2 - 1




Types:

                N a m e                  Size     Attr

@proto_0 . . . . . . . . . . . .	 00000004     CODE 
@proto_10  . . . . . . . . . . .	 00000004     CODE 
@proto_11  . . . . . . . . . . .	 00000004     CODE 
@proto_12  . . . . . . . . . . .	 00000004     CODE 
@proto_13  . . . . . . . . . . .	 00000004     CODE 
@proto_14  . . . . . . . . . . .	 00000004     CODE 
@proto_15  . . . . . . . . . . .	 00000004     CODE 
@proto_16  . . . . . . . . . . .	 00000004     CODE 
@proto_17  . . . . . . . . . . .	 00000004     CODE 
@proto_18  . . . . . . . . . . .	 00000004     CODE 
@proto_19  . . . . . . . . . . .	 00000004     CODE 
@proto_1 . . . . . . . . . . . .	 00000004     CODE 
@proto_20  . . . . . . . . . . .	 00000004     CODE 
@proto_21  . . . . . . . . . . .	 00000004     CODE 
@proto_22  . . . . . . . . . . .	 00000004     CODE 
@proto_23  . . . . . . . . . . .	 00000004     CODE 
@proto_24  . . . . . . . . . . .	 00000004     CODE 
@proto_25  . . . . . . . . . . .	 00000004     CODE 
@proto_26  . . . . . . . . . . .	 00000004     CODE 
@proto_27  . . . . . . . . . . .	 00000004     CODE 
@proto_28  . . . . . . . . . . .	 00000004     CODE 
@proto_29  . . . . . . . . . . .	 00000004     CODE 
@proto_2 . . . . . . . . . . . .	 00000004     CODE 
@proto_30  . . . . . . . . . . .	 00000004     CODE 
@proto_31  . . . . . . . . . . .	 00000004     CODE 
@proto_32  . . . . . . . . . . .	 00000004     CODE 
@proto_3 . . . . . . . . . . . .	 00000004     CODE 
@proto_4 . . . . . . . . . . . .	 00000004     CODE 
@proto_5 . . . . . . . . . . . .	 00000004     CODE 
@proto_6 . . . . . . . . . . . .	 00000004     CODE 
@proto_7 . . . . . . . . . . . .	 00000004     CODE 
@proto_8 . . . . . . . . . . . .	 00000004     CODE 
@proto_9 . . . . . . . . . . . .	 00000004     CODE 


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	32 Bit	 00000000 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000BE0 DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

ShortDelay . . . . . . . . . . .	P Near	 000007F5 _TEXT	Length= 00000052 Public C
  Delay  . . . . . . . . . . . .	DWord	 bp + 00000008
  DELAYLOOP  . . . . . . . . . .	L Near	 0000080E _TEXT	
  skipupdate . . . . . . . . . .	L Near	 00000841 _TEXT	
ackPICCntlrasm32 . . . . . . . .	P Near	 000000FF _TEXT	Length= 00000044 Public C
  port . . . . . . . . . . . . .	Word	 bp + 00000008
  msk  . . . . . . . . . . . . .	Word	 bp + 0000000C
  skipupdate . . . . . . . . . .	L Near	 0000013C _TEXT	
cleanscreenasm32 . . . . . . . .	P Near	 00000AFE _TEXT	Length= 00000030 Public C
  skipupdate . . . . . . . . . .	L Near	 00000B2A _TEXT	
clearntflagasm32 . . . . . . . .	P Near	 00000343 _TEXT	Length= 00000011 Public C
cliTimerasm32  . . . . . . . . .	P Near	 00000201 _TEXT	Length= 0000000C Public C
cliasm32 . . . . . . . . . . . .	P Near	 00000066 _TEXT	Length= 00000007 Public C
ctiasm32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
disableIRQCntlrasm32 . . . . . .	P Near	 000000B6 _TEXT	Length= 00000049 Public C
  port . . . . . . . . . . . . .	Word	 bp + 00000008
  msk  . . . . . . . . . . . . .	Word	 bp + 0000000C
  skipupdate . . . . . . . . . .	L Near	 000000F8 _TEXT	
enableIRQCntlrasm32  . . . . . .	P Near	 0000006D _TEXT	Length= 00000049 Public C
  port . . . . . . . . . . . . .	Word	 bp + 00000008
  msk  . . . . . . . . . . . . .	Word	 bp + 0000000C
  skipupdate . . . . . . . . . .	L Near	 000000AF _TEXT	
fetchasm32 . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
freeasm32  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
getGDTEntryasm32 . . . . . . . .	P Near	 0000068F _TEXT	Length= 0000006C Public C
  descriptorh  . . . . . . . . .	DWord	 bp + 00000008
  descriptorl  . . . . . . . . .	DWord	 bp + 0000000C
  appno  . . . . . . . . . . . .	Word	 bp + 00000010
  skipupdate . . . . . . . . . .	L Near	 000006F4 _TEXT	
getIDTEntryasm32 . . . . . . . .	P Near	 000006FB _TEXT	Length= 0000007F Public C
  descriptorh  . . . . . . . . .	DWord	 bp + 00000008
  descriptorl  . . . . . . . . .	DWord	 bp + 0000000C
  appno  . . . . . . . . . . . .	Word	 bp + 00000010
  skipupdate . . . . . . . . . .	L Near	 00000772 _TEXT	
getTaskPtrasm32  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
getcharasm32 . . . . . . . . . .	P Near	 00000B2E _TEXT	Length= 0000007C Public C
  cursorp  . . . . . . . . . . .	DWord	 bp + 00000008
  WaitChar . . . . . . . . . . .	L Near	 00000B5A _TEXT	
  RoundChar  . . . . . . . . . .	L Near	 00000B83 _TEXT	
  UpdateChar . . . . . . . . . .	L Near	 00000B85 _TEXT	
  NDisp  . . . . . . . . . . . .	L Near	 00000B93 _TEXT	
  CursorOK . . . . . . . . . . .	L Near	 00000B9E _TEXT	
  Charout  . . . . . . . . . . .	L Near	 00000BA1 _TEXT	
getcharbuffasm32 . . . . . . . .	P Near	 000004E0 _TEXT	Length= 00000030 Public C
  skipupdate . . . . . . . . . .	L Near	 0000050C _TEXT	
getcharintasm32  . . . . . . . .	P Near	 000004D9 _TEXT	Length= 00000007 Public C
getcursorasm32 . . . . . . . . .	P Near	 0000025B _TEXT	Length= 00000025 Public C
getdecasm32  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
getmemasm32  . . . . . . . . . .	P Near	 00000468 _TEXT	Length= 0000001F Public C
  address  . . . . . . . . . . .	DWord	 bp + 00000008
getrealmemory  . . . . . . . . .	P Near	 000004A9 _TEXT	Length= 0000001F Public C
  address  . . . . . . . . . . .	DWord	 bp + 00000008
getsharedmemasm32  . . . . . . .	P Near	 00000AAA _TEXT	Length= 0000001F Public C
  index  . . . . . . . . . . . .	DWord	 bp + 00000008
getsharedmemcharasm32  . . . . .	P Near	 00000448 _TEXT	Length= 00000020 Public C
  index  . . . . . . . . . . . .	DWord	 bp + 00000008
  base1  . . . . . . . . . . . .	DWord	 bp + 0000000C
getstackpopasm32 . . . . . . . .	P Near	 000004C8 _TEXT	Length= 00000011 Public C
  index  . . . . . . . . . . . .	DWord	 bp + 00000008
getstrasm32  . . . . . . . . . .	P Near	 0000020D _TEXT	Length= 0000004E Public C
  buffer . . . . . . . . . . . .	DWord	 bp + 00000008
  GetChar  . . . . . . . . . . .	L Near	 0000021A _TEXT	
  Exit . . . . . . . . . . . . .	L Near	 00000227 _TEXT	
  skipupdate . . . . . . . . . .	L Near	 00000253 _TEXT	
gettimerasm32  . . . . . . . . .	P Near	 00000280 _TEXT	Length= 00000044 Public C
  skipupdate . . . . . . . . . .	L Near	 000002BE _TEXT	
initschedulerasm32 . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
inittimerasm32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
inttimerasm32  . . . . . . . . .	P Near	 000001B3 _TEXT	Length= 00000030 Public C
  skipupdate . . . . . . . . . .	L Near	 000001DD _TEXT	
intttimerasm32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
mallocasm32  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
printchar32  . . . . . . . . . .	P Near	 00000A6B _TEXT	Length= 0000001A Public C
printcharasm32 . . . . . . . . .	P Near	 00000320 _TEXT	Length= 00000023 Public C
  value  . . . . . . . . . . . .	Byte	 bp + 00000008
  pos  . . . . . . . . . . . . .	DWord	 bp + 0000000C
printflagsasm32  . . . . . . . .	P Near	 00000354 _TEXT	Length= 0000003D Public C
  base . . . . . . . . . . . . .	DWord	 bp + 00000008
  skipupdate . . . . . . . . . .	L Near	 0000038A _TEXT	
printhexasm32  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
printhex . . . . . . . . . . . .	P Far	 00000A85 _TEXT	Length= 00000025 Public C
  PutHexLoopP  . . . . . . . . .	L Near	 00000A95 _TEXT	
printregsasm32 . . . . . . . . .	P Near	 00000847 _TEXT	Length= 00000201 Public C
  pos  . . . . . . . . . . . . .	DWord	 bp + 00000008
printstackregsasm32  . . . . . .	P Near	 00000A48 _TEXT	Length= 00000023 Public C
  pos  . . . . . . . . . . . . .	DWord	 bp + 00000008
printstrasm32  . . . . . . . . .	P Near	 00000BAA _TEXT	Length= 00000036 Public C
  buffer . . . . . . . . . . . .	DWord	 bp + 00000008
  len  . . . . . . . . . . . . .	DWord	 bp + 0000000C
  base . . . . . . . . . . . . .	DWord	 bp + 00000010
  PrintChar  . . . . . . . . . .	L Near	 00000BC7 _TEXT	
  exit . . . . . . . . . . . . .	L Near	 00000BD7 _TEXT	
readdateasm32  . . . . . . . . .	P Near	 0000017B _TEXT	Length= 00000022 Public C
readfloppyasm32  . . . . . . . .	P Near	 00000510 _TEXT	Length= 0000008D Public C
  buffer1  . . . . . . . . . . .	DWord	 bp + 00000008
  sectorno . . . . . . . . . . .	DWord	 bp + 0000000C
  movonesector1  . . . . . . . .	L Near	 00000558 _TEXT	
  skipupdate . . . . . . . . . .	L Near	 00000595 _TEXT	
readintmaskregisterasm32 . . . .	P Near	 0000019D _TEXT	Length= 00000016 Public C
  port . . . . . . . . . . . . .	Word	 bp + 00000008
readintstatusregisterasm32 . . .	P Near	 00000143 _TEXT	Length= 00000016 Public C
  port . . . . . . . . . . . . .	Word	 bp + 00000008
readrtcasm32 . . . . . . . . . .	P Near	 00000159 _TEXT	Length= 00000022 Public C
resetlockasm32 . . . . . . . . .	P Near	 00000391 _TEXT	Length= 0000004B Public C
  shlock . . . . . . . . . . . .	DWord	 bp + 00000008
  tid  . . . . . . . . . . . . .	DWord	 bp + 0000000C
  itisnotlocked  . . . . . . . .	L Near	 000003D3 _TEXT	
scrollasm32  . . . . . . . . . .	P Near	 000002F0 _TEXT	Length= 00000030 Public C
  skipupdate . . . . . . . . . .	L Near	 0000031C _TEXT	
setGDTEntryasm32 . . . . . . . .	P Near	 00000624 _TEXT	Length= 0000006B Public C
  descriptorh  . . . . . . . . .	DWord	 bp + 00000008
  descriptorl  . . . . . . . . .	DWord	 bp + 0000000C
  appno  . . . . . . . . . . . .	Word	 bp + 00000010
  skipupdate . . . . . . . . . .	L Near	 00000688 _TEXT	
setIDTEntryasm32 . . . . . . . .	P Near	 0000077A _TEXT	Length= 0000007B Public C
  descriptorh  . . . . . . . . .	DWord	 bp + 00000008
  descriptorl  . . . . . . . . .	DWord	 bp + 0000000C
  appno  . . . . . . . . . . . .	Word	 bp + 00000010
  skipupdate . . . . . . . . . .	L Near	 000007ED _TEXT	
setcursorasm32 . . . . . . . . .	P Near	 000002C4 _TEXT	Length= 0000002C Public C
  pos  . . . . . . . . . . . . .	DWord	 bp + 00000008
setmemasm32  . . . . . . . . . .	P Near	 00000487 _TEXT	Length= 00000022 Public C
  address  . . . . . . . . . . .	DWord	 bp + 00000008
  data . . . . . . . . . . . . .	DWord	 bp + 0000000C
setsharedmemasm32  . . . . . . .	P Near	 00000AC9 _TEXT	Length= 00000022 Public C
  index  . . . . . . . . . . . .	DWord	 bp + 00000008
  val  . . . . . . . . . . . . .	DWord	 bp + 0000000C
setsharedmemcharasm32  . . . . .	P Near	 00000423 _TEXT	Length= 00000025 Public C
  index  . . . . . . . . . . . .	DWord	 bp + 00000008
  char1  . . . . . . . . . . . .	Byte	 bp + 0000000C
  base1  . . . . . . . . . . . .	DWord	 bp + 00000010
stiTimerasm32  . . . . . . . . .	P Near	 00000AEB _TEXT	Length= 00000013 Public C
stiasm32 . . . . . . . . . . . .	P Near	 000001E3 _TEXT	Length= 0000001E Public C
  itisset  . . . . . . . . . . .	L Near	 000001FF _TEXT	
testandsetasm32  . . . . . . . .	P Near	 000003DC _TEXT	Length= 00000047 Public C
  shlock . . . . . . . . . . . .	DWord	 bp + 00000008
  tid  . . . . . . . . . . . . .	DWord	 bp + 0000000C
  itislocked . . . . . . . . . .	L Near	 0000041C _TEXT	
testasm32  . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000066 Public C
  Delay  . . . . . . . . . . . .	DWord	 bp + 00000008
  DELAYLOOP  . . . . . . . . . .	L Near	 00000030 _TEXT	
  skipupdate . . . . . . . . . .	L Near	 0000005F _TEXT	
writefloppyasm32 . . . . . . . .	P Near	 0000059D _TEXT	Length= 00000087 Public C
  buffer1  . . . . . . . . . . .	DWord	 bp + 00000008
  sectorno . . . . . . . . . . .	DWord	 bp + 0000000C
  movuserto8400  . . . . . . . .	L Near	 000005DC _TEXT	
  skipupdate . . . . . . . . . .	L Near	 0000061C _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000001h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
AppGDTPtr  . . . . . . . . . . .	Number	 000001BDh   
D_ADDROFFSET . . . . . . . . . .	Number	 00000011h   
GKHead . . . . . . . . . . . . .	Number	 00000407h   
GKKQ . . . . . . . . . . . . . .	Number	 00000308h   
GKTail . . . . . . . . . . . . .	Number	 00000408h   
GlobalDataSel  . . . . . . . . .	Number	 000000B8h   
MEMDataSel . . . . . . . . . . .	Number	 000000C0h   
NoOfCycles_Delay . . . . . . . .	Number	 00000005h   
Processor_Speed  . . . . . . . .	Number	 00000163h   
Puthex32DataSel  . . . . . . . .	Number	 00000090h   
RDataSel . . . . . . . . . . . .	Number	 00000018h   
S_APP_String . . . . . . . . . .	Number	 00000024h   
S_Base . . . . . . . . . . . . .	Number	 00008600h   
S_CIRLISTSTATE . . . . . . . . .	Number	 00000080h   
S_Clock_Hz . . . . . . . . . . .	Number	 00000014h   
S_Cycle_Count  . . . . . . . . .	Number	 00000010h   
S_DATE . . . . . . . . . . . . .	Number	 00000124h   
S_DPD_Count  . . . . . . . . . .	Number	 000000A8h   
S_DUMMY  . . . . . . . . . . . .	Number	 00000094h   
S_EINIT_RET  . . . . . . . . . .	Number	 000000A0h   
S_ERR  . . . . . . . . . . . . .	Number	 00000128h   
S_Error_Code . . . . . . . . . .	Number	 0000001Ch   
S_Error_Flag . . . . . . . . . .	Number	 00000018h   
S_IDTOffset  . . . . . . . . . .	Number	 0000000Ch   
S_IOBASE . . . . . . . . . . . .	Number	 0000009Ch   
S_IO_Function_Code . . . . . . .	Number	 00000020h   
S_ISRCount . . . . . . . . . . .	Number	 0000008Ch   
S_ISRSTIFlag . . . . . . . . . .	Number	 00000090h   
S_ITCP_ARP_Count . . . . . . . .	Number	 00000118h   
S_ITCP_DAT_Count . . . . . . . .	Number	 0000010Ch   
S_ITCP_FACK_Count  . . . . . . .	Number	 00000110h   
S_ITCP_GACK_Count  . . . . . . .	Number	 00000104h   
S_ITCP_HDR_Count . . . . . . . .	Number	 00000108h   
S_ITCP_PRIOR_Count . . . . . . .	Number	 0000011Ch   
S_ITCP_RESET_Count . . . . . . .	Number	 00000114h   
S_ITCP_SACK_Count  . . . . . . .	Number	 00000100h   
S_InCount  . . . . . . . . . . .	Number	 00000070h   
S_InRecord . . . . . . . . . . .	Number	 00000084h   
S_LSError  . . . . . . . . . . .	Number	 00000140h   
S_Lock1  . . . . . . . . . . . .	Number	 0000004Ch   
S_Lock2  . . . . . . . . . . . .	Number	 00000050h   
S_Lock3  . . . . . . . . . . . .	Number	 00000054h   
S_Lock4  . . . . . . . . . . . .	Number	 00000058h   
S_NTFLAG . . . . . . . . . . . .	Number	 0000007Ch   
S_OutCount . . . . . . . . . . .	Number	 00000074h   
S_OutRecord  . . . . . . . . . .	Number	 00000088h   
S_PID  . . . . . . . . . . . . .	Number	 00000078h   
S_RTCFLAG  . . . . . . . . . . .	Number	 00000130h   
S_RTC  . . . . . . . . . . . . .	Number	 00000120h   
S_SectorNo . . . . . . . . . . .	Number	 00000004h   
S_Suspend_Command  . . . . . . .	Number	 000000ACh   
S_Suspend_Delay  . . . . . . . .	Number	 000000B0h   
S_TCP_ARP_Count  . . . . . . . .	Number	 000000D0h   
S_TCP_DAT_Count  . . . . . . . .	Number	 000000C4h   
S_TCP_FACK_Count . . . . . . . .	Number	 000000C8h   
S_TCP_GACK_Count . . . . . . . .	Number	 000000BCh   
S_TCP_HDR_Count  . . . . . . . .	Number	 000000C0h   
S_TCP_RESET_Count  . . . . . . .	Number	 000000CCh   
S_TCP_SACK_Count . . . . . . . .	Number	 000000B8h   
S_TCP_Tx_Count . . . . . . . . .	Number	 000000B4h   
S_TID1 . . . . . . . . . . . . .	Number	 0000005Ch   
S_TID2 . . . . . . . . . . . . .	Number	 00000060h   
S_TID3 . . . . . . . . . . . . .	Number	 00000064h   
S_TID4 . . . . . . . . . . . . .	Number	 00000068h   
S_Timer  . . . . . . . . . . . .	Number	 00000000h   
S_Total_Tx_Count . . . . . . . .	Number	 000000A4h   
S_Trace  . . . . . . . . . . . .	Number	 00000160h   
StackSel . . . . . . . . . . . .	Number	 0000000Ch   
StoreCharOffset  . . . . . . . .	Number	 0000000Bh   
StoreDecOffset . . . . . . . . .	Number	 0000000Ch   
Timer  . . . . . . . . . . . . .	Number	 0000020Dh   
Video_Sel_Loc  . . . . . . . . .	Number	 00000010h   

	   0 Warnings
	   0 Errors
