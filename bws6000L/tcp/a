
#include "tcpobj.h"
#include "..\ip\rand.h"
#include "..\webserver\apptask.h"
#include "..\Ethernet\EtherObj.h"
#include "..\interfaces\aoaprotected.h"
//***********************************************************************************************
// Static Variable Definitions

// Variables used to Addess the Host
char TCPObj::HostIP[4];					// Specifies the host IP Address
char TCPObj::HostSubnetMask[4];				// Specifies the Hosts Subnet Mask
char TCPObj::GateWayIP[6];				// Specifies the GateWays IP Address
char TCPObj::GateWayMAC[6];				// Specifies the Gateways MAC Address
unsigned short TCPObj::SourcePort = 80;			// Port Number of the HTTP TO listen u can change the port 

// Variables used to Track the TCP Buffer
unsigned long TCPObj::TCBBase = 0;			// Base of TCB Table
long TCPObj::FreeList =0;				// pointer to the Free TCB Linked List 
long TCPObj::TimeWaitList =0;				// Pointer to the List of TCB's in the Time Wait State 
long TCPObj::LastTimeWaitList=0;			// Pointer to the Last Record in the Time Wait List 
long TCPObj::TCBRecords=0;				// Denotes the total number of TCB Records both used and free 
int TCPObj::SendCountPtr=0;				// Send Count Ptr for debug  
							// and in time wait list  
long TCPObj::waitRtt=0;							
//RKK change the following value to change the pkt size 
const int TCPSegSize = 1460;				
// The Maximum amount of Data that could be accomodated in a 
							// single 
//----------------------
// eth   ip   tcp   data
// ---------------------
// 14    20    20   1460 
//      <--------------->
//            1500 
unsigned long TCPObj::noHttpR = 0;			// number of incomming HTTP Requests
unsigned long TCPObj::noHttpRs = 0;			// number of HTTP Requests Served
unsigned long TCPObj::noconnreq = 0;			// number of connection requested
unsigned long TCPObj::noconnestab = 0;			// number of connection established 
unsigned long TCPObj::noconncurr = 0;			// Number of open connections at present 
unsigned long TCPObj::averageconntime = 0;		// Average time of a connection from the starting to end
							// untill the TCB is made free

// Function Definitions begins here
//*******************************************************************************************
// This is the init function this function must be called only once in a Application
// The input parameters: are the IP Address of the HOST, Port number of the HOST Application, GateWay IP, GatewayMac of the Host, 
// Base address of the TCP Buffer, Size of the TCP Buffer, Count of number of Entries in the Connection Request Queue, 
// Count of Number of entries in the connection Established Queue, Count of number of entries in the Connection close queue
// Return Values:
//  0 - if initialized successfully
// -1 if the TCP Buffer Space is not sufficient 
int TCPObj::init(char SrcIP[4], char SourceMAC[6],char SubnetMask[4], char GwayIP[4],char GwayMAC[6], unsigned short SrcPort, long TCPBuffBase, long TCBBufferSize, long NoTCBRecords, long NoHashRecords)
{
	long hashSize=0;
	TCPBuffBase = TCPBuffBase - ADDR_OFFSET;
	hashSize = t.init(NoHashRecords, TCPBuffBase);		
	io.AOAprintHex(sizeof(TCBRecord), Line10+20);

	// Check for the size of availablable memory space for the table and return error if it is not enough
	TCBRecords = NoTCBRecords;
	if(TCBBufferSize < (hashSize+(NoTCBRecords*sizeof(TCBRecord))))
	{
	    return -1;
	}
	
    	for(int i=0;i<4;i++)
	{
	    	HostIP[i] = SrcIP[i];			// Assign the Source IP
		GateWayIP[i] = GwayIP[i]; 		// Assign the Gateway IP
		HostSubnetMask[i] = SubnetMask[i]; 	// Assign the Host Subnet Mask
	}
	
	
	for(i =0; i< 6 ;i++)
	{
	 	GateWayMAC[i] = GwayMAC[i];
	}
	
	
	// Initialize the source port	
	SourcePort = SrcPort;			



	// Initialize the base address of the TCP Memory Space 
	TCBBase = TCPBuffBase + hashSize;	
	
	
	// Initialise the TCB Table
	TCBRecord *TCBPointer = (TCBRecord*)TCBBase;
		
	for(i =0; i<NoTCBRecords;i++)
	{
	    	if(i==0)
		{
		    	TCBPointer[i].Avail =0;
			TCBPointer[i].prev = -1;
			TCBPointer[i].next = i+1;
			FreeList = 0;
		}
		else if(i==(NoTCBRecords-1))
		{
			TCBPointer[i].Avail =0;
			TCBPointer[i].prev = i-1;
			TCBPointer[i].next = -1;
		}
		else
		{
			TCBPointer[i].Avail =0;
			TCBPointer[i].prev = i-1;
			TCBPointer[i].next = i+1;
		}
		TCBPointer[i].state = CLOSED;
		TCBPointer[i].noAckSent = 0;
		TCBPointer[i].noFinSent = 0;
		TCBPointer[i].noDataSent = 0;
		TCBPointer[i].noSynSent = 0;
		TCBPointer[i].noHttpHeaderSent = 0;
	}

	TimeWaitList =-1;
	LastTimeWaitList = -1;
	random r = random(io.AOAgetTimer());	
	return 0;
}
//************************************************************************************************
// These are functions to manipulate the TCB Data Structure
// Insert a row in TCB
// It returns the Record Number if Successful
// It Returns -1 if the The TCB Table is full
 	
int TCPObj::InsertTCB(TCBRecord *tcb)
{
   TCBRecord *TCBPointer, *FreeTCB;
   TCBPointer = (TCBRecord*)TCBBase;
   long FreeTCBIndex=0; 
   int hashvalue=0;
   long hashIndexVal=0;

   // if TCB table is full
   if(FreeList == -1)
   {
       return -1;
   }

   // Get the address of the free tcb record at the head of the FreeList
   FreeTCB = &TCBPointer[FreeList];
   // Assign the index of the free TCB to return the 
   FreeTCBIndex = FreeList;
   //Update the head of free list to the next free record
   FreeList = FreeTCB->next;
   // Update teh Avail bit to 1
   FreeTCB->Avail = 1; 
   // Update the previous pointer of the free list to -1
   if(FreeList != -1)
   {
   TCBPointer[FreeList].prev = -1;
   }

   // Destinsiton Port Number
   FreeTCB->PORT[0] = tcb->PORT[0];
   FreeTCB->PORT[1] = tcb->PORT[1];	
   // Destination IP Address
   for(int j=0;j<4;j++)
   {
      FreeTCB->IP[j] = tcb->IP[j];
   }

   for( j=0; j<6;j++)
   {
      FreeTCB->destmac[j] = tcb->destmac[j];
   }

   // The State of the connection
   FreeTCB->state = tcb->state;
   // Last Unacknowledged Sequence number
   FreeTCB->SNDUNA = tcb->SNDUNA;
   // Next Send Sequence number
   FreeTCB->SNDNXT = tcb->SNDNXT;	
   // Sender Window size available
   FreeTCB->SNDWND =tcb->SNDWND;	
   // Segment Sequence of last window update
   FreeTCB->SNDWL1 = tcb->SNDWL1;
   // Segment sequence of last acknowledged segment
   FreeTCB->SNDWL2 = tcb->SNDWL2;
   // Initial Send Sequence Number
   FreeTCB->ISS = tcb->ISS;
   // Next Sequence number to acceot by the receiver
   FreeTCB->RCVNXT=tcb->RCVNXT;
   // Window size of the receiver
   FreeTCB->RCVWND=tcb->RCVWND;
   // Initial receive Sequence number
   FreeTCB->IRS = tcb->IRS;
   // Sender Round Trip Time
   FreeTCB->SRTT = tcb->SRTT;
   // Last packet sent time 
   FreeTCB->LST = tcb->LST; 
   // Last Packet Sent Timer or in case of a connection establishment its the SYNC Received Time
   FreeTCB->CURRENTRTT = tcb->CURRENTRTT;
   FreeTCB->DIFF = tcb->DIFF;

   FreeTCB->SEQ = tcb->SEQ;
   
   hashvalue = t.hashfun(FreeTCB->IP, FreeTCB->PORT);
   hashIndexVal = t.getIndex(hashvalue);  
   if(hashIndexVal == -1)
   {
       FreeTCB->next = -1;
       FreeTCB->prev = -1; 
       t.setIndex(hashvalue,FreeTCBIndex);
   }
   else
   {
       FreeTCB->prev=-1;
       FreeTCB->next = hashIndexVal;
       TCBPointer[hashIndexVal].prev = FreeTCBIndex;
       t.setIndex(hashvalue,FreeTCBIndex);
   }
   
   return FreeTCBIndex;
}
//****************************************************************************
// Delete a Row in TCB
int TCPObj::DeleteTCB(int TCBRecordNum)
{
   TCBRecord *TCBPointer;
   TCBPointer = (TCBRecord*)TCBBase;   
   long prev;
   long next;
   long hashValue =0;
   
   if(TCBPointer[TCBRecordNum].state == CLOSED)
   {
       return 0;
   }
   if(TCBPointer[TCBRecordNum].state == TIMEWAIT)
   {
       return 0;
   }
   averageconntime = ((averageconntime + ((unsigned long)io.AOAgetTimer() - TCBPointer[TCBRecordNum].connstarttime)));  
   noconncurr--; 
   TCBPointer[TCBRecordNum].state = CLOSED; 	
   TCBPointer[TCBRecordNum].Avail = 0;
   TCBPointer[TCBRecordNum].SendFlag = 0; 
   prev = TCBPointer[TCBRecordNum].prev;
   next = TCBPointer[TCBRecordNum].next;
   hashValue = t.hashfun(TCBPointer[TCBRecordNum].IP,TCBPointer[TCBRecordNum].PORT); 	

   if(next == -1 && prev ==-1)
   {
       // update the hash ndex to -1
       t.setIndex(hashValue, -1);
   }
   if(next == -1 && prev >-1)
   {
      // Update the free list
      TCBPointer[prev].next =-1;
   } 
   if(next > -1 && prev == -1)
   {
       // update the free list
       t.setIndex(hashValue, next);	
       TCBPointer[next].prev=-1;
       
   }  
   if(next > -1 && prev > -1)
   {
       TCBPointer[next].prev=prev;
       TCBPointer[prev].next=next; 
   } 
   if(FreeList != -1)
   {
   TCBPointer[FreeList].prev = TCBRecordNum;
   TCBPointer[TCBRecordNum].next = FreeList; 
   }
   else
   {
   TCBPointer[TCBRecordNum].next = -1;  
   }
   TCBPointer[TCBRecordNum].prev =-1;
   FreeList = TCBRecordNum;
  
   return 0;
}

//***********************************************************************************************************
// Get a Row in TCB
int TCPObj::GetTCB(int TCBRecordNum, long *tcb)
{
   TCBRecord *TCBPointer, tcbrecord;
   TCBPointer = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) ));
	
   if(TCBPointer->Avail == 1) 
   {
       *tcb = (long)TCBPointer;	
       return 0;
   }
   return -1;
}
//**********************************************************************************************************
// This function does a modulo 32 comparision
// z Totaal Receive Window Size
// x is the value which is assumed to be greater
// y is the value whic is assumed to be small 
// Returns 0 if the values are equal
// Returns > 0 if x is > y i.e. x-y
// Returns a value -1 if y is less than x
int TCPObj::greaterEqualto(unsigned long x,unsigned long y,unsigned long z)
{
	// Denotes the lower bound of long
	unsigned long Start = 0;

	// Denotes the upper bound of long 
	unsigned long End = 0xFFFFFFFF;
	
	if(x == y)
	{
		return 0;
	}
	else if(x > y)
	{
		if((x - y) > z)
		{
			return -1;
		}
		else if((x-y) <= z)
		{
			return (x-y);
		}
	}
	else if(x < y)
	{
	        
		if( ( (x-Start) + (End-y) ) > z)
		{
			return -1;
		}
		else
		{
			return (x-Start) + (End-y) + 1;
		}
	}
	return -1;

}
//*************************************************************************************************
// TCPHandler
//*************************************************************************************************
// Returns -17 if the packet is less than minimum length
// Returns -18 if the packet is not for HTTP Port
// Returns -19 if the packet does not have correct checksum
// Returns -20 if Retrieving TCB Record Failed
int TCPObj::TCPHandler(char* TCPPack,int size,char* SourceIP, char* TargetIP,
		       int Protocol, char *macaddr, int currenttask)
{
char chsum1[2];
char chsum2[2];
int checksum=0;
char SrcPortNum[2];
long TCBRecordNum;
int retcode=0;
// TCPHeader is 20 bytes
// tcp is one header, statically declared
char Header[sizeof(TCPHeader)];
TCPHeader *tcp;
tcp = (TCPHeader*)Header;

// check the size if the size is less than the minimum header size return error
if(size < MIN_TSLength)
{
    return -17;
}

// Check the destination port of the packet to be the HTTP Port if so accept it or discard it
if(TCPPack[2] != HTTPPort_H || TCPPack[3] != HTTPPort_L)
{
    return -18;
}

// get the checksum from the packet
chsum1[0] = TCPPack[16];
chsum1[1] = TCPPack[17];

//calculate the checksum of the packet
checksum = TCPChecksum(TCPPack, size, SourceIP, TargetIP, Protocol);

chsum2[0] =(char)((checksum>>8) & 0xFF);
chsum2[1] =(char)(checksum & 0xFF);	

//compare checksum in packet and calculated checksum
if(chsum1[0] != chsum2[0] || chsum1[1] != chsum2[1])
{
    return -19;
}

// Check if a TCB Record is already available
SrcPortNum[0]= TCPPack[0];
SrcPortNum[1]= TCPPack[1];

// format tcp header
FormatHeader(Header, TCPPack);

// search tcb
TCBRecordNum = SearchTCB(SourceIP,SrcPortNum);

TCBRecord *tcb;
tcb=(TCBRecord*)(TCBBase + (TCBRecordNum * sizeof(TCBRecord) ));

//  io.AOAprintHex(tcb->noSynSent, Line22);
//  io.AOAprintHex(tcb->noHttpHeaderSent, Line22+20);
//  io.AOAprintHex(tcb->noAckSent, Line22+40);
//  io.AOAprintHex(tcb->noFinSent, Line22+60);
//  io.AOAprintHex(tcb->noDataSent, Line22+80);

// Check if TCB Record is available
if(TCBRecordNum == -1)
{
  tcb->noSynSent = 0;
  tcb->noHttpHeaderSent = 0;
  tcb->noAckSent = 0;
  tcb->noFinSent = 0;
  tcb->noDataSent = 0;
	////io.AOAprintCharacter('!', Line19);
   	// IF the TCB dosent Exist It is assumed to be in Listen State or it is in closed state 
	retcode = ListenHandler(TCPPack, size, tcp, SourceIP, TargetIP, TCBRecordNum, macaddr, currenttask);
	return retcode;			
}
else
{
	////io.AOAprintCharacter('@', Line19+4);
	// Get the TCB record if available
	if(GetTCB(TCBRecordNum,(long*)&tcb)!=0)
	{
	 	return -20;   
	}

	retcode = OtherHandler(TCPPack, size, tcb, tcp, SourceIP, TargetIP, TCBRecordNum, currenttask);
	return retcode;
}

return 0;	
}

//************************************************************************************************
int TCPObj::ListenHandler(char* TCPPack,int size, TCPHeader *tcp, char* SourceIP, char* TargetIP,
			int TCBRecordNumber, char *macaddr, int currenttask)
{
	//RKK Buffer Definitions 
	AOATask task;
	EtherObj EO;

	char SrcPortNum[2];
	unsigned long seqnum; 
	char options[10];
	char data[10];
	char TargetMAC[6];
	int status;
	TCBRecord temptcb;
	int retcode = 0;
	int currtime = 0;
	
      	// In this case the TCB Dosenot Exist so assume the state of that connection is in LISTEN State

        // 1. Check for TSYN.
        if( (TCPPack[13] & TSYN) == TSYN)
        {
		//io.AOAprintCharacter('a', Line20);

		// IF the packet is a syn packet
		temptcb.Avail = 1;
		
		// Error Check these things Here
		temptcb.PORT[0] = TCPPack[0];
		temptcb.PORT[1] = TCPPack[1]; 
		temptcb.IP[0] = SourceIP[0]; 	
		temptcb.IP[1] = SourceIP[1]; 		
		temptcb.IP[2] = SourceIP[2]; 		
		temptcb.IP[3] = SourceIP[3]; 			

		// macaddr is passed from EtherObj
		temptcb.destmac[0] = macaddr[0];
		temptcb.destmac[1] = macaddr[1];
		temptcb.destmac[2] = macaddr[2];
		temptcb.destmac[3] = macaddr[3];
		temptcb.destmac[4] = macaddr[4];
		temptcb.destmac[5] = macaddr[5];

		temptcb.state	= SYNRCVD;
		temptcb.connstarttime = io.AOAgetTimer();
		noconnreq++;
		random r = random(io.AOAgetTimer());	
		temptcb.ISS	= r.getRandomAoA(io.AOAgetTimer());	  
		temptcb.SNDUNA	= temptcb.ISS;
		temptcb.SNDNXT  = temptcb.SNDUNA + 1;   
		
		temptcb.SNDWND 	= charToWindow(&TCPPack[14]);
		temptcb.SEQ = 0;

		// Error: Check These Two Statements
		temptcb.SNDWL1	= 0;
		temptcb.SNDWL2 	= 0xFFFFFFFF;
	
		temptcb.IRS	= charToseqnum(&TCPPack[4]); 
	
		temptcb.RCVNXT  = temptcb.IRS + 1;
		temptcb.RCVWND  = MAXTCPDATASIZE; 
		temptcb.SRTT 	= 0;
		temptcb.LST 	= io.AOAgetTimer();
		temptcb.SendFlag=0;
		temptcb.DIFF=0;

		// Insert Record into TCB
		status = InsertTCB(&temptcb);

		// IF TCB table is full
		if(status == -1)
		{
			//io.AOAprintCharacter('b', Line20+4);
			SrcPortNum[0]= HTTPPort_H;
	 		SrcPortNum[1]= HTTPPort_L; 
	 	 	seqnum = 0x00;
			seqnum = charToseqnum(&TCPPack[4]);
			
	  		retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TRST,MAXTCPSEGSIZE,
					    seqnum,0, options, 0, data, 0, macaddr, currenttask);
             	    	return retcode;
		}		
		else
		{
			//io.AOAprintCharacter('c', Line20+8);
	 	
			//Send SYN ACK Back
			SrcPortNum[0]= HTTPPort_H;
			SrcPortNum[1]= HTTPPort_L; 	

			retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TSYN|TACK, MAXTCPSEGSIZE,
				       temptcb.ISS,temptcb.RCVNXT, options, 0, data, 0, temptcb.destmac, currenttask);

			return retcode;
	        }
	  }// End of SYN 

        // 2. Check for TACK
      	if((TCPPack[13] & TACK) == TACK) 
      	{
	  //io.AOAprintCharacter('d', Line20+12);
	  // Why TRST Here   
	  // check if it is an acknowledgement if so send a reset	
	  SrcPortNum[0]= HTTPPort_H;
	  SrcPortNum[1]= HTTPPort_L; 
	  seqnum = 0x00;
	  seqnum = charToseqnum(&TCPPack[8]);

	  io.AOAPrintText("TCPObj:ListenHandler 2. check for tack", Line20);
	  retcode = SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TRST, MAXTCPSEGSIZE, 
			     seqnum,0, options, 0, data, 0, macaddr, currenttask);

          return retcode;
        }
	
      return 0; 
}
//********************************************************************************************************
// OtherHandler 
//********************************************************************************************************
int TCPObj::OtherHandler(char* TCPPack,int size, TCBRecord *tcb, TCPHeader *tcp, 
			char* SourceIP, char* TargetIP,int TCBRecordNumber, int currenttask)
{
    //RKK Buffer Definitions 
    AOATask task;
    apptask tsk;
    EtherObj EO; 
    int retcode=0;
    char SrcPortNum[2];
    char options[10];
    char data[10];
    char TargetMAC[6]; 	
    int Acceptable_Flag = 0;
    int tempretcode=0;
    long timer;
    int currtime = 0;

    // 1. Check if the sequence number is acceptable or not 
    // Acceptability Test Case1
    if(((size - (tcp->Dataoffset*4)) == 0) && (tcb->RCVWND == 0))
    {
        if(tcp->seqnumber == tcb->RCVNXT)
        {
     	   Acceptable_Flag =1;
	}
    }

    // Acceptability Test Case 2
    if((((tcp->Dataoffset*4)- size) == 0) && (tcb->RCVWND > 0))
    {
        if((greaterEqualto(tcp->seqnumber, tcb->RCVNXT, MAXTCPDATASIZE) >= 0) && 
           (greaterEqualto((tcb->RCVNXT+tcb->RCVWND),tcp->seqnumber, MAXTCPDATASIZE) > 0))
        {
    	   Acceptable_Flag =1;
	}
    }

    // Acceptability Test Case 3	
    if(((size - (tcp->Dataoffset*4)) > 0 )&& (tcb->RCVWND == 0))	
    {
        Acceptable_Flag = 0;
    }
		
    // Acceptability Test Case 4
    if(((size - (tcp->Dataoffset*4))) > 0 && (tcb->RCVWND > 0))
    {
        if(((greaterEqualto(tcp->seqnumber, tcb->RCVNXT, MAXTCPDATASIZE) >= 0) && 
	    (greaterEqualto((tcb->RCVNXT + tcb->RCVWND), tcp->seqnumber, MAXTCPDATASIZE) > 0)) || 
	    ((greaterEqualto(( tcp->seqnumber + ( size - ( tcp->Dataoffset * 4 ) - 1) ), 
	     tcb->RCVNXT, MAXTCPDATASIZE) >= 0) && (greaterEqualto((tcb->RCVNXT + tcb->RCVWND), 
	     ( tcp->seqnumber + ( size - ( tcp->Dataoffset * 4 ) - 1) ), MAXTCPDATASIZE) > 0)))
	{
	   Acceptable_Flag =1;	
        }
    }
	
    // If the Incomming segment is not acceptable 
    if(Acceptable_Flag == 0)
    {	
	    //io.AOAprintCharacter('e', Line20+16);
	    if((tcp->Flags & TRST) == TRST)
	    {
		//io.AOAprintCharacter('f', Line20+20);
		// If the segment has a RST flag on. Drop the segment, delete tcb and return
		DeleteTCB(TCBRecordNumber); 
		return 0;	
	    }
	    else
	    {
			//io.AOAprintCharacter('g', Line20+24);
               		// Error is here check it
			// send an Acknowledgement drop the segment and return 
			// Form an ACK and Send it 
			SrcPortNum[0]= HTTPPort_H;
			SrcPortNum[1]= HTTPPort_L;
		
			io.AOAPrintText("TCPObj:OtherHandler in TACK|TRST", Line22);
			io.AOAprintHex(TCBRecordNumber, Line22+140);
			io.AOAprintHex((long)tcb->PORT, Line22+120);
	  		retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TACK|TRST, tcb->RCVWND,
					    tcb->SNDNXT,tcb->RCVNXT, options, 0, data, 0, tcb->destmac, currenttask);
			DeleteTCB(TCBRecordNumber); 	
			
			return retcode;
	    }
    }  
    else //If the Incomming segment is acceptable
    {
	//io.AOAprintCharacter('h', Line20+28);
	// 2. Check if the RST bit is set 
        if((tcp->Flags & TRST) == TRST)
	{
	    //io.AOAprintCharacter('i', Line20+32);
	    DeleteTCB(TCBRecordNumber);
	    return 0;
	}

	// 3. Check the SYN bit
	if((tcp->Flags & TSYN) == TSYN)
	{
	    //io.AOAprintCharacter('j', Line20+36);
   	    // Form an ACK and Send it 
	    SrcPortNum[0]= HTTPPort_H;
	    SrcPortNum[1]= HTTPPort_L;
			
	    // Format a TCP Packet
	    // Error: The reset Sequence number might change
	    // Why TRST Here
	
	    retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TRST,tcb->RCVWND,
				tcb->SNDNXT,tcb->RCVNXT, options, 0, data, 0, tcb->destmac, currenttask);

   	    DeleteTCB(TCBRecordNumber);
	    return retcode;	
	}

	// 4. Check the ACK Field
	if((tcp->Flags & TACK) == TACK)
	{
	    tcb->SNDWND = tcp->window;

	    //io.AOAprintCharacter('k', Line20+40);
	    
	    if(tcb->state == SYNRCVD)
	    {
		tcb->noSynSent++;
		tcb->noAckSent++;
		//io.AOAprintCharacter('l', Line20+44);
	        // if we get correct ack for syn/ack, change state to established
		if((greaterEqualto(tcp->acknumber, tcb->SNDUNA, MAXTCPDATASIZE) >= 0) && 
		   (greaterEqualto(tcb->SNDNXT, tcp->acknumber, MAXTCPDATASIZE) >= 0) )
		{
		    //io.AOAprintCharacter('m', Line20+48);
		    // The Ack is acceptable 
		    // Our SYN has been ACKED 
		    // Enter Established State
		    tcb->state= ESTAB;
		    noconnestab++;
		    noconncurr++;
		  //sdp  tcb->SNDUNA = tcp->acknumber;
		  //sdp  tcb->LST = io.AOAgetTimer();

		    tcb->SRTT =CalcRTT(tcb->LST,tcb->SRTT);
                    //firstrtt
		    //  tcb->LST = io.AOAgetTimer();
		    return 0;
		}
		else
		{
			//io.AOAprintCharacter('n', Line20+52);
			// Error : Might Have Error Check it 
		    	// The Ack is not acceptable so send a RST and send it
			SrcPortNum[0]= HTTPPort_H;
			SrcPortNum[1]= HTTPPort_L;
			
			// Format a TCP Packet
			// Why TRST Here

	  		retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TRST,
					    0, tcp->acknumber,0 , options, 0, data, 0, tcb->destmac, currenttask);
			DeleteTCB(TCBRecordNumber);
			return retcode;
		}
	    } // end of if SYNRCVD

	    // Start of ESTAB State checking 
	    if(tcb->state == ESTAB)
	    {
		//io.AOAprintCharacter('o', Line20+56);
		// Case 1:		    
		//  |----------|-------|-------|-----------|
		//  0	      UNA     ack    SNDNXT     MAXTCPDATASIZE
		if((greaterEqualto(tcp->acknumber, tcb->SNDUNA, MAXTCPDATASIZE) >= 0) && 
		   (greaterEqualto(tcb->SNDNXT, tcp->acknumber, MAXTCPDATASIZE) >= 0))	
		{
			//io.AOAprintCharacter('p', Line20+60);
			if((greaterEqualto(tcp->seqnumber, tcb->SNDWL1, MAXTCPDATASIZE) > 0) ||
			  ((tcb->SNDWL1 == tcp->seqnumber) && (greaterEqualto(tcp->acknumber, 
			    tcb->SNDWL2, MAXTCPDATASIZE) >= 0)))
			{
			    io.AOAprintCharacter('q', Line20+64);
			    tcb->SNDWL1 = tcp->seqnumber;
			    tcb->SNDWL2 = tcp->acknumber;
			}
		
		        tcb->SNDUNA = tcp->acknumber;
			tcb->SRTT = CalcRTT(tcb->LST,tcb->SRTT);
			tcb->DIFF = CalcDiff(tcb->LST,tcb->SRTT,tcb->DIFF);
			tcb->SRTT = tcb->SRTT + 2*(tcb->DIFF);

			if(tcb->SNDNXT == tcb->SNDUNA)
			{
				if(tcb->suspendFlag==1)        //let the task get out of delay
					tcb->resumeFlag=1;
			}
                       // tcb->LST = io.AOAgetTimer();
			
			if((tcp->Flags & TFIN) == TFIN)
			{
			     //io.AOAprintCharacter('r', Line20+68);
			     tcb->state = CLOSEWAIT;
			     SrcPortNum[0]= HTTPPort_H;
		            SrcPortNum[1]= HTTPPort_L;

	  	 	    retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TRST,tcb->RCVWND,
					tcb->SNDNXT,tcb->RCVNXT, options, 0, data, 0, tcb->destmac, currenttask);
			    DeleteTCB(TCBRecordNumber);
                            return 0;
			}

			// payload
			int len = size - (tcp->Dataoffset*4);
			// in future
			if(len !=0)
			{
			    //io.AOAprintCharacter('s', Line20+72);
	 		    tcb->RCVNXT = tcb->RCVNXT + len;
			    tcb->RCVWND = tcb->RCVWND - len;
			    retcode = h.insert(&(TCPPack[(tcp->Dataoffset*4)]), len,TCBRecordNumber,
						tcb->IP, tcb->PORT);
			    tempretcode = retcode;
			    
			    //sdp scheduler  
	    		    tsk.insertHttpTask();
			    io.AOAMaskRunRegister(HTTP_PID, 1);
			    
			    // if insert fails
			    if(retcode != 0)
			    {
				//io.AOAprintCharacter('t', Line20+76);
				SrcPortNum[0]= HTTPPort_H;
		        	SrcPortNum[1]= HTTPPort_L;

	  	 		retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TRST,tcb->RCVWND,
					tcb->SNDNXT,tcb->RCVNXT, options, 0, data, 0, tcb->destmac, currenttask);
				DeleteTCB(TCBRecordNumber);

				return tempretcode; 
			    }
			    noHttpR++;	
			}
			
  		        // We may have to set up the send window here	
		        // Send an Acknowledgement 
	    	        SrcPortNum[0]= HTTPPort_H;
		        SrcPortNum[1]= HTTPPort_L;
			
	  	 	retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TACK,tcb->RCVWND,
					tcb->SNDNXT,tcb->RCVNXT+1, options, 0, data, 0, tcb->destmac, currenttask);
			tcb->noAckSent++;
			return retcode;
		}

		
		// Case 2:		    
		//  |----------|-------|-------|-----------|
		//  0	      ack     UNA    SNDNXT     MAXTCPDATASIZE
		if(greaterEqualto(tcb->SNDUNA, tcp->acknumber, MAXTCPDATASIZE) >= 0)
		{
			//io.AOAprintCharacter('u', Line20+80);
	                // ignore it  
			//
		//	tcb->SRTT = CalcRTT(tcb->LST,tcb->SRTT);
		//	tcb->LST = io.AOAgetTimer();
			return 0;
		}

		// Case 3:		    
		//  |----------|-------|-------|-----------|
		//  0	      UNA     SNDNXT  ack     MAXTCPDATASIZE
		if(greaterEqualto(tcp->acknumber,tcb->SNDNXT, MAXTCPDATASIZE) > 0)
		{
			//io.AOAprintCharacter('v', Line20+84);
					
		    	SrcPortNum[0]= HTTPPort_H;
			SrcPortNum[1]= HTTPPort_L;

	  		retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TRST,tcb->RCVWND,
					tcb->SNDNXT,tcb->RCVNXT, options, 0, data, 0, tcb->destmac, currenttask);
			
			DeleteTCB(TCBRecordNumber);
			
			return retcode;	
		}

		
	    }// End of ESTAB State Checking

	    if(tcb->state == FINWAIT1)
	    {

		//io.AOAprintCharacter('w', Line20+88);
                //io.AOAprintHex(tcp->acknumber,Line24);
	        //io.AOAprintHex(tcb->SNDNXT,Line24+20);	
		if(tcp->acknumber == (tcb->SNDNXT))
		{
	//	 retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TACK,tcb->RCVWND,
	//	        	       tcb->SNDNXT,tcb->RCVNXT + 1, options, 0, data, 0, tcb->destmac, currenttask);			 DeleteTCB(TCBRecordNumber); 

//			    return 0;
			//io.AOAprintCharacter('x', Line20+92);
			tcb->SNDUNA = tcp->acknumber;
			//
			tcb->SRTT = CalcRTT(tcb->LST,tcb->SRTT);
                       // tcb->LST = io.AOAgetTimer();
			if(tcb->suspendFlag==1)        //let the task get out of delay
					tcb->resumeFlag=1;
                    	if((tcp->Flags & TFIN) == TFIN)
			{
			    SrcPortNum[0]= HTTPPort_H;
		            SrcPortNum[1]= HTTPPort_L;

	         	    retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TACK,tcb->RCVWND,
		        	       tcb->SNDNXT,tcb->RCVNXT + 1, options, 0, data, 0, tcb->destmac, currenttask);                      	    tcb->noAckSent++; 
		            tcb->state = CLOSING; 
			    DeleteTCB(TCBRecordNumber); 

			    return 0;
			}
			else
			{
			    tcb->state = FINWAIT2;
			    return 0;
			}
		}
		else if(tcp->acknumber > tcb->SNDUNA && tcp->acknumber <( tcb->SNDNXT + 1 ))
		{
			//io.AOAprintCharacter('y', Line20+96);
			tcb->SNDUNA = tcp->acknumber;
			//
			tcb->SRTT = CalcRTT(tcb->LST,tcb->SRTT);
		//	tcb->LST = io.AOAgetTimer();
			
                	if((tcp->Flags & TFIN) == TFIN)
			{
			    SrcPortNum[0]= HTTPPort_H;
		            SrcPortNum[1]= HTTPPort_L;

	         	    retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TACK|TRST,tcb->RCVWND,
		        	       tcb->SNDNXT,tcb->RCVNXT + 1, options, 0, data, 0, tcb->destmac, currenttask); 
			    DeleteTCB(TCBRecordNumber); 

		            //tcb->state = CLOSING; 
			    return 0;
			}
		}
		return 0;
	    }

	   if(tcb->state == CLOSING)
	   {	
		//io.AOAprintCharacter('z', Line20+100);
		if(tcp->acknumber == tcb->SNDNXT/* sdp + 1 */)
		{
		   //io.AOAprintCharacter('A', Line20+104);
		   tcb->state = TIMEWAIT;
		   tcb->SNDUNA = tcp->acknumber;
		   tcb->SRTT =  CalcRTT(tcb->LST,tcb->SRTT);
	//	   tcb->LST = io.AOAgetTimer(); 
//		   UpdateTimeWaitList(TCBRecordNumber); 
		   DeleteTCB(TCBRecordNumber); 

		}
		return 0;
	   }

	   if(tcb->state == LASTACK)
	   {
		//io.AOAprintCharacter('B', Line20+108);
		if(tcp->acknumber == tcb->SNDNXT)
		{
			//io.AOAprintCharacter('C', Line20+112);
			DeleteTCB(TCBRecordNumber);
			tcb->state = CLOSED;
		}
	        return 0;	
	   }

	} // end of ACK

	// 5. Check the FIN Field
	if((tcp->Flags & TFIN) == TFIN)
	{
	   //io.AOAprintCharacter('D', Line20+116);
	   if(tcb->state == ESTAB)
	   {
		//io.AOAprintCharacter('E', Line20+120);
		SrcPortNum[0]= HTTPPort_H;
		SrcPortNum[1]= HTTPPort_L;
                if(tcb->suspendFlag==1)        //let the task get out of delay
		      tcb->resumeFlag=1;
	  	retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TACK,tcb->RCVWND,
				tcb->SNDNXT,tcb->RCVNXT + 1, options, 0, data, 0, tcb->destmac, currenttask);
		tcb->noAckSent++;	
		tcb->state = CLOSEWAIT;
		return retcode;
	   }

	   if(tcb->state == FINWAIT1)
	   {
		//io.AOAprintCharacter('F', Line20+124);
	        SrcPortNum[0]= HTTPPort_H;
		SrcPortNum[1]= HTTPPort_L;
                if(tcb->suspendFlag==1)        //let the task get out of delay
		     tcb->resumeFlag=1;
	  	retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TACK,tcb->RCVWND,
				tcb->SNDNXT,tcb->RCVNXT + 1, options, 0, data, 0, tcb->destmac, currenttask);
		tcb->noAckSent++;	
		tcb->state = CLOSING;
		DeleteTCB(TCBRecordNumber); 

		return 0;
	   }

	   if(tcb->state == FINWAIT2)
	   {
		//io.AOAprintCharacter('G', Line20+128);
		SrcPortNum[0]= HTTPPort_H;
		SrcPortNum[1]= HTTPPort_L;
                if(tcb->suspendFlag==1)        //let the task get out of delay
		   tcb->resumeFlag=1;
	  	retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TACK,tcb->RCVWND,
				tcb->SNDNXT,tcb->RCVNXT+1, options, 0, data, 0, tcb->destmac, currenttask);
		tcb->noAckSent++;	
		tcb->state = TIMEWAIT; 
  	        //tcb->LST = io.AOAgetTimer(); 
		DeleteTCB(TCBRecordNumber); 
	
		return retcode;
	   }
        } // end of if FIN

	
	//5. Process the Incomming segment text
	if((tcb->state == ESTAB) || (tcb->state == FINWAIT1) || (tcb->state == FINWAIT2))
	{
		//io.AOAprintCharacter('H', Line20+132);
		if( tcp->acknumber > tcb->SNDUNA )
		   tcb->SNDUNA = tcp->acknumber;		
	        
		tcb->SRTT = CalcRTT(tcb->LST,tcb->SRTT);
		tcb->DIFF = CalcDiff(tcb->LST,tcb->SRTT,tcb->DIFF);
		tcb->SRTT = tcb->SRTT + 2*(tcb->DIFF);
	

		int len = size - (tcp->Dataoffset*4);					
		// payload
		if(len !=0)
		{
			    //io.AOAprintCharacter('I', Line20+136);
	 		    tcb->RCVNXT = tcb->RCVNXT + len;
			    tcb->RCVWND = tcb->RCVWND - len;
			    retcode = h.insert(&(TCPPack[(tcp->Dataoffset*4)]), len,TCBRecordNumber,
						tcb->IP, tcb->PORT);
			    tempretcode = retcode;
		
			    //sdp scheduler 
			    tsk.insertHttpTask();
			    io.AOAMaskRunRegister(HTTP_PID, 1);
			    
			    // if insert fails
			    if(retcode != 0)
			    {
				//io.AOAprintCharacter('J', Line20+140);
				SrcPortNum[0]= HTTPPort_H;
		        	SrcPortNum[1]= HTTPPort_L;

	  	 		retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TRST,tcb->RCVWND,
					tcb->SNDNXT,tcb->RCVNXT, options, 0, data, 0, tcb->destmac, currenttask);
				DeleteTCB(TCBRecordNumber);

				return tempretcode; 
			    }
		}
		return 0;
	} // end of if
    } // end of else
    return 0;	
}

//**************************************************************************************************
// This Function assembles the TCP Packet in the Form of TCP Header Structure
// It takes pointer to the buffer, which the Structure pointer will point to 
// and the TCP Packet buffer

void TCPObj::FormatHeader(char * Header, char * TCPPack)
{
	Header[0] = TCPPack[1];
	Header[1] = TCPPack[0];
	Header[2] = TCPPack[3];
	Header[3] = TCPPack[2];

	Header[4] = TCPPack[7];		
	Header[5] = TCPPack[6];
	Header[6] = TCPPack[5];
	Header[7] = TCPPack[4];

	Header[8] = TCPPack[11];		
	Header[9] = TCPPack[10];
	Header[10] = TCPPack[9];
	Header[11] = TCPPack[8];

	Header[12] = TCPPack[12];
	Header[12] = Header[12] >> 4;
	Header[13] = TCPPack[13];

	Header[14] = TCPPack[15];
	Header[15] = TCPPack[14];

	Header[16] = TCPPack[17];
	Header[17] = TCPPack[16];
	
	Header[18] = TCPPack[19];
	Header[19] = TCPPack[18];
	
	int dataoffset;
	dataoffset = (int)&TCPPack[Header[12]*4];
	char *temp = (char*)&dataoffset;

	
	long Options = (long)&TCPPack[20];
	char *temp1 = (char*)&Options;

	Header[20] = temp[0];
	Header[21] = temp[1];
	Header[22] = temp[2];
	Header[23] = temp[3];

	Header[24] = temp1[0];
	Header[25] = temp1[1];
	Header[26] = temp1[2];
	Header[27] = temp1[3];
}

//*****************************************************************************************************************


//This function Format's a TCP Packet
int TCPObj::FormatTCPPacket(char *TCPPack, char *sourceIP, char *destIP, 
    char *sourcePort, char * destPort, char Flags,unsigned short Window,unsigned long seqnum, 
    unsigned long acknum, char *options, int numbytesoptions, char *data, int datasize, int rIndex, int currenttask)
{
	int retcode = 0; 
	int checksum = 0;

	// Assign the source and destination port 
    	TCPPack[0] = sourcePort[0];
	TCPPack[1] = sourcePort[1];	
	TCPPack[2] = destPort[0];
	TCPPack[3] = destPort[1];		

	// Assign the sequence numbers	
	TCPPack[4] = (seqnum>>24)&0x000000FF;
	TCPPack[5] = (seqnum>>16)&0x000000FF; 
	TCPPack[6] = (seqnum>>8)&0x000000FF; 
	TCPPack[7] = (seqnum)&0x000000FF; 

	// Assign the acknowledgement numbers
	TCPPack[8] = (acknum>>24)&0x000000FF;
	TCPPack[9] = (acknum>>16)&0x000000FF; 
	TCPPack[10] = (acknum>>8)&0x000000FF; 
	TCPPack[11] = (acknum)&0x000000FF; 
	
	// Calculate the Header Length including Options and assign it to the Header
	// 5 - Minimun TCP Header
	char HeaderLength = 5 + (int)(numbytesoptions /4);
	if((numbytesoptions%4) > 0)
	    HeaderLength = HeaderLength +1;
	TCPPack[12] = ((HeaderLength<<4) & 0xF0);

	// Assign the Flags and window to the packet
	TCPPack[13] = (Flags & 0x3F);	
	TCPPack[14] = (Window>>8)&0x00FF;
	TCPPack[15] = Window & 0x00FF;

	// Initialize the urgent pointer to zero not supported
	TCPPack[18] = 0x00;
	TCPPack[19] = 0x00;	
	
	//numbytesoptions is 0 
	int i=0;
	for(i = 0 ; i < numbytesoptions ; i++)
	{
		TCPPack[20+i] = options[i];
	}
	
	for(int k=0; k < (4-(numbytesoptions%4)) ; k++)
	{
		TCPPack[20+i] = 0x00;
		i++;
	}	
	int StartofData	= HeaderLength * 4;  //5*4 = 20 bytes 
	

	//RKK only one copy of data from HTTP memory to ETHERNET linked list memory 
	for(i=0; i < datasize; i++)
	{
		TCPPack[StartofData+i] = data[i+rIndex];
	}
/*
	SendCountPtr++; 
	if (SendCountPtr < 200) 
	  {
	   //store the counter value in memory 
	   io.AOAsetMem (0x0b000000 + SendCountPtr*4, (long)&TCPPack[0]+0x00110000); 
	  }
	else 
	   {
	   SendCountPtr = 0;  //restart the debug pointer 
	   }
*/
	checksum = TCPChecksum(TCPPack, (StartofData+datasize), sourceIP, destIP, TCP_Protocol);	

	TCPPack[16] = (char)((checksum>>8) & 0xFF);
	TCPPack[17] = (char)(checksum & 0xFF);	
	
	return StartofData+datasize;	
}
//************************************************************************************************************
// Calculate the TCP header checksum
unsigned short TCPObj::TCPChecksum(char *tdatagram, long TSLength,char *sourceIP, char*targetIP,unsigned int protocol)
{
 
	//Compute the Checksum
    	 unsigned short padd=0;
  	 unsigned int   word16=0;
	 unsigned long sum=0;	
	 unsigned int temp1=0;
	 unsigned int temp2=0;
	 unsigned short checksum=0;
	 tdatagram[16]=0x00;
	 tdatagram[17]=0x00;
	 
	// Find out if the length of data is even or odd number. If odd,
	// add a padding byte = 0 at the end of packet
	// here 'len' is the TCP packet len TCP(header + data)
	
	if (TSLength&1==1)
	{
	    	padd=1;
		tdatagram[TSLength]=0x00;
	} //end of IF
	
	// make 16 bit words out of every two adjacent 8 bit words and 
	// calculate the sum of all 16 bit words
	
	//TCP data 
	for (int i=0;i<TSLength+padd;i=i+2)
	{
		temp1 = tdatagram[i]; 
		temp2 = tdatagram[i+1];		
		word16 =((temp1<<8)&0xFF00)+(temp2&0xFF);
		sum += word16 & 0xffff;
	} //end of for
	
	// add  the TCP pseudo header which contains:
	// the IP source and destinationn addresses,
	for (i=0;i<4;i=i+2)
	{
	 	temp1 = sourceIP[i];
		temp2 = sourceIP[i+1];		
		word16 =((temp1<<8)&0xFF00)+(temp2&0xFF);
		sum += word16 & 0xffff;
	} //end of for
	
	for (i=0;i<4;i=i+2)
	{
		temp1 = targetIP[i];
		temp2 = targetIP[i+1];		
		word16 =((temp1<<8)&0xFF00)+(temp2&0xFF);
		sum += word16 & 0xffff;		
	} //end of for

	word16 =((protocol)&0x00FF);
	sum += word16 & 0xffff;

	word16 =((TSLength)&0xFFFF);
	sum += word16 & 0xffff;
		
	// keep only the last 16 bits of the 32 bit calculated sum and add the carries
    	while (sum>>16)
		sum = (sum & 0xFFFF)+(sum >> 16);
		
	// Take the one's complement of sum
	sum = ~sum;

        checksum = (unsigned short) sum;

	return checksum; 
 } 
// End of TCPChecksum

//***********************************************************************************************************
// Search for a record in TCB
// This function takes an source ip address an source port and checks if there is already a TCB
// in the TCB table for that connection if so it returns the TCB Value or else it returns -1 
int TCPObj::SearchTCB(char IPAdd[4], char SrcPortNum[2])
{	
   TCBRecord *TCBPointer;
   TCBPointer = (TCBRecord*)TCBBase;
   long hashval;
   long next;
   
   // check if the entry is already present in the TCB is so return Error
   hashval = t.hashfun(IPAdd,SrcPortNum);
   next = t.getIndex(hashval);
   
   while(next !=-1)
   {       
   if(TCBPointer[next].Avail == 1 && 
      TCBPointer[next].IP[0] == IPAdd[0] && TCBPointer[next].IP[1] == IPAdd[1] &&
      TCBPointer[next].IP[2] == IPAdd[2] && TCBPointer[next].IP[3] == IPAdd[3] && 
      TCBPointer[next].PORT[0] == SrcPortNum[0] && TCBPointer[next].PORT[1] == SrcPortNum[1]) 
     {
	 return next;
     }
     //-------------------------------------
     //Temporary solution must find out the problem 
     if(next == TCBPointer[next].next)
     {
	 TCBPointer[next].next = -1;
	 io.AOAPrintText("TCPObj:SearchTCB In if(next == TCBPointer[next].next)", Line22);
     }
     //-------------------------------------
     next = TCBPointer[next].next;
   }
   return -1;
    
}
//**********************************************************************************************
// general utility function for implementing TCP 
// This converts a char[] seqnum to unsigned long 
unsigned long TCPObj::charToseqnum(char *TCPPack)
{
	char  seqnum[4];
	seqnum[0] = TCPPack[3];
	seqnum[1] = TCPPack[2];
	seqnum[2] = TCPPack[1];
	seqnum[3] = TCPPack[0];	
	return (*(long*)seqnum);
}
// This function converts char[] window to unsigned short window 
unsigned short TCPObj::charToWindow(char *TCPPack)
{
	char seqnum[2];
	seqnum[0] = TCPPack[1];
	seqnum[1] = TCPPack[0];	
	
	return (*(unsigned short*)seqnum);
}

// update the SNDNXT
int TCPObj::updateSNDNxt(int TCBRecordNum,unsigned long seqnum)
{
   TCBRecord *TCBPointer;
   // Assign the address of the record to the TCB Pointer
   TCBPointer = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) ));
   TCBPointer->SNDNXT = seqnum;
   return 0;	
}

//*****************************************************************************************************************
//This function is used to send listener and other handler packets
//*****************************************************************************************************************
int TCPObj::SendMisc(char *sourceIP, char *destIP, char *sourcePort, char * destPort, char Flags,
		unsigned short Window,unsigned long seqnum, unsigned long acknum, char *options, 
		int numbytesoptions, char *data, int datasize, char *TargetMAC, int currenttask)
{

   //RKK Buffer Definitions 
	EtherObj EO; 
	char *send_buffer; 
	long *p1; 
	long c3; 
	char c4; 
	long x = 0; 
	int i; 
	int retcode = 0;

   	int TCPPack_size=0;
  	long InPtr=0;

   	p1 = &c3; //dummy address 
   	send_buffer = &c4;  //dummy address 

	
        //RKK Buffer Initialization 
	x = EO.DownListPointer + EO.SendInPtr * 32 + 8 - ADDR_OFFSET; 

        //check if the DPD pointer in the range 
          if ((x-8+ADDR_OFFSET) > (EO.DownListPointer + (SndLstSize-1) * 32))
            {
             return -22; 
            }    

	p1 = (long*)x; 
	
        //now check if this data buffer is within the limits of DPD data buffers 
        if ((*p1) >= (EO.DownListDataPointer + SndLstSize * EO.PacketSize)) 
          {
           return -23;
          }    
	
	send_buffer = (char*)*p1; //address from DPD pointing to next available slot 

	InPtr = EO.SendInPtr;

        EO.SendInPtr++;    //this is like an InPtr which inserts packets 

         if (EO.SendInPtr == EO.SndLstSize) 
           {
	    EO.SendInPtr = 0; //circular list 
           }
	 
	//add TCP header in front of the packet 
	send_buffer = send_buffer  - 20 - ADDR_OFFSET;//add header before data  

	TCPPack_size = FormatTCPPacket(send_buffer, sourceIP, destIP, sourcePort, destPort, Flags,
				Window, seqnum, acknum, options, numbytesoptions, data, datasize, 0, currenttask); 
	// this is to format IP packet 
	// ip and EO object instantiations can be avoided by placing the code in this object

	send_buffer = send_buffer - 20; //20 byte IP header  

	//pass by reference do not work in DOSC 
	// you have to use return value to get the value from call 
	// double indexing need to be done to pass by reference 
	retcode = ip.FormatIPPacket(send_buffer, TCPPack_size, destIP, TargetMAC, TCP_Protocol, currenttask);
	if(retcode != 0)
	   return retcode;
	
	send_buffer = send_buffer - 14; //14  byte ethernet header  

	retcode = EO.FormatEthPacket(send_buffer, TCPPack_size+20, IP_TYPE , TargetMAC, InPtr, currenttask);
	if(retcode != 0)
	   return retcode;

        return 0; 
}

//****************************************************************************************************
//RKKUSED......................
//SEND USED
// This is the only send used by TCP to send packets 
//This function is used to send TCP Data one segment at a time 
// to send ftp files in blocks RKK Send 1  Used  
// return code
// -9  TCB Segment size is greater than the maximum acceptable send size
// -10 Connection closed because no connection exists
// -11 State is not established or finwait1
// -12 Dpd pointer is out of range
// -13 Data buffer is out of range
//****************************************************************************************************
/*
int TCPObj::Send(int TCBRecordNum, char *sendbuffer, int rIndex, unsigned long *sendsize, 
		unsigned long SeqNum,char flags, char *tip, char *port, int currenttask)
{
   AOATask task;
   EtherObj EO; 
   char *send_buffer; 
   long *p1; 
   long c3; 
   char c4; 
   long x = 0; 
   int i; 
   int retcode = 0;
   
   char SrcPortNum[2];
   int TCPPack_size=0;
   char *options = "";
   char TargetMAC[6];
   long InPtr=0;
   int currtime = 0;

   p1 = &c3; //dummy address 
   send_buffer = &c4;  //dummy address 

   // Check for send Size 
   if(*sendsize>MAXTCPDATASIZE)
   {
       return -9;
   }
   
   TCBRecord *tcb; 
   tcb = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) )); 
   if(tcb->Avail ==0)
   {
       // Error the connection is closed because no connection exist
       return -10;
   }

   if(tcb->state == ESTAB || tcb->state == FINWAIT1)
   {
        // Assign the source Port number to HTTP Port 
	SrcPortNum[0]= HTTPPort_H;
	SrcPortNum[1]= HTTPPort_L;
  
	x = EO.DownListPointer + EO.SendInPtr * 32 + 8 - ADDR_OFFSET; 

        //check if the DPD pointer in the range 
          if ((x-8+ADDR_OFFSET) > (EO.DownListPointer + (SndLstSize-1) * 32))
            {
                return -12; 
            }    

	p1 = (long*)x; 
	
        //now check if this data buffer is within the limits of DPD data buffers 
        if ((*p1) >= (EO.DownListDataPointer + SndLstSize * EO.PacketSize))
          {
              return -13;
          }    
	
	send_buffer = (char*)*p1; //address from DPD pointing to next available slot 

	InPtr = EO.SendInPtr;

        EO.SendInPtr++;    //this is like an InPtr which inserts packets 

         if (EO.SendInPtr == EO.SndLstSize) 
           {
	    EO.SendInPtr = 0; //circular list 
           }
	 
	//add TCP header in front of the packet 
	send_buffer = send_buffer  - 20 - ADDR_OFFSET;//add header before data  

	TCPPack_size = FormatTCPPacket(send_buffer, HostIP, tcb->IP, SrcPortNum, tcb->PORT,
		       flags,tcb->RCVWND,SeqNum,tcb->RCVNXT, options, 0, sendbuffer, *sendsize, rIndex, currenttask); 
	// this is to format IP packet 
	// ip and EO object instantiations can be avoided by placing the code in this object

	send_buffer = send_buffer - 20; //20 byte IP header  

	//pass by reference do not work in DOSC 
	// you have to use return value to get the value from call 
	// double indexing need to be done to pass by reference 
	retcode = ip.FormatIPPacket(send_buffer, TCPPack_size, tcb->IP, tcb->destmac, TCP_Protocol, currenttask);
	if(retcode != 0)
	   return retcode;
	
	send_buffer = send_buffer - 14; //14  byte ethernet header  

	retcode = EO.FormatEthPacket(send_buffer, TCPPack_size+20, IP_TYPE , tcb->destmac, InPtr, currenttask);
	if(retcode != 0)
	   return retcode;
	
	return 0; 
       
   }
  return 0; 
}
*/

//***********************************************************************************
// send n
//***********************************************************************************
int TCPObj::SendN(int TCBRecordNum, char *sendbuffer, int rIndex, unsigned long SeqNum,
		char flags, char *tip, char *port, int noOfPackets, int leftOverBytes, int lastSet, int currenttask)
{
   AOATask task;
   EtherObj EO; 
   char *send_buffer; 
   long *p1; 
   long c3; 
   char c4; 
   long x = 0; 
   int i=0,j=0; 
   int retcode = 0;
   
   char SrcPortNum[2];
   int TCPPack_size=0;
   char *options = "";
   char TargetMAC[6];
   long InPtr=0;
   int currtime = 0;
   int temprIndex = 0;
   int tempSeqNum = 0;
   int tempflags = 0;
   int count1 = 0;
   int lastFlag = 0;

   if(leftOverBytes == 0)
	count1 = noOfPackets;
   else
	count1 = noOfPackets + 1;

   temprIndex = rIndex;
   tempSeqNum = SeqNum;
   tempflags = flags;

   p1 = &c3; //dummy address 
   send_buffer = &c4;  //dummy address 

   TCBRecord *tcb; 
   tcb = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) )); 
   if(tcb->Avail ==0)
   {
       // Error the connection is closed because no connection exist
       return -10;
   }
   
   if(tcb->state == ESTAB || tcb->state == FINWAIT1)
   {
        // Assign the source Port number to HTTP Port 
	SrcPortNum[0]= HTTPPort_H;
	SrcPortNum[1]= HTTPPort_L;
  
   for(i=0; i<noOfPackets; i++)	
   {
        if(lastSet == 1 && leftOverBytes == 0 && i == noOfPackets-1)
	   tempflags = tempflags | TFIN;
	
	if((i+1)*TCPSegSize > 5000)
	   tempflags = tempflags | TPUSH;
	
	x = EO.DownListPointer + EO.SendInPtr * 32 + 8 - ADDR_OFFSET; 

        //check if the DPD pointer in the range 
          if ((x-8+ADDR_OFFSET) > (EO.DownListPointer + (SndLstSize-1) * 32))
            {
                return -12; 
            }    

	p1 = (long*)x; 
	
        //now check if this data buffer is within the limits of DPD data buffers 
        if ((*p1) >= (EO.DownListDataPointer + SndLstSize * EO.PacketSize))
          {
              return -13;
          }    
	
	send_buffer = (char*)*p1; //address from DPD pointing to next available slot 

	InPtr = EO.SendInPtr;

        EO.SendInPtr++;    //this is like an InPtr which inserts packets 

         if (EO.SendInPtr == EO.SndLstSize) 
           {
	    EO.SendInPtr = 0; //circular list 
           }
	 
	//add TCP header in front of the packet 
	send_buffer = send_buffer  - 20 - ADDR_OFFSET;//add header before data  

	TCPPack_size = FormatTCPPacket(send_buffer, HostIP, tcb->IP, SrcPortNum, tcb->PORT, tempflags,tcb->RCVWND,
			tempSeqNum,tcb->RCVNXT, options, 0, sendbuffer, TCPSegSize, temprIndex, currenttask); 
	// this is to format IP packet 
	// ip and EO object instantiations can be avoided by placing the code in this object

	send_buffer = send_buffer - 20; //20 byte IP header  

	//pass by reference do not work in DOSC 
	// you have to use return value to get the value from call 
	// double indexing need to be done to pass by reference 
	retcode = ip.FormatIPPacket(send_buffer, TCPPack_size, tcb->IP, tcb->destmac, TCP_Protocol, currenttask);
	if(retcode != 0)
	   return retcode;
	
	send_buffer = send_buffer - 14; //14  byte ethernet header  

	// last packet inserted in ethernet buffer
	if(leftOverBytes == 0 && i == noOfPackets-1)
	{
	 retcode = EO.FormatEthPacketN(send_buffer, TCPPack_size+20, IP_TYPE , tcb->destmac,
					InPtr, count1, currenttask);
	 if(retcode != 0)
	   return retcode;
        }
	else
	{
	 retcode = EO.FormatEthPacketN(send_buffer, TCPPack_size+20, IP_TYPE , tcb->destmac, InPtr, 0, currenttask);
	 if(retcode != 0)
	   return retcode;				
	}
	temprIndex = temprIndex + TCPSegSize; 
	tempSeqNum = tempSeqNum + TCPSegSize;
	
    } // end of for loop

   if(leftOverBytes != 0)
   {
        if(lastSet == 1)
	   tempflags = tempflags | TFIN;
	
	if(i*TCPSegSize+leftOverBytes > 5000)
	   tempflags = tempflags | TPUSH;
			   
	x = EO.DownListPointer + EO.SendInPtr * 32 + 8 - ADDR_OFFSET; 

        //check if the DPD pointer in the range 
          if ((x-8+ADDR_OFFSET) > (EO.DownListPointer + (SndLstSize-1) * 32))
            {
                return -12; 
            }    

	p1 = (long*)x; 
	
        //now check if this data buffer is within the limits of DPD data buffers 
        if ((*p1) >= (EO.DownListDataPointer + SndLstSize * EO.PacketSize))
          {
              return -13;
          }    
	
	send_buffer = (char*)*p1; //address from DPD pointing to next available slot 

	InPtr = EO.SendInPtr;

        EO.SendInPtr++;    //this is like an InPtr which inserts packets 

         if (EO.SendInPtr == EO.SndLstSize) 
           {
	    EO.SendInPtr = 0; //circular list 
           }
	 
	//add TCP header in front of the packet 
	send_buffer = send_buffer  - 20 - ADDR_OFFSET;//add header before data  

	TCPPack_size = FormatTCPPacket(send_buffer, HostIP, tcb->IP, SrcPortNum, tcb->PORT, tempflags,tcb->RCVWND,
			tempSeqNum,tcb->RCVNXT, options, 0, sendbuffer, leftOverBytes, temprIndex, currenttask); 
	// this is to format IP packet 
	// ip and EO object instantiations can be avoided by placing the code in this object

	send_buffer = send_buffer - 20; //20 byte IP header  

	//pass by reference do not work in DOSC 
	// you have to use return value to get the value from call 
	// double indexing need to be done to pass by reference 
	retcode = ip.FormatIPPacket(send_buffer, TCPPack_size, tcb->IP, tcb->destmac, TCP_Protocol, currenttask);
	if(retcode != 0)
	   return retcode;
	
	send_buffer = send_buffer - 14; //14  byte ethernet header  

	retcode = EO.FormatEthPacketN(send_buffer, TCPPack_size+20, IP_TYPE , tcb->destmac, 
					InPtr, count1, currenttask);
	if(retcode != 0)
	   return retcode;
   }
   
	return 0; 
   } // end of if

return 0; 
}

//****************************************************************************************************
//gets the sequence number
// returns the current sequence number of the connection instance 
//****************************************************************************************************
unsigned long TCPObj::getSeqNum(int TCBRecordNum)
{
 TCBRecord *tcb; 
 tcb = (TCBRecord*)(TCBBase); 
 return tcb[TCBRecordNum].SNDNXT;
}
//****************************************************************************************************
//get the seq num that was last ack
//This runs only in multitasking environment 
//return code
//-28 TCB is not available
//****************************************************************************************************
unsigned long  TCPObj::getLastAck(int TCBRecordNum)
{
 TCBRecord *tcb;
 tcb = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) )); 
 
 if(tcb->Avail == 0)
     return -28;
/* if(tcb->state == CLOSED)
     return -6; 
*/ 
 return tcb->SNDUNA;
}
//*************************************************************************************************
// get the RTT value
// Just returns the RTT value of the connection instance 
int TCPObj::getRtt(int TCBRecordNum)
{
 TCBRecord *tcb; 
 tcb = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) )); 
 return tcb->SRTT; 
}

//get the loopcount from tcb 
unsigned long TCPObj::getLoopcount(int TCBRecordNum)
{
 TCBRecord *tcb; 
 tcb = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) )); 
 return tcb->LOOPCOUNT; 
}
/*
//get responseHeader from tcb
char TCPObj::getResponseheader(int TCBRecordNum)
{
 TCBRecord *tcb; 
 tcb = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) )); 
 return tcb->RESPONSEHEADER; 
}

//get resource address from tcb
unsigned long TCPObj::getResource(int TCBRecordNum)
{
 TCBRecord *tcb; 
 tcb = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) )); 
 return tcb->RESOURCEADDRESS; 
}

//get file size from tcb
long TCPObj::getFilesize(int TCBRecordNum)
{
 TCBRecord *tcb; 
 tcb = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) )); 
 return tcb-FILESIZE; 
}

//get header size
long TCPObj::getHsize(int TCBRecordNum)
{
 TCBRecord *tcb; 
 tcb = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) )); 
 return tcb->HSIZE; 
}
*/
//get currenttask id
int TCPObj::getCurrenttask(int TCBRecordNum)
{
 TCBRecord *tcb; 
 tcb = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) )); 
 return tcb->CURRENTTASK; 
}

int TCPObj::setRtt(int TCBRecordNum, long lst)
{
    TCBRecord *tcb;
    tcb = (TCBRecord*)(TCBBase + ( TCBRecordNum * sizeof(TCBRecord) ));
    tcb->LST=lst;
    return 0;
}
			

//*************************************************************************************************
// This function is used to do a modulo 32 comparision for the sesuence numbers 
// This function assumes that the seq1 is greater than seq 2 if not it will return 0xFFFFFFFF
// Else if seq1 is greater than seq 2 it will return the difference between seq1 ans seq2
// The logic is self explanatory 
// In a very fast connection there is a possibility the sequence numbers might wrap around causing an error in the program. Not in the current environment  
//  If the packets acknowledgement number is not in the acceptable range in the other handler it is advisable to verify the return values from this function and ckeck the sequence numbers u r self 
//  This error is a very rare case 
//********************************************************************************************
unsigned long TCPObj::mod32cmp(unsigned long seq1, unsigned long seq2)
{
	unsigned long MAXVal = 0xFFFFFFFF;
	unsigned long MIDVal = (0xFFFFFFFF / 2);
    	unsigned long LeastVal = 0x00;
	
	// if both the sesuence numbers are equal return 0 
    	if(seq1 == seq2)
		return 0x00;
    	
	if(seq1 <= MIDVal && seq1 >= LeastVal && seq2 <=MIDVal && seq2 >= LeastVal)
	{
		if( seq1 < seq2)
		{
		return 0xFFFFFFFF;
		}
		return (seq1-seq2);
    	}
	else if(seq1 > MIDVal && seq1 <= MAXVal && seq2 > MIDVal && seq2 <= MAXVal)
    	{
		if( seq1 < seq2)
		{
			return 0xFFFFFFFF;
		}

     	}
	else if(seq2 >= (MIDVal/2) && seq2 <=MIDVal && seq1 >=MIDVal && seq1<=(MIDVal*3/2))
    	{
		return (seq1 - seq2);
    	}
	else if(seq1 >= LeastVal && seq1 <=(MIDVal/2) && seq2 <=MAXVal && seq2 >=(MIDVal*3/2))
    	{
		return ((MAXVal-seq2) + (seq1-LeastVal));
    	}
    	return 0xFFFFFFFF;
}



//get LST
int TCPObj::getLST(int TCBRecordNum)
{
    TCBRecord *tcb;
    tcb=(TCBRecord*)(TCBBase + (TCBRecordNum * sizeof(TCBRecord )));
    return tcb->LST;
}
//***************************************************************

//get sliding window size
long TCPObj::getSlidingWindow(int TCBRecordNum)
{
    TCBRecord *tcb;
    tcb=(TCBRecord*)(TCBBase + (TCBRecordNum * sizeof(TCBRecord) ));
    return tcb->SNDWND;
}



//***********************************************************************************************
// This function calculates the RTT for the transmission 
// This is based on formula 0.3* RTTPrev + 0.7 * RTTCurrent
// Where RTT is the time from LST to Time the ACK is obtained  	
//***********************************************************************************************
unsigned long TCPObj::CalcRTT(unsigned long LST, unsigned long SRTT)
{
    unsigned long RTT;
    //io.AOAprintHex(LST, Line24+60);
    //io.AOAprintHex(SRTT, Line24+80);
    //RTT = ((long)(SRTT*(3/10))) + ((long)( (7/10) * (io.AOAgetTimer() - LST ))) +1;
    RTT = (long)(io.AOAgetTimer() - LST);
    return RTT;
}

//***********************************************************************************************
//***********************************************************************************************
unsigned long TCPObj::CalcDiff(unsigned long LST, unsigned long SRTT, unsigned long DIFF)
{
    unsigned long Diff;
    unsigned long a;
    //io.AOAprintHex(LST, Line24+60);
    //io.AOAprintHex(SRTT, Line24+80);
    //RTT = ((long)(SRTT*(3/10))) + ((long)( (7/10) * (io.AOAgetTimer() - LST ))) +1;
    a = (long)(io.AOAgetTimer() - LST - SRTT);
    if (a>=0)
       Diff = DIFF + a;
    else
       Diff = DIFF - a;
    return Diff;
}

//****************************************************************************************************
// This function is used to send the TCP Data for a http response 
// It get the TCPRecordNo to identify the connection
// The HTTP Response Header
// The HTTP Header Size
// The HTTP Resource Address
// The HTTP Resource/File Size 
// Then Sends the TCP Data 
// In HTTP Headers the content size must be specified for this function to be successful 
// return code
// -7 Send flag cannot be set
// -8 Connection timeout
//****************************************************************************************************
/*
int TCPObj::tcpSend(int TCBRecordNum, char *responseHeader, long hSize, unsigned long resourceAddress,
		    long fileSize, char *ip, char *port, int currenttask)
{
	AOATask task;
	apptask tsk;
        TCBRecord *tcb;
	int tcbrno = 0; 
	int retcode = 0;

	tcbrno = TCBRecordNum;
	tsk.Current_TCBRNo = tcbrno;		// save the record number	

        tcb=(TCBRecord*)(TCBBase + (tcbrno * sizeof(TCBRecord) ));	
	
	unsigned long startHeaderSeq=0;		// Denotes starting sequence number
	unsigned long startResourceSeq=0;	// starting resource sequence number
	unsigned long expectedHeaderAck=0;	// expected ack num for header
      	unsigned long expectedResourceAck=0; 	// expected ack num for resource 
	
	unsigned long lastAck=0;		// Denotes the last ack number that 
						// corresponds to the last sequence number
	unsigned long cmpVal= 0; 		// This is the value returned by the mod32 cmp 
        unsigned long cmpVal1= 0; 		// This is the value returned by the mod32 cmp 
	unsigned long lst=0;
	int RTT=0;				// Round trip time

	//----------------------------------------------------------------
	//  SAVING PARAMETERS IN TCB
	tcb->RESOURCE = (char*)resourceAddress;
	tcb->LOOPCOUNT = io.AOAgetTimer(); 
        tcb->HSIZE = hSize;
	tcb->FILESIZE = fileSize;
	tcb->CURRENTTASK = currenttask;
	tcb->RESPONSEHEADER = responseHeader;
	tcb->SEQ = getSeqNum(tcbrno);
	//----------------------------------------------------------------
	
	int Sent_Flag =0;			// This flag is set to 1 if the send was successful
						// the send then send failed return failure to the user 
	long k = 0;				// Count Variable  
	long k1 = 0;
	long p = 0;
        int counter1=0;
	int tempvalue=0;
	
        char buffer[2]; 
	unsigned long j=0;

	long sw	 = getSlidingWindow(tcbrno);  //sliding window

	// Set the send flag and lock the TCP connection for this send 
	// so no other thread can send data on this connection  
	int sendf = 1;
        int temptimer=0;
	noHttpRs++;

	//RTT=getRtt(TCBRecordNum);		// get the RTT of the connection instance 
	
	startResourceSeq = tcb->SEQ + tcb->HSIZE;// Self explanatory  	
	expectedHeaderAck=tcb->SEQ+ tcb->HSIZE; // Assign the expected ack number for header 
	expectedResourceAck=startResourceSeq+ tcb->FILESIZE;// assign the expected ack for resource
	    
	wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00100000, 3); 

	// First send the HTTP data 
	//setRtt(TCBRecordNum, io.AOAgetTimer());
	//
        //Case1
	//  |<-------------------sliding window-------------------->|              
	//  |<---- hSize---------->|<------fileSize---------->|
	//  |----------------------|--------------------------|
	//startHeaderSeq     startResourceSeq           expectedResourceAck  
	//in the case we shall send the header and the whole payload
	
	if(sw >= (tcb->HSIZE + tcb->FILESIZE))
	{
	    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00200000, 3); 
	    // sendHeader => sends http/1.1 200 OK data
	    // sendPayload1 => sends data --- called many times
	    // sendPayload2 => sends last data block (many packets) ; used at the end of transmission
	    sendHeader(tcbrno,tcb->RESPONSEHEADER,tcb->SEQ,expectedHeaderAck, tcb->SEQ, 
		       sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);

            sendPayload2 (tcbrno,tcb->RESOURCE, startResourceSeq, expectedResourceAck, startResourceSeq,
		          sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);
	}
        //Case2
	//  |<--sliding window-->|              
	//  |<------hSize--------->|<------fileSize---------->|
	//  |----------------------|--------------------------|
	//startHeaderSeq     startResourceSeq           expectedResourceAck 
	//in that case we send part of header until sliding window size is full
	else if( sw < tcb->HSIZE)
	{
	    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00300000, 3); 
	    p = tcb->SEQ + sw;
	    sendHeader(tcbrno,tcb->RESPONSEHEADER,tcb->SEQ, p, tcb->SEQ,sendf,
				 tcb->IP, tcb->PORT, tcb->CURRENTTASK); 
	}
        //Case3
	//  |<--------sliding window------------>|              
	//  |<--------hSize------->|<-------fileSize--------->|
	//  |----------------------|--------------------------|
	//startHeaderSeq     startResourceSeq           expectedResourceAck  
	//in the case we send the header and part of payload until the sliding window is full
	else
	{
	    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00400000, 3); 
	    sendHeader(tcbrno,tcb->RESPONSEHEADER,tcb->SEQ,expectedHeaderAck, tcb->SEQ, 
		       sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);

	    p = tcb->SEQ + sw - tcb->HSIZE;
	    sendPayload1(tcbrno, tcb->RESOURCE, startResourceSeq, p, startResourceSeq, 
				sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);
	}
	    
 	temptimer = io.AOAgetTimer();
        RTT=getRtt(tcbrno);
	wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00010000, 4); 
	wlst.insert(tcb->CURRENTTASK, 1);
	//-------------------------------------------------------------------------
	tsk.Current_TCBRNo = tcbrno;		// save the record number
	//When a task is suspended, other HTTP tasks can run and create a 
	// concurrency control issue, so save and restore the state of the task 
	//  use TCB for saving parameters 
	tcb->suspendFlag = 1;  //set the suspend flag 
	tcb->resumeFlag = 0;   //reset the resume flag 
	io.AOAprintHex((long)tcb->SRTT, Line22+20); 
	task.AOAsuspendHTask(20, tsk.Current_State, tsk.Current_TCBRNo, currenttask); //first delay 

	//restore TCBRecordNum
	tcbrno = tsk.Current_TCBRNo; 
	//-------------------------------------------------------------------------
	wlst.insert(tcb->CURRENTTASK, 2);
	wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00020000, 4); 

        tcb=(TCBRecord*)(TCBBase + (tcbrno * sizeof(TCBRecord) ));	
	tcb->suspendFlag = 0;  //reset the suspend flag 

	//after rtt time, if the tcp is deleted because of rst from client, we terminate tcp
       	if( tcb->Avail == 0)
	   return 0; 

	lastAck=getLastAck(tcbrno); 

	if(lastAck < 0 )
	{
	    //io.AOAprintCharacter('B', Line6+108);
	    if(sendf == 1)
	    {
		    //io.AOAprintCharacter('C', Line6+112);
		    // updateSNDNxt(TCBRecordNum, (startHeaderSeq + hSize + fileSize + 1));	
		    //ClearSendFlag(TCBRecordNum);   
	    sendf = 0; 
	    }
		    return lastAck;
	} 
	startResourceSeq = tcb->SEQ + tcb->HSIZE;// Self explanatory  	
	expectedHeaderAck=tcb->SEQ+ tcb->HSIZE; // Assign the expected ack number for header 
	expectedResourceAck=startResourceSeq+ tcb->FILESIZE;// assign the expected ack for resource	

	cmpVal = mod32cmp(lastAck, expectedHeaderAck);         //comapre last ack with header
        cmpVal1 = mod32cmp(lastAck, (expectedResourceAck+1));  //compare last ack with last bit of file
	
	if(cmpVal1 != 0xFFFFFFFF)           // we get the last bit acknowledgement, transmit finished
	{
	    //io.AOAprintCharacter('D', Line6+116);
	    Sent_Flag = 1;
	    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000010, 7);
	}

	 

	while(Sent_Flag != 1)               //we need to use loop to send the rest of packets
	{
		counter1++;
	        wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000100, 6); 

		//io.AOAprintCharacter('E', Line6+120);
		if(mod32cmp(io.AOAgetTimer(), tcb->LOOPCOUNT) > TIMER_PERIOD*1091 )
		{
		    //io.AOAprintCharacter('F', Line6+124);
		    // close the TCP connection 
		    //Close(TCBRecordNum);
		    // return Error to the user 	
		        
		    	if(sendf == 1)
			{
			//io.AOAprintCharacter('G', Line6+128);
		        //updateSNDNxt(TCBRecordNum, (startHeaderSeq + hSize + fileSize + 1));	
		    	//ClearSendFlag(TCBRecordNum);   
		 	sendf = 0; 
			}

                        buffer[0] = '\0';
		        retcode = Send(tcbrno, buffer, 0,  &j, tcb->SNDUNA, TRST,
				tcb->IP, tcb->PORT, tcb->CURRENTTASK); 	
		  //   retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TACK,tcb->RCVWND,
		 //       	       tcb->SNDNXT,tcb->RCVNXT + 1, options, 0, data, 0, tcb->destmac, currenttask); 	
			if(retcode != 0)
		    	{
		            return retcode;
		    	} 
			DeleteTCB(tcbrno);			
			wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000030, 7);
			return -8;
		}

		setRtt(tcbrno, io.AOAgetTimer());
		sw=getSlidingWindow(tcbrno);
		sendf=1;
		

		//ack is within the header
	        //  |--------------|--------|--------------------------|
	        //startHeaderSeq  ack     startResourceSeq           expectedResourceAck 
		if(cmpVal == 0xFFFFFFFF)         
		{
			//io.AOAprintCharacter('H', Line6+132);
		        k = (((unsigned long)tcb->HSIZE) - mod32cmp(expectedHeaderAck, lastAck));
			
			if(k < 0 )
			{
			    ////io.AOAprintCharacter('I', Line6+136);
			    k = 0; 
			}
		        

                //ack is within the header Case 1
		//                 |<--sliding window-->|      
	        //  |<----------hSize----------------------->|<--------fileSize-------->|
	        //  |--------------|-------------------------|--------------------------|
	        //startHeaderSeq  ack           startResourceSeq           expectedResourceAck 
			if( (k + sw)< tcb->HSIZE )
			{
			    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000200, 6); 
                	    k1 = tcb->SEQ + k;
			    p = k1 + sw;
	                    sendHeader(tcbrno, tcb->RESPONSEHEADER, k1, p, tcb->SEQ, 
				sendf,tcb->IP, tcb->PORT, tcb->CURRENTTASK); 
			}
                //ack is within the header Case 2
		//                 |<----------------sliding window----------------------->|    
	        //  |<-----hSize------------------------>|<------fileSize---------->|
	        //  |--------------|---------------------|--------------------------|
	        //startHeaderSeq  ack           startResourceSeq           expectedResourceAck 
			else if( ( k +sw ) >= (tcb->HSIZE + tcb->FILESIZE) )
			{
			    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000300, 6); 
			    k1 = tcb->SEQ +k;
			    sendHeader(tcbrno,tcb->RESPONSEHEADER, k1, expectedHeaderAck, tcb->SEQ,
				       sendf,tcb->IP, tcb->PORT, tcb->CURRENTTASK);  
                            sendPayload2 (tcbrno, tcb->RESOURCE, startResourceSeq, expectedResourceAck,
					  startResourceSeq, sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);
			}
                //ack is within the header Case 3
		//                 |<---------sliding window-------->|    
	        //  |<-----hSize------------------------>|<------fileSize---------->|
	        //  |--------------|---------------------|--------------------------|
	        //startHeaderSeq  ack           startResourceSeq           expectedResourceAck 
			else 
			{
			   wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000400, 6); 
			   k1 = tcb->SEQ + k;
			   sendHeader(tcbrno,tcb->RESPONSEHEADER, k1, expectedHeaderAck, tcb->SEQ,
				       sendf,tcb->IP, tcb->PORT, tcb->CURRENTTASK);  
			   p = k1 +sw -tcb->HSIZE;
			   sendPayload1(tcbrno, tcb->RESOURCE, startResourceSeq, p, startResourceSeq, 
				        sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK); 
			}			
		}
                //ack is within the payload range
	        //  |--------------------|-------------|-------------|
	        //startHeaderSeq  startResourceSeq    ack       expectedResourceAck 
		else if ( cmpVal != 0xFFFFFFFF && cmpVal1 == 0xFFFFFFFF )
		{
		    //io.AOAprintCharacter('i', Line7+28);
		    k = (((unsigned long)tcb->FILESIZE) - mod32cmp(expectedResourceAck, lastAck));
		//ack is within the payload Case 1
		//                                   |<---------sliding window-------->|    
	        //  |<-----hSize------->|<------fileSize----------->|
	        //  |-------------------|------------|--------------|
	        //startHeaderSeq  startResourceSeq  ack         expectedResourceAck 	
		    if ( ( k + sw) >= tcb->FILESIZE)
		    {
			wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000500, 6); 
			k1 = startResourceSeq + k;
		        sendPayload2 (tcbrno, tcb->RESOURCE, k1, expectedResourceAck, startResourceSeq,
		                      sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);
		    }
		//ack is within the payload Case 2
		//                                   |<-----sliding window---->|    
	        //  |<-----hSize------->|<-----------------fileSize------------------->|
	        //  |-------------------|------------|---------------------------------|
	        //startHeaderSeq  startResourceSeq  ack         expectedResourceAck  
		    else
		    { 
			wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000600, 6); 
			k1 = startResourceSeq + k;
			p = k1 +sw;
		        sendPayload1(tcbrno, tcb->RESOURCE, k1, p, startResourceSeq, 
					sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK); 	
		    }
		}
	
	       // lst=getLST(TCBRecordNum);
	//	RTT1=RTT;
        //        RTT = CalcRTT(lst,RTT1);
		//task.TaskSleep(TIMER_PERIOD*RTT);	 //HELONG
		//io.AOAprintHex(RTT, Line15+60);

		temptimer = io.AOAgetTimer();

		//io.AOAprintHex(temptimer, Line15+80);
		RTT=getRtt(tcbrno);
		
		wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00030000, 4);
		//-------------------------------------------------------------------------
		tsk.Current_TCBRNo = tcbrno;		// save the record number
		//When a task is suspended, other HTTP tasks can run and create a 
		// concurrency control issue, so save and restore the state of the task 
		//  use TCB for saving parameters 
	        tcb->suspendFlag = 1;  //set the suspend flag 
	        tcb->resumeFlag = 0;   //reset the resume flag 
	        io.AOAprintHex((long)tcb->SRTT, Line22+40); 
		task.AOAsuspendHTask(20, tsk.Current_State, tsk.Current_TCBRNo, currenttask); //second delay 

		//restore TCBRecordNum
		tcbrno = tsk.Current_TCBRNo; 
		//-------------------------------------------------------------------------
		wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00040000, 4);
     
                tcb=(TCBRecord*)(TCBBase + (tcbrno * sizeof(TCBRecord) ));	
	        tcb->suspendFlag = 0;  //reset the suspend flag 

	        //after rtt time, if the tcp is deleted because of rst from client, we terminate tcp
		//
       	        if( tcb->Avail == 0)
		    return 0; 

        	lastAck=getLastAck(tcbrno); 

		//io.AOAprintHex(lastAck, Line17+40);
		//io.AOAprintHex(expectedHeaderAck, Line17+60);
		//io.AOAprintHex(expectedResourceAck, Line17+80);
	
	        if(lastAck < 0 )
        	{
	        //io.AOAprintCharacter('B', Line6+108);
	          if(sendf == 1)
	          {
		    //io.AOAprintCharacter('C', Line6+112);
		    // updateSNDNxt(TCBRecordNum, (startHeaderSeq + hSize + fileSize + 1));	
		    //ClearSendFlag(TCBRecordNum);   
	            sendf = 0; 
	          }
		  return lastAck;
	        } 
	
	    	startResourceSeq = tcb->SEQ + tcb->HSIZE;// Self explanatory  	
		expectedHeaderAck=tcb->SEQ+ tcb->HSIZE; // Assign the expected ack number for header 
		expectedResourceAck=startResourceSeq+ tcb->FILESIZE;// assign the expected ack for resource	

                cmpVal1 = mod32cmp(lastAck,(expectedResourceAck+1));
                //io.AOAprintHex(lastAck, Line24+100);
		//io.AOAprintHex(expectedResourceAck,Line24+120);
                if(cmpVal1 != 0xFFFFFFFF)	
        	{
        	  Sent_Flag = 1;  
		  wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000020, 7);
        	}
		
		  tempvalue = counter1 & 0x0000000f;
		  tempvalue = tempvalue << 12;
		  wlst.insert(tcb->CURRENTTASK, tcbrno, tempvalue, 5);

        } // end of while
	return 0;
}
*/
//****************************************************************************************************
// This function is used to send the TCP Data for a http response 
// It get the TCPRecordNo to identify the connection
// The HTTP Response Header
// The HTTP Header Size
// The HTTP Resource Address
// The HTTP Resource/File Size 
// Then Sends the TCP Data 
// In HTTP Headers the content size must be specified for this function to be successful 
// return code
// -7 Send flag cannot be set
// -8 Connection timeout
//****************************************************************************************************
int TCPObj::tcpSendN(int TCBRecordNum, char *responseHeader, long hSize, unsigned long resourceAddress,
		    long fileSize, char *ip, char *port, int currenttask)
{
	AOATask task;
	apptask tsk;
        TCBRecord *tcb;
	int tcbrno = 0; 
	int retcode = 0;

	tcbrno = TCBRecordNum;
	tsk.Current_TCBRNo = tcbrno;		// save the record number	

        tcb=(TCBRecord*)(TCBBase + (tcbrno * sizeof(TCBRecord) ));	
	
	unsigned long startHeaderSeq=0;		// Denotes starting sequence number
	unsigned long startResourceSeq=0;	// starting resource sequence number
	unsigned long expectedHeaderAck=0;	// expected ack num for header
      	unsigned long expectedResourceAck=0; 	// expected ack num for resource 
	
	unsigned long lastAck=0;		// Denotes the last ack number that 
						// corresponds to the last sequence number
	unsigned long cmpVal= 0; 		// This is the value returned by the mod32 cmp 
        unsigned long cmpVal1= 0; 		// This is the value returned by the mod32 cmp 
	unsigned long lst=0;
	int RTT=0;				// Round trip time

	//----------------------------------------------------------------
	//  SAVING PARAMETERS IN TCB
	tcb->RESOURCE = (char*)resourceAddress;
	tcb->LOOPCOUNT = io.AOAgetTimer(); 
        tcb->HSIZE = hSize;
	tcb->FILESIZE = fileSize;
	tcb->CURRENTTASK = currenttask;
	tcb->RESPONSEHEADER = responseHeader;
	tcb->SEQ = getSeqNum(tcbrno);
	//----------------------------------------------------------------
	
	int Sent_Flag =0;			// This flag is set to 1 if the send was successful
						// the send then send failed return failure to the user 
	long k = 0;				// Count Variable  
	long k1 = 0;
	long p = 0;
        int counter1=0;
	int tempvalue=0;
	
        char buffer[2]; 
	unsigned long j=0;

	long sw	 = getSlidingWindow(tcbrno);  //sliding window

	// Set the send flag and lock the TCP connection for this send 
	// so no other thread can send data on this connection  
	int sendf = 1;
        int temptimer=0;
	noHttpRs++;

	//RTT=getRtt(TCBRecordNum);		// get the RTT of the connection instance 
	
	startResourceSeq = tcb->SEQ + tcb->HSIZE;// Self explanatory  
	expectedHeaderAck=tcb->SEQ+ tcb->HSIZE; // Assign the expected ack number for header 
	expectedResourceAck=startResourceSeq+ tcb->FILESIZE;// assign the expected ack for resource
	wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00100000, 3); 

	// First send the HTTP data 
	//setRtt(TCBRecordNum, io.AOAgetTimer());
	//
        //Case1
	//  |<-------------------sliding window-------------------->|              
	//  |<---- hSize---------->|<------fileSize---------->|
	//  |----------------------|--------------------------|
	//startHeaderSeq     startResourceSeq           expectedResourceAck  
	//in the case we shall send the header and the whole payload
	
	if(sw >= (tcb->HSIZE + tcb->FILESIZE))
	{
	    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00200000, 3); 
	    // sendHeader => sends http/1.1 200 OK data
	    // sendPayload1 => sends data --- called many times
	    // sendPayload2 => sends last data block (many packets) ; used at the end of transmission
	    sendHeader1(tcbrno,tcb->RESPONSEHEADER,tcb->SEQ,expectedHeaderAck, tcb->SEQ, 
		       sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);

            sendPayload4 (tcbrno,tcb->RESOURCE, startResourceSeq, expectedResourceAck, startResourceSeq,
		          sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);
	}
        //Case2
	//  |<--sliding window-->|              
	//  |<------hSize--------->|<------fileSize---------->|
	//  |----------------------|--------------------------|
	//startHeaderSeq     startResourceSeq           expectedResourceAck 
	//in that case we send part of header until sliding window size is full
	else if( sw < tcb->HSIZE)
	{
	    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00300000, 3); 
	    p = tcb->SEQ + sw;
	    sendHeader1(tcbrno,tcb->RESPONSEHEADER,tcb->SEQ, p, tcb->SEQ,sendf,
				 tcb->IP, tcb->PORT, tcb->CURRENTTASK); 
	}
        //Case3
	//  |<--------sliding window------------>|              
	//  |<--------hSize------->|<-------fileSize--------->|
	//  |----------------------|--------------------------|
	//startHeaderSeq     startResourceSeq           expectedResourceAck  
	//in the case we send the header and part of payload until the sliding window is full
	else
	{
	    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00400000, 3); 
	    sendHeader1(tcbrno,tcb->RESPONSEHEADER,tcb->SEQ,expectedHeaderAck, tcb->SEQ, 
		       sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);

	    p = tcb->SEQ + sw - tcb->HSIZE;
	    sendPayload3(tcbrno, tcb->RESOURCE, startResourceSeq, p, startResourceSeq, 
				sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);
	}
	    
 	temptimer = io.AOAgetTimer();
        RTT=getRtt(tcbrno);
	wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00010000, 4); 
	wlst.insert(tcb->CURRENTTASK, 1);
	//-------------------------------------------------------------------------
	tsk.Current_TCBRNo = tcbrno;		// save the record number
	//When a task is suspended, other HTTP tasks can run and create a 
	// concurrency control issue, so save and restore the state of the task 
	//  use TCB for saving parameters 
	tcb->suspendFlag = 1;  //set the suspend flag 
	tcb->resumeFlag = 0;   //reset the resume flag 
	task.AOAsuspendHTask(20/*4*(tcb->SRTT)*/, tsk.Current_State, tsk.Current_TCBRNo, currenttask); //first delay 

	//restore TCBRecordNum
	tcbrno = tsk.Current_TCBRNo; 
	//-------------------------------------------------------------------------
	wlst.insert(tcb->CURRENTTASK, 2);
	wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00020000, 4); 

        tcb=(TCBRecord*)(TCBBase + (tcbrno * sizeof(TCBRecord) ));	
	tcb->suspendFlag = 0;  //reset the suspend flag 

	//after rtt time, if the tcp is deleted because of rst from client, we terminate tcp
       	if( tcb->Avail == 0)
	   return 0; 

	lastAck=getLastAck(tcbrno); 

	if(lastAck < 0 )
	{
	    //io.AOAprintCharacter('B', Line6+108);
	    if(sendf == 1)
	    {
		    //io.AOAprintCharacter('C', Line6+112);
		    // updateSNDNxt(TCBRecordNum, (startHeaderSeq + hSize + fileSize + 1));	
		    //ClearSendFlag(TCBRecordNum);   
	    sendf = 0; 
	    }
		    return lastAck;
	} 
	startResourceSeq = tcb->SEQ + tcb->HSIZE;// Self explanatory  	
	expectedHeaderAck=tcb->SEQ+ tcb->HSIZE; // Assign the expected ack number for header 
	expectedResourceAck=startResourceSeq+ tcb->FILESIZE;// assign the expected ack for resource

	cmpVal = mod32cmp(lastAck, expectedHeaderAck);         //comapre last ack with header
        cmpVal1 = mod32cmp(lastAck, (expectedResourceAck+1));  //compare last ack with last bit of file
	
	if(cmpVal1 != 0xFFFFFFFF)           // we get the last bit acknowledgement, transmit finished
	{
	    //io.AOAprintCharacter('D', Line6+116);
	    Sent_Flag = 1;
	    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000010, 7);
	}

	 

	while(Sent_Flag != 1)               //we need to use loop to send the rest of packets
	{
		counter1++;
	        wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000100, 6); 

		//io.AOAprintCharacter('E', Line6+120);
		if(mod32cmp(io.AOAgetTimer(), tcb->LOOPCOUNT) > TIMER_PERIOD*1091 )
		{
		    //io.AOAprintCharacter('F', Line6+124);
		    // close the TCP connection 
		    //Close(TCBRecordNum);
		    // return Error to the user 	
		        
		    	if(sendf == 1)
			{
			//io.AOAprintCharacter('G', Line6+128);
		        //updateSNDNxt(TCBRecordNum, (startHeaderSeq + hSize + fileSize + 1));	
		    	//ClearSendFlag(TCBRecordNum);   
		 	sendf = 0; 
			}

                        buffer[0] = '\0';
		  //      retcode = Send(tcbrno, buffer, 0,  &j, tcb->SNDUNA, TRST,
		//		tcb->IP, tcb->PORT, tcb->CURRENTTASK); 	
		  //   retcode =  SendMisc(HostIP, SourceIP, SrcPortNum, &TCPPack[0],TACK,tcb->RCVWND,
		 //       	       tcb->SNDNXT,tcb->RCVNXT + 1, options, 0, data, 0, tcb->destmac, currenttask); 	
			if(retcode != 0)
		    	{
		            return retcode;
		    	} 
			DeleteTCB(tcbrno);			
			wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000030, 7);
			return -8;
		}

		setRtt(tcbrno, io.AOAgetTimer());
		sw=getSlidingWindow(tcbrno);
		sendf=1;
		

		//ack is within the header
	        //  |--------------|--------|--------------------------|
	        //startHeaderSeq  ack     startResourceSeq           expectedResourceAck 
		if(cmpVal == 0xFFFFFFFF)         
		{
		        k = (((unsigned long)tcb->HSIZE) - mod32cmp(expectedHeaderAck, lastAck));
			
			if(k < 0 )
			{
			    ////io.AOAprintCharacter('I', Line6+136);
			    k = 0; 
			}
		        

                //ack is within the header Case 1
		//                 |<--sliding window-->|      
	        //  |<----------hSize----------------------->|<--------fileSize-------->|
	        //  |--------------|-------------------------|--------------------------|
	        //startHeaderSeq  ack           startResourceSeq           expectedResourceAck 
			if( (k + sw)< tcb->HSIZE )
			{
			    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000200, 6); 
                	    k1 = tcb->SEQ + k;
			    p = k1 + sw;
	                    sendHeader1(tcbrno, tcb->RESPONSEHEADER, k1, p, tcb->SEQ, 
				sendf,tcb->IP, tcb->PORT, tcb->CURRENTTASK); 
			}
                //ack is within the header Case 2
		//                 |<----------------sliding window----------------------->|    
	        //  |<-----hSize------------------------>|<------fileSize---------->|
	        //  |--------------|---------------------|--------------------------|
	        //startHeaderSeq  ack           startResourceSeq           expectedResourceAck 
			else if( ( k +sw ) >= (tcb->HSIZE + tcb->FILESIZE) )
			{
			    wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000300, 6); 
			    k1 = tcb->SEQ +k;
			    sendHeader1(tcbrno,tcb->RESPONSEHEADER, k1, expectedHeaderAck, tcb->SEQ,
				       sendf,tcb->IP, tcb->PORT, tcb->CURRENTTASK);  
                            sendPayload4 (tcbrno, tcb->RESOURCE, startResourceSeq, expectedResourceAck,
					  startResourceSeq, sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);
			}
                //ack is within the header Case 3
		//                 |<---------sliding window-------->|    
	        //  |<-----hSize------------------------>|<------fileSize---------->|
	        //  |--------------|---------------------|--------------------------|
	        //startHeaderSeq  ack           startResourceSeq           expectedResourceAck 
			else 
			{
			   wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000400, 6); 
			   k1 = tcb->SEQ + k;
			   sendHeader1(tcbrno,tcb->RESPONSEHEADER, k1, expectedHeaderAck, tcb->SEQ,
				       sendf,tcb->IP, tcb->PORT, tcb->CURRENTTASK);  
			   p = k1 +sw -tcb->HSIZE;
			   sendPayload3(tcbrno, tcb->RESOURCE, startResourceSeq, p, startResourceSeq, 
				        sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK); 
			}			
		}
                //ack is within the payload range
	        //  |--------------------|-------------|-------------|
	        //startHeaderSeq  startResourceSeq    ack       expectedResourceAck 
		else if ( cmpVal != 0xFFFFFFFF && cmpVal1 == 0xFFFFFFFF )
		{
		    k = (((unsigned long)tcb->FILESIZE) - mod32cmp(expectedResourceAck, lastAck));
		//ack is within the payload Case 1
		//                                   |<---------sliding window-------->|    
	        //  |<-----hSize------->|<------fileSize----------->|
	        //  |-------------------|------------|--------------|
	        //startHeaderSeq  startResourceSeq  ack         expectedResourceAck 	
		    if ( ( k + sw) >= tcb->FILESIZE)
		    {
			wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000500, 6); 
			k1 = startResourceSeq + k;
		        sendPayload4 (tcbrno, tcb->RESOURCE, k1, expectedResourceAck, startResourceSeq,
		                      sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK);
		    }
		//ack is within the payload Case 2
		//                                   |<-----sliding window---->|    
	        //  |<-----hSize------->|<-----------------fileSize------------------->|
	        //  |-------------------|------------|---------------------------------|
	        //startHeaderSeq  startResourceSeq  ack         expectedResourceAck  
		    else
		    { 
			wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000600, 6); 
			k1 = startResourceSeq + k;
			p = k1 +sw;
		        sendPayload3(tcbrno, tcb->RESOURCE, k1, p, startResourceSeq, 
					sendf, tcb->IP, tcb->PORT, tcb->CURRENTTASK); 	
		    }
		}
	
	       // lst=getLST(TCBRecordNum);
	//	RTT1=RTT;
        //        RTT = CalcRTT(lst,RTT1);
		//task.TaskSleep(TIMER_PERIOD*RTT);	 //HELONG
		//io.AOAprintHex(RTT, Line15+60);

		temptimer = io.AOAgetTimer();

		//io.AOAprintHex(temptimer, Line15+80);
		RTT=getRtt(tcbrno);
		
		wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00030000, 4);
		//-------------------------------------------------------------------------
		tsk.Current_TCBRNo = tcbrno;		// save the record number
		//When a task is suspended, other HTTP tasks can run and create a 
		// concurrency control issue, so save and restore the state of the task 
		//  use TCB for saving parameters 
	        tcb->suspendFlag = 1;  //set the suspend flag 
	        tcb->resumeFlag = 0;   //reset the resume flag 
		task.AOAsuspendHTask(20/*4*(tcb->SRTT)*/, tsk.Current_State, tsk.Current_TCBRNo, currenttask); //second delay 

		//restore TCBRecordNum
		tcbrno = tsk.Current_TCBRNo; 
		//-------------------------------------------------------------------------
		wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00040000, 4);
     
                tcb=(TCBRecord*)(TCBBase + (tcbrno * sizeof(TCBRecord) ));	
	        tcb->suspendFlag = 0;  //reset the suspend flag 

	        //after rtt time, if the tcp is deleted because of rst from client, we terminate tcp
		//
       	        if( tcb->Avail == 0)
		    return 0; 

        	lastAck=getLastAck(tcbrno); 

		//io.AOAprintHex(lastAck, Line17+40);
		//io.AOAprintHex(expectedHeaderAck, Line17+60);
		//io.AOAprintHex(expectedResourceAck, Line17+80);
	
	        if(lastAck < 0 )
        	{
	        //io.AOAprintCharacter('B', Line6+108);
	          if(sendf == 1)
	          {
		    //io.AOAprintCharacter('C', Line6+112);
		    // updateSNDNxt(TCBRecordNum, (startHeaderSeq + hSize + fileSize + 1));	
		    //ClearSendFlag(TCBRecordNum);   
	            sendf = 0; 
	          }
		  return lastAck;
	        } 
	
	    	startResourceSeq = tcb->SEQ + tcb->HSIZE;// Self explanatory  	
		expectedHeaderAck=tcb->SEQ+ tcb->HSIZE; // Assign the expected ack number for header 
		expectedResourceAck=startResourceSeq+ tcb->FILESIZE;// assign the expected ack for resource	

                cmpVal1 = mod32cmp(lastAck,(expectedResourceAck+1));
                //io.AOAprintHex(lastAck, Line24+100);
		//io.AOAprintHex(expectedResourceAck,Line24+120);
                if(cmpVal1 != 0xFFFFFFFF)	
        	{
        	  Sent_Flag = 1;  
		  wlst.insert(tcb->CURRENTTASK, tcbrno, 0x00000020, 7);
        	}
		
		  tempvalue = counter1 & 0x0000000f;
		  tempvalue = tempvalue << 12;
		  wlst.insert(tcb->CURRENTTASK, tcbrno, tempvalue, 5);

        } // end of while
	return 0;
}

//*************************************************************************************************
//This function manages transfer the header data 
//The begining point of data is seqnum, until the last bit with sequence number k3
//*************************************************************************************************
/*
int TCPObj::sendHeader(int TCBRecordNum, char *responseHeader, unsigned long seqnum, unsigned long k3, 
		       unsigned long k2, int sendf, char *ip, char *port, int currenttask)
{
    int k = seqnum - k2;
    int retcode = 0;
    unsigned long j=0;
    int s = sendf;
    int rIndex = 0;
    TCBRecord *tcb;
    tcb=(TCBRecord*)(TCBBase + (TCBRecordNum * sizeof(TCBRecord)));   
   
    rIndex = k;
    for(j=0; k < ( k3 - k2) ; k++,j++ )
    {
        if(j >= TCPSegSize)
	{
	    //io.AOAprintCharacter('L', Line20+120);
	    j = j + 1; 
	    retcode = Send(TCBRecordNum, responseHeader, rIndex, &j, seqnum, TACK, ip, port, currenttask); 
	    if(retcode != 0)		
	    {
		return retcode;
	    } 
	    tcb->noHttpHeaderSent++;
	    seqnum = seqnum + j;
	    j = -1; 
	    rIndex = k + 1;
	}			
   }
   if( j != 0)
   {
	//io.AOAprintCharacter('M', Line20+124);
	retcode = Send(TCBRecordNum, responseHeader, rIndex, &j, seqnum, TACK, ip, port, currenttask);	 
	if(retcode != 0)
	{
       	    return retcode;
	} 
	tcb->noHttpHeaderSent++;
	seqnum = seqnum + j;
   }
	//j = 0 ;
   if(s == 1)
   {
       updateSNDNxt(TCBRecordNum, (k3 + 1)); 
	    //ClearSendFlag(TCBRecordNum);   
       sendf = 0; 
   }
   return 0;
}
*/
//*************************************************************************************************
//This function manages transfer the payload data 
//The begining point of data is seqnum, until the data with sequence number of k3
//*************************************************************************************************
/*
int TCPObj::sendPayload1 (int TCBRecordNum, char *resource, unsigned long seqnum, 
	          unsigned long k3, unsigned long k2, int sendf, char *ip, char *port, int currenttask)
{
    int m = 0; 
    long k = seqnum - k2;
    int retcode = 0;
    unsigned long j = 0;
    int rIndex = 0;
    TCBRecord *tcb;
    tcb=(TCBRecord*)(TCBBase + (TCBRecordNum * sizeof(TCBRecord) )); 
  
    rIndex = k;
    for(j=0; k < (k3 - k2) ; k++,j++ )
    {
	if(j>=TCPSegSize)
	{
	    j = j + 1; 	
	    if ((m * TCPSegSize) > 5000)
	    {
		//io.AOAprintCharacter('r', Line7+64);
   		retcode = Send(TCBRecordNum, resource, rIndex, &j, seqnum, TACK|TPUSH, ip, port, currenttask);  
		if(retcode != 0)
		{
		    return retcode;
		} 
		tcb->noDataSent++;
		m = 0; 
	    }
	    else
	    {
		//io.AOAprintCharacter('s', Line7+68);
		retcode = Send(TCBRecordNum, resource, rIndex, &j, seqnum, TACK, ip, port, currenttask);	 
	    	if(retcode != 0)
	    	{
	            return retcode;
	    	} 
	        tcb->noDataSent++;
	    }
	    m = m + 1; 
	    seqnum = seqnum + j;
	    j = -1; 
	    rIndex = k + 1;
	}			
    }
    if( j != 0)
    {
	//io.AOAprintCharacter('t', Line7+72);
	retcode = Send(TCBRecordNum, resource, rIndex, &j, seqnum, TACK, ip, port, currenttask);	 
	if(retcode != 0)
	{
	    return retcode;
	} 
	tcb->noDataSent++;
	seqnum = seqnum + j;
    }
	//j = -1 ;
    if(sendf == 1)
    {
	//io.AOAprintCharacter('u', Line7+76);
        updateSNDNxt(TCBRecordNum, (k3 + 1)); 
	//ClearSendFlag(TCBRecordNum);   
	sendf = 0; 
    }
    return 0;
}

*/
/*
int TCPObj::sendPayload2(int TCBRecordNum, char *resource, unsigned long seqnum, unsigned long k3, 
	                  unsigned long k2, int sendf, char *ip, char *port, int currenttask)
{
    int m = 0; 
    long k = seqnum - k2;
    int retcode = 0;
    unsigned long j = 0;
    char buffer[2];
    TCBRecord *tcb;
    tcb=(TCBRecord*)(TCBBase + (TCBRecordNum * sizeof(TCBRecord) )); 
    int rIndex = 0;

    rIndex = k;
    for(j=0; k < ( k3 - k2) ; k++,j++ )
    {
	if(j>=TCPSegSize)
	{
	    j = j + 1; 	
	    if ((m * TCPSegSize) > 5000)
	    {
		//io.AOAprintCharacter('r', Line7+64);
   		retcode = Send(TCBRecordNum, resource, rIndex, &j, seqnum, TACK|TPUSH, ip, port, currenttask);  
		if(retcode != 0)
		{
		    return retcode;
		} 
		tcb->noDataSent++;
		m = 0; 
	    }
	    else
	    {
		//io.AOAprintCharacter('s', Line7+68);
		retcode = Send(TCBRecordNum, resource, rIndex, &j, seqnum, TACK, ip, port, currenttask);	 
	    	if(retcode != 0)
	    	{
	            return retcode;
	    	} 
	        tcb->noDataSent++;
	    }
	    m = m + 1; 
	    seqnum = seqnum + j;
	    j = -1; 
	    rIndex = k + 1;
	}			
    }
    if( j != 0)
    {
	//io.AOAprintCharacter('t', Line7+72);
	retcode = Send(TCBRecordNum, resource, rIndex, &j, seqnum, TACK|TFIN, ip, port, currenttask);	 
	if(retcode != 0)
	{
	    return retcode;
	} 
	tcb->noDataSent++;
	seqnum = seqnum + j;
    }
    else
    {
        buffer[0] = '\0';
        retcode = Send(TCBRecordNum, buffer, 0, &j, (k3+1), TACK|TPUSH|TFIN, ip, port, currenttask);
	if(retcode != 0)
	{
	    return retcode;
	} 	
    }
			    
	//j = -1 ;
    if(sendf == 1)
    {
	//io.AOAprintCharacter('u', Line7+76);
        updateSNDNxt(TCBRecordNum, (k3 + 1)); 
	//ClearSendFlag(TCBRecordNum);   
	sendf = 0; 
    }
    tcb->noFinSent++;
    tcb->noDataSent++;
    tcb->state = FINWAIT1;

    return 0;
}
*/
//*************************************
// This function prints IP statistics 
void TCPObj::printStatistics(int Line)
{
AOAProtected io;
io.AOAPrintText("TCP Statistics",Line);
io.AOAPrintText("Total Number of TCP Connections Requested  :",Line + 160);
io.AOAprintHex(noconnreq,Line+ 244 + 4); 
io.AOAPrintText("Total Number of TCP Connections Established:",Line + 320 );
io.AOAprintHex(noconnestab,Line+ 404 + 4);
io.AOAPrintText("Total Number of HTTP Requests              :",Line+ 480 );
io.AOAprintHex(noHttpR,Line+ 564 + 4);
io.AOAPrintText("Total Number of HTTP Requests Processed    :",Line+ 480 + 160 );
io.AOAprintHex(noHttpR,Line+ 564 + 4 + 160);
io.AOAPrintText("Total Number of Active TCP Connections     :",Line+ 480 + 320);
io.AOAprintHex(noconncurr,Line+ 564 + 4 + 320);
io.AOAPrintText("Average Connection Time                    :",Line+ 480 + 320 + 160);
io.AOAprintHex(averageconntime,Line+ 564 + 4 + 320 + 160);
}

//****************************************************************************************************
// send header 1
//****************************************************************************************************
int TCPObj::sendHeader1(int TCBRecordNum, char *responseHeader, unsigned long seqnum, unsigned long k3, 
		       unsigned long k2, int sendf, char *ip, char *port, int currenttask)
{
    int k = seqnum - k2;
    int retcode = 0;
    int s = sendf;
    int rIndex = 0;
    TCBRecord *tcb;
    tcb=(TCBRecord*)(TCBBase + (TCBRecordNum * sizeof(TCBRecord)));   
   
    rIndex = k;
    retcode = SendN(TCBRecordNum, responseHeader, rIndex, seqnum, TACK, ip, port, 0, (k3-k2), 0, currenttask); 
    
    if(retcode != 0)		
    {
	return retcode;
    } 
    tcb->noHttpHeaderSent++;
	//j = 0 ;
    if(s == 1)
    {
       updateSNDNxt(TCBRecordNum, (k3 + 1)); 
	    //ClearSendFlag(TCBRecordNum);   
       sendf = 0; 
    }
    return 0;
}

//*************************************************************************************************
// send payload 3
//*************************************************************************************************
int TCPObj::sendPayload3 (int TCBRecordNum, char *resource, unsigned long seqnum, 
	          unsigned long k3, unsigned long k2, int sendf, char *ip, char *port, int currenttask)
{
    long k = seqnum - k2;
    unsigned long j1 = 0;
    unsigned long n=0;
    int rIndex = 0;
    int retcode = 0;
    TCBRecord *tcb;
    tcb=(TCBRecord*)(TCBBase + (TCBRecordNum * sizeof(TCBRecord) )); 
  
    rIndex = k;

    n = (k3-seqnum)/TCPSegSize;
    j1 = (k3 - seqnum) - (n*TCPSegSize);


	    retcode = SendN(TCBRecordNum, resource, rIndex, seqnum, TACK, ip, port, n, j1, 0, currenttask);  
	    if(retcode != 0)
	    {
	       return retcode;
	    } 
	    tcb->noDataSent++;

	//j = -1 ;
    if(sendf == 1)
    {
        updateSNDNxt(TCBRecordNum, (k3 + 1)); 
	//ClearSendFlag(TCBRecordNum);   
	sendf = 0; 
    }
    return 0;
}


//*************************************************************************************************
//This function manages transfer the payload data 
//The begining point of data is seqnum, until the last bit of data in the payload
//*************************************************************************************************
int TCPObj::sendPayload4 (int TCBRecordNum, char *resource, unsigned long seqnum, unsigned long k3, 
	                  unsigned long k2, int sendf, char *ip, char *port, int currenttask)
{
    int n = 0; 
    long k = seqnum - k2;
    int retcode = 0;
    unsigned long j1 = 0;
    TCBRecord *tcb;
    tcb=(TCBRecord*)(TCBBase + (TCBRecordNum * sizeof(TCBRecord) )); 
    int rIndex = 0;

    rIndex = k;

    n = (k3-seqnum)/TCPSegSize;
    j1 = (k3 - seqnum) - (n*TCPSegSize);


   		retcode = SendN(TCBRecordNum, resource, rIndex, seqnum, TACK, ip, port, n, j1, 1, currenttask);  
		if(retcode != 0)
		{
		    return retcode;
		} 
		tcb->noDataSent++;
			    
    if(sendf == 1)
    {
        updateSNDNxt(TCBRecordNum, (k3 + 1)); 
	//ClearSendFlag(TCBRecordNum);   
	sendf = 0; 
    }
    tcb->noFinSent++;
    tcb->noDataSent++;
    tcb->state = FINWAIT1;

    return 0;
}

//*************************************
// get suspendFlag  
//*************************************
int TCPObj::getSuspendFlag(int tcbrno)
{
   TCBRecord *tcb;
   int flag1; 

   tcb=(TCBRecord*)(TCBBase + (tcbrno * sizeof(TCBRecord) ));
   flag1 = tcb->suspendFlag; 
   return flag1; 
}; 
//*************************************
// get resumeFlag  
//*************************************
int TCPObj::getResumeFlag(int tcbrno)
{
   TCBRecord *tcb;
   int flag1; 

   tcb=(TCBRecord*)(TCBBase + (tcbrno * sizeof(TCBRecord) ));
   flag1 = tcb->resumeFlag; 
   return flag1; 
}; 
//*************************************
// reset resumeFlag  
//*************************************
int TCPObj::resetResumeFlag(int tcbrno)
{
   TCBRecord *tcb;
   int flag1; 

   tcb=(TCBRecord*)(TCBBase + (tcbrno * sizeof(TCBRecord) ));
   tcb->resumeFlag = 0; 
   return 0; 
}; 
